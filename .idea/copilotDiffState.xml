<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/SOLUCION_DEFINITIVA.bat">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/SOLUCION_DEFINITIVA.bat" />
              <option name="updatedContent" value="@echo off&#10;echo ==========================================&#10;echo SOLUCION DEFINITIVA - ERROR GRADLE TASKS&#10;echo ==========================================&#10;cd /d &quot;%~dp0&quot;&#10;&#10;echo.&#10;echo Este script resolvera: &quot;Unable to find Gradle tasks to build&quot;&#10;echo.&#10;pause&#10;&#10;echo.&#10;echo [1/8] Cerrando Android Studio si esta abierto...&#10;echo Por favor, CIERRA Android Studio ahora si esta abierto.&#10;echo.&#10;pause&#10;&#10;echo.&#10;echo [2/8] Deteniendo procesos de Gradle...&#10;call gradlew.bat --stop&#10;timeout /t 3 /nobreak &gt; nul&#10;&#10;echo.&#10;echo [3/8] Eliminando cache del proyecto...&#10;if exist .gradle rmdir /s /q .gradle&#10;if exist .idea rmdir /s /q .idea&#10;if exist .kotlin rmdir /s /q .kotlin&#10;if exist build rmdir /s /q build&#10;if exist app\build rmdir /s /q app\build&#10;&#10;echo.&#10;echo [4/8] Eliminando archivos de configuracion del IDE...&#10;if exist *.iml del /q *.iml&#10;if exist app\*.iml del /q app\*.iml&#10;&#10;echo.&#10;echo [5/8] Limpiando con Gradle...&#10;call gradlew.bat clean&#10;&#10;echo.&#10;echo [6/8] Verificando estructura del proyecto...&#10;call gradlew.bat projects&#10;&#10;echo.&#10;echo [7/8] Listando tareas disponibles...&#10;call gradlew.bat tasks&#10;&#10;echo.&#10;echo [8/8] Compilando el proyecto...&#10;call gradlew.bat assembleDebug&#10;&#10;echo.&#10;echo ==========================================&#10;echo COMPLETADO!&#10;echo ==========================================&#10;echo.&#10;echo Ahora ABRE Android Studio y:&#10;echo 1. Abre este proyecto&#10;echo 2. File ^&gt; Sync Project with Gradle Files&#10;echo 3. Build ^&gt; Rebuild Project&#10;echo.&#10;echo El error deberia estar resuelto.&#10;echo ==========================================&#10;pause&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/appcolegios/academico/CalendarScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/appcolegios/academico/CalendarScreen.kt" />
              <option name="originalContent" value="package com.example.appcolegios.academico&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.gestures.detectHorizontalDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.grid.GridCells&#10;import androidx.compose.foundation.lazy.grid.LazyVerticalGrid&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import kotlinx.coroutines.launch&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.appcolegios.perfil.ProfileViewModel&#10;import com.example.appcolegios.data.UserPreferencesRepository&#10;import com.example.appcolegios.data.UserData&#10;import com.example.appcolegios.data.model.Role&#10;import androidx.compose.ui.platform.LocalContext&#10;import android.util.Log&#10;import com.google.firebase.Timestamp&#10;import com.google.firebase.firestore.ListenerRegistration&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.animation.AnimatedContent&#10;import androidx.compose.animation.ExperimentalAnimationApi&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.animation.slideInHorizontally&#10;import androidx.compose.animation.slideOutHorizontally&#10;import java.time.Instant&#10;import java.time.LocalDate&#10;import java.time.ZoneId&#10;import java.time.temporal.WeekFields&#10;import com.google.firebase.firestore.DocumentSnapshot&#10;import java.util.Locale&#10;&#10;enum class EventSource { USER, GLOBAL }&#10;&#10;data class CalendarEvent(&#10;    val id: String,&#10;    val title: String,&#10;    val description: String,&#10;    val date: Date,&#10;    val type: EventType,&#10;    val source: EventSource = EventSource.USER,&#10;    val ownerId: String? = null // for USER -&gt; userId; for GLOBAL -&gt; courseId or owner&#10;)&#10;&#10;enum class EventType {&#10;    CLASE, EXAMEN, TAREA, EVENTO&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class, ExperimentalAnimationApi::class)&#10;@Composable&#10;fun CalendarScreen() {&#10;    // Separamos mes mostrado y fecha seleccionada&#10;    var displayedMonth by remember { mutableStateOf(Calendar.getInstance()) }&#10;    var selectedDay by remember { mutableStateOf&lt;Calendar?&gt;(Calendar.getInstance()) }&#10;    var showAddEventDialog by remember { mutableStateOf(false) }&#10;    val context = LocalContext.current&#10;&#10;    // Eventos para el mes mostrado (se cargan por rango mediante snapshot listener)&#10;    val events = remember { mutableStateListOf&lt;CalendarEvent&gt;() }&#10;    val auth = FirebaseAuth.getInstance()&#10;    val db = FirebaseFirestore.getInstance()&#10;    // user role and preferences&#10;    val userPrefs = remember { UserPreferencesRepository(context) }&#10;    val userData by userPrefs.userData.collectAsState(initial = UserData(null, null, null))&#10;    val role = userData.roleEnum&#10;    val canCreate = role == Role.DOCENTE || role == Role.PADRE || role == Role.ESTUDIANTE&#10;    val canEdit = role == Role.DOCENTE || role == Role.ESTUDIANTE || role == Role.PADRE&#10;    val canDelete = role == Role.DOCENTE || role == Role.ESTUDIANTE || role == Role.PADRE&#10;    // courses for teacher/student/child selection&#10;    val userCourses = remember { mutableStateListOf&lt;Pair&lt;String,String&gt;&gt;() }&#10;    // Próximos eventos paginados y filtro por tipo&#10;    val upcomingEvents = remember { mutableStateListOf&lt;CalendarEvent&gt;() }&#10;    var upcomingLastSnapshot by remember { mutableStateOf&lt;DocumentSnapshot?&gt;(null) }&#10;    var loadingUpcoming by remember { mutableStateOf(false) }&#10;    val PAGE_SIZE = 25&#10;    var selectedFilterType by remember { mutableStateOf&lt;EventType?&gt;(null) }&#10;&#10;    // Estado del bottom sheet para mostrar eventos del día seleccionado&#10;    var bottomSheetVisible by remember { mutableStateOf(false) }&#10;&#10;    // Estados para edición / borrado (deben existir para las acciones de la lista y bottom sheet)&#10;    var editingEvent by remember { mutableStateOf&lt;CalendarEvent?&gt;(null) }&#10;    var showEditEventDialog by remember { mutableStateOf(false) }&#10;    var eventToDelete by remember { mutableStateOf&lt;CalendarEvent?&gt;(null) }&#10;    var showDeleteConfirm by remember { mutableStateOf(false) }&#10;&#10;    // Profile VM: para padres (lista de hijos)&#10;    val profileVm: ProfileViewModel = viewModel()&#10;    val children by profileVm.children.collectAsState()&#10;    var selectedChildIndex by remember { mutableStateOf(0) }&#10;&#10;    // Listener registration manejado con DisposableEffect: soporta múltiples listeners según rol&#10;    DisposableEffect(displayedMonth.timeInMillis, auth.currentUser?.uid, role, selectedChildIndex) {&#10;        val userId = auth.currentUser?.uid&#10;        val regs = mutableListOf&lt;ListenerRegistration&gt;()&#10;        events.clear()&#10;&#10;        if (userId != null) {&#10;            // calcular primer y ultimo día del mes mostrado&#10;            val start = (displayedMonth.clone() as Calendar).apply {&#10;                set(Calendar.DAY_OF_MONTH, 1)&#10;                set(Calendar.HOUR_OF_DAY, 0)&#10;                set(Calendar.MINUTE, 0)&#10;                set(Calendar.SECOND, 0)&#10;                set(Calendar.MILLISECOND, 0)&#10;            }&#10;            val end = (displayedMonth.clone() as Calendar).apply {&#10;                set(Calendar.DAY_OF_MONTH, getActualMaximum(Calendar.DAY_OF_MONTH))&#10;                set(Calendar.HOUR_OF_DAY, 23)&#10;                set(Calendar.MINUTE, 59)&#10;                set(Calendar.SECOND, 59)&#10;                set(Calendar.MILLISECOND, 999)&#10;            }&#10;            val startTs = Timestamp(start.time)&#10;            val endTs = Timestamp(end.time)&#10;&#10;            try {&#10;                // 1) listener to personal events of the viewed user (teacher sees own personal too)&#10;                val personalListener = db.collection(&quot;users&quot;).document(userId).collection(&quot;events&quot;)&#10;                    .whereGreaterThanOrEqualTo(&quot;date&quot;, startTs)&#10;                    .whereLessThanOrEqualTo(&quot;date&quot;, endTs)&#10;                    .addSnapshotListener { snap, e -&gt;&#10;                        if (e != null) { Log.e(&quot;CalendarScreen&quot;, &quot;Personal listener error: ${e.message}&quot;); return@addSnapshotListener }&#10;                        if (snap != null) {&#10;                            for (doc in snap.documents) {&#10;                                val id = doc.id&#10;                                val title = doc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                                val description = doc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                                val ts = doc.get(&quot;date&quot;)&#10;                                val d = when (ts) { is com.google.firebase.Timestamp -&gt; ts.toDate(); is Date -&gt; ts; else -&gt; null }&#10;                                val type = try { EventType.valueOf(doc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                                if (d != null &amp;&amp; events.none { it.id == id }) events.add(CalendarEvent(id, title, description, d, type, EventSource.USER, userId))&#10;                                val rec = doc.getString(&quot;recurrence&quot;)&#10;                                if (!rec.isNullOrBlank() &amp;&amp; d != null) {&#10;                                    try { val occ = generateOccurrences(d, rec, start.time, end.time); occ.forEachIndexed { idx, occDate -&gt; if (events.none { it.id == &quot;${id}_occ_$idx&quot; }) events.add(CalendarEvent(&quot;${id}_occ_$idx&quot;, title, description, occDate, type, EventSource.USER, userId)) } } catch (_: Exception) {}&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                regs.add(personalListener)&#10;&#10;                // 2) role-specific: teacher -&gt; events for their courses; student -&gt; events for courses enrolled; parent -&gt; events for selected child&#10;                when (role) {&#10;                    Role.DOCENTE -&gt; {&#10;                        // get course ids taught by teacher&#10;                        val courseIds = mutableListOf&lt;String&gt;()&#10;                        try {&#10;                            val q = db.collection(&quot;courses&quot;).whereEqualTo(&quot;teacherId&quot;, userId).get()&#10;                            q.addOnSuccessListener { snap -&gt;&#10;                                userCourses.clear()&#10;                                for (doc in snap.documents) {&#10;                                    val cid = doc.id&#10;                                    courseIds.add(cid)&#10;                                    val cname = doc.getString(&quot;name&quot;) ?: doc.getString(&quot;title&quot;) ?: cid&#10;                                    userCourses.add(Pair(cid, cname))&#10;                                }&#10;                                // query top-level events where courseId in courseIds, chunked by 10&#10;                                if (courseIds.isNotEmpty()) {&#10;                                    courseIds.chunked(10).forEach { chunk -&gt;&#10;                                        val evQuery = db.collection(&quot;events&quot;).whereIn(&quot;courseId&quot;, chunk).whereGreaterThanOrEqualTo(&quot;date&quot;, startTs).whereLessThanOrEqualTo(&quot;date&quot;, endTs)&#10;                                        val r = evQuery.addSnapshotListener { snap2, e2 -&gt;&#10;                                            if (e2 != null) { Log.e(&quot;CalendarScreen&quot;,&quot;Course events listener err: ${e2.message}&quot;); return@addSnapshotListener }&#10;                                            if (snap2 != null) {&#10;                                                for (doc in snap2.documents) {&#10;                                                    val id = doc.id&#10;                                                    val title = doc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                                                    val description = doc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                                                    val ts = doc.get(&quot;date&quot;)&#10;                                                    val d = when (ts) { is com.google.firebase.Timestamp -&gt; ts.toDate(); is Date -&gt; ts; else -&gt; null }&#10;                                                    val type = try { EventType.valueOf(doc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                                                    if (d != null &amp;&amp; events.none { it.id == id }) events.add(CalendarEvent(id, title, description, d, type, EventSource.GLOBAL, null))&#10;                                                }&#10;                                            }&#10;                                        }&#10;                                        regs.add(r)&#10;                                    }&#10;                                }&#10;                            }&#10;                        } catch (_: Exception) { }&#10;                    }&#10;                    Role.ESTUDIANTE -&gt; {&#10;                        // student: read student doc for courses&#10;                        try {&#10;                            val sdocTask = db.collection(&quot;students&quot;).document(userId).get()&#10;                            sdocTask.addOnSuccessListener { sdoc -&gt;&#10;                                val courseIds = (sdoc.get(&quot;courses&quot;) as? List&lt;*&gt;)?.mapNotNull { it?.toString() } ?: emptyList()&#10;                                // populate userCourses with names&#10;                                userCourses.clear()&#10;                                for (cid in courseIds) {&#10;                                    db.collection(&quot;courses&quot;).document(cid).get().addOnSuccessListener { cdoc -&gt;&#10;                                        if (cdoc.exists()) userCourses.add(Pair(cid, cdoc.getString(&quot;name&quot;) ?: cid))&#10;                                    }&#10;                                }&#10;                                if (courseIds.isNotEmpty()) {&#10;                                    courseIds.chunked(10).forEach { chunk -&gt;&#10;                                        val evQuery = db.collection(&quot;events&quot;).whereIn(&quot;courseId&quot;, chunk).whereGreaterThanOrEqualTo(&quot;date&quot;, startTs).whereLessThanOrEqualTo(&quot;date&quot;, endTs)&#10;                                        val r = evQuery.addSnapshotListener { snap2, e2 -&gt;&#10;                                            if (e2 != null) return@addSnapshotListener&#10;                                            if (snap2 != null) {&#10;                                                for (doc in snap2.documents) {&#10;                                                    val id = doc.id&#10;                                                    val title = doc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                                                    val description = doc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                                                    val ts = doc.get(&quot;date&quot;)&#10;                                                    val d = when (ts) { is com.google.firebase.Timestamp -&gt; ts.toDate(); is Date -&gt; ts; else -&gt; null }&#10;                                                    val type = try { EventType.valueOf(doc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                                                    if (d != null &amp;&amp; events.none { it.id == id }) events.add(CalendarEvent(id, title, description, d, type, EventSource.GLOBAL, null))&#10;                                                }&#10;                                            }&#10;                                        }&#10;                                        regs.add(r)&#10;                                    }&#10;                                }&#10;                            }&#10;                        } catch (_: Exception) { }&#10;                    }&#10;                    Role.PADRE -&gt; {&#10;                        // parent: use selected child&#10;                        val childId = children.getOrNull(selectedChildIndex)?.id&#10;                        if (!childId.isNullOrBlank()) {&#10;                            // personal events of child&#10;                            val childListener = db.collection(&quot;users&quot;).document(childId).collection(&quot;events&quot;)&#10;                                .whereGreaterThanOrEqualTo(&quot;date&quot;, startTs)&#10;                                .whereLessThanOrEqualTo(&quot;date&quot;, endTs)&#10;                                .addSnapshotListener { snap, e -&gt;&#10;                                    if (e != null) { Log.e(&quot;CalendarScreen&quot;, &quot;Child listener error: ${e.message}&quot;); return@addSnapshotListener }&#10;                                    if (snap != null) {&#10;                                        for (doc in snap.documents) {&#10;                                            val id = doc.id&#10;                                            val title = doc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                                            val description = doc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                                            val ts = doc.get(&quot;date&quot;)&#10;                                            val d = when (ts) { is com.google.firebase.Timestamp -&gt; ts.toDate(); is Date -&gt; ts; else -&gt; null }&#10;                                            val type = try { EventType.valueOf(doc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                                            if (d != null &amp;&amp; events.none { it.id == id }) events.add(CalendarEvent(id, title, description, d, type, EventSource.USER, childId))&#10;                                        }&#10;                                    }&#10;                                }&#10;                            regs.add(childListener)&#10;&#10;                            // also load course events for that child (like student)&#10;                            try {&#10;                                val sdocTask = db.collection(&quot;students&quot;).document(childId).get()&#10;                                sdocTask.addOnSuccessListener { sdoc -&gt;&#10;                                    val courseIds = (sdoc.get(&quot;courses&quot;) as? List&lt;*&gt;)?.mapNotNull { it?.toString() } ?: emptyList()&#10;                                    if (courseIds.isNotEmpty()) {&#10;                                        courseIds.chunked(10).forEach { chunk -&gt;&#10;                                            val evQuery = db.collection(&quot;events&quot;).whereIn(&quot;courseId&quot;, chunk).whereGreaterThanOrEqualTo(&quot;date&quot;, startTs).whereLessThanOrEqualTo(&quot;date&quot;, endTs)&#10;                                            val r = evQuery.addSnapshotListener { snap2, e2 -&gt;&#10;                                                if (e2 != null) { Log.e(&quot;CalendarScreen&quot;, &quot;Child course events listener err: ${e2.message}&quot;); return@addSnapshotListener }&#10;                                                if (snap2 != null) {&#10;                                                    for (doc in snap2.documents) {&#10;                                                        val id = doc.id&#10;                                                        val title = doc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                                                        val description = doc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                                                        val ts = doc.get(&quot;date&quot;)&#10;                                                        val d = when (ts) { is com.google.firebase.Timestamp -&gt; ts.toDate(); is Date -&gt; ts; else -&gt; null }&#10;                                                        val type = try { EventType.valueOf(doc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                                                        if (d != null &amp;&amp; events.none { it.id == id }) events.add(CalendarEvent(id, title, description, d, type, EventSource.GLOBAL, doc.getString(&quot;courseId&quot;)))&#10;                                                    }&#10;                                                }&#10;                                            }&#10;                                            regs.add(r)&#10;                                        }&#10;                                    }&#10;                                }&#10;                            } catch (_: Exception) {}&#10;                        }&#10;                    }&#10;                    else -&gt; {&#10;                        // default: no extra listeners&#10;                    }&#10;                }&#10;            } catch (ex: Exception) {&#10;                Log.e(&quot;CalendarScreen&quot;, &quot;Error starting listeners: ${ex.message}&quot;, ex)&#10;            }&#10;        }&#10;&#10;        onDispose {&#10;            regs.forEach { try { it.remove() } catch (_: Exception) {} }&#10;        }&#10;    }&#10;&#10;    // Snackbar / scaffold&#10;    val snackbarHostState = remember { SnackbarHostState() }&#10;    val scope = rememberCoroutineScope()&#10;&#10;    Scaffold(&#10;        snackbarHost = { SnackbarHost(hostState = snackbarHostState) }&#10;    ) { innerPadding -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(innerPadding)&#10;                .padding(16.dp)&#10;        ) {&#10;            // Header con mes actual&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                IconButton(onClick = {&#10;                    displayedMonth = (displayedMonth.clone() as Calendar).apply { add(Calendar.MONTH, -1) }&#10;                }) {&#10;                    Icon(Icons.Filled.ChevronLeft, contentDescription = &quot;Mes anterior&quot;)&#10;                }&#10;&#10;                Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                    Text(&#10;                        text = SimpleDateFormat(&quot;MMMM yyyy&quot;, Locale.getDefault()).format(displayedMonth.time),&#10;                        style = MaterialTheme.typography.titleLarge,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;                    TextButton(onClick = { // volver a hoy&#10;                        displayedMonth = Calendar.getInstance()&#10;                        selectedDay = Calendar.getInstance()&#10;                    }) { Text(&quot;Hoy&quot;) }&#10;&#10;                    // selector de hijo para PADRE&#10;                    if (role == Role.PADRE) {&#10;                        Spacer(Modifier.height(8.dp))&#10;                        Row(verticalAlignment = Alignment.CenterVertically) {&#10;                            Text(&quot;Hijo: &quot;)&#10;                            if (children.isEmpty()) {&#10;                                Text(&quot;(sin hijos)&quot;)&#10;                            } else {&#10;                                var expanded by remember { mutableStateOf(false) }&#10;                                val label = children.getOrNull(selectedChildIndex)?.nombre ?: &quot;Seleccionar&quot;&#10;                                Box {&#10;                                    TextButton(onClick = { expanded = true }) { Text(label) }&#10;                                    DropdownMenu(expanded = expanded, onDismissRequest = { expanded = false }) {&#10;                                        children.forEachIndexed { idx, child -&gt;&#10;                                            DropdownMenuItem(text = { Text(child.nombre) }, onClick = { selectedChildIndex = idx; expanded = false })&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                IconButton(onClick = {&#10;                    displayedMonth = (displayedMonth.clone() as Calendar).apply { add(Calendar.MONTH, 1) }&#10;                }) {&#10;                    Icon(Icons.Filled.ChevronRight, contentDescription = &quot;Mes siguiente&quot;)&#10;                }&#10;            }&#10;&#10;            Spacer(Modifier.height(16.dp))&#10;&#10;            // Días de la semana -- respetar locale (primer día simplificado)&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceEvenly&#10;            ) {&#10;                // Obtener nombres de días desde locale&#10;                val df = SimpleDateFormat(&quot;EE&quot;, Locale.getDefault())&#10;                val headerCal = Calendar.getInstance()&#10;                // usar firstDayOfWeek del locale&#10;                val firstDow = headerCal.firstDayOfWeek&#10;                for (i in 0 until 7) {&#10;                    headerCal.set(Calendar.DAY_OF_WEEK, (firstDow + i - 1) % 7 + 1)&#10;                    Text(&#10;                        text = df.format(headerCal.time),&#10;                        modifier = Modifier.weight(1f),&#10;                        textAlign = TextAlign.Center,&#10;                        style = MaterialTheme.typography.labelMedium,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = MaterialTheme.colorScheme.primary&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(Modifier.height(8.dp))&#10;&#10;            // Grid del calendario con fecha seleccionada y soporte swipe/anim&#10;            Box(modifier = Modifier&#10;                .fillMaxWidth()&#10;                .height(320.dp)&#10;                .pointerInput(Unit) {&#10;                    detectHorizontalDragGestures { change, dragAmount -&gt;&#10;                        val threshold = 150&#10;                        if (dragAmount &gt; threshold) {&#10;                            // swipe derecha -&gt; mes anterior&#10;                            displayedMonth = (displayedMonth.clone() as Calendar).apply { add(Calendar.MONTH, -1) }&#10;                        } else if (dragAmount &lt; -threshold) {&#10;                            // swipe izquierda -&gt; mes siguiente&#10;                            displayedMonth = (displayedMonth.clone() as Calendar).apply { add(Calendar.MONTH, 1) }&#10;                        }&#10;                    }&#10;                }&#10;            ) {&#10;                AnimatedContent(targetState = displayedMonth.timeInMillis, transitionSpec = {&#10;                    slideInHorizontally(initialOffsetX = { fullWidth -&gt; if (targetState &gt; initialState) fullWidth else -fullWidth }, animationSpec = tween(300))&#10;                        .togetherWith(slideOutHorizontally(targetOffsetX = { fullWidth -&gt; if (targetState &gt; initialState) -fullWidth else fullWidth }, animationSpec = tween(300)))&#10;                }) { _ -&gt;&#10;                     CalendarGrid(&#10;                         displayedMonth = displayedMonth,&#10;                         selectedDay = selectedDay,&#10;                         events = events,&#10;                         onDateSelected = { cal -&gt;&#10;                             selectedDay = cal&#10;                             bottomSheetVisible = true&#10;                         }&#10;                     )&#10;                 }&#10;             }&#10;&#10;            Spacer(Modifier.height(16.dp))&#10;&#10;            // Botón para agregar evento&#10;            Button(&#10;                onClick = { showAddEventDialog = true },&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Icon(Icons.Filled.Add, contentDescription = &quot;Agregar evento&quot;)&#10;                Spacer(Modifier.width(8.dp))&#10;                Text(&quot;Agregar Evento&quot;)&#10;            }&#10;&#10;            Spacer(Modifier.height(16.dp))&#10;&#10;            // Lista de próximos eventos (paginated) con filtro por tipo&#10;            Text(&#10;                &quot;Próximos Eventos&quot;,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;&#10;            Spacer(Modifier.height(8.dp))&#10;&#10;            // Filtro por tipo&#10;            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                Text(&quot;Filtrar: &quot;)&#10;                Spacer(Modifier.width(8.dp))&#10;                // botones simples para filtrar por tipo&#10;                EventType.entries.let { types -&gt;&#10;                    types.forEach { t -&gt;&#10;                         val selected = selectedFilterType == t&#10;                         TextButton(onClick = { selectedFilterType = if (selected) null else t }) {&#10;                             Text(t.name, color = if (selected) MaterialTheme.colorScheme.onPrimary else MaterialTheme.colorScheme.onSurface)&#10;                         }&#10;                     }&#10;                 }&#10;            }&#10;&#10;            Spacer(Modifier.height(8.dp))&#10;&#10;            // carga inicial de upcoming en background (no duplicar si ya cargado)&#10;            LaunchedEffect(auth.currentUser?.uid) {&#10;                upcomingEvents.clear()&#10;                upcomingLastSnapshot = null&#10;                // pasar los courseIds disponibles (si ya se cargaron) para traer también eventos globales&#10;                val courseIds = userCourses.map { it.first }&#10;                loadMoreUpcoming(db, auth, upcomingEvents, role, courseIds) { doc -&gt; upcomingLastSnapshot = doc }&#10;            }&#10;&#10;            val displayedUpcoming = if (selectedFilterType == null) upcomingEvents.toList() else upcomingEvents.filter { it.type == selectedFilterType }&#10;&#10;            LazyColumn(&#10;                 verticalArrangement = Arrangement.spacedBy(8.dp)&#10;             ) {&#10;                items(displayedUpcoming) { event -&gt;&#10;                    // per-event permissions: owner can edit/delete USER events; DOCENTE can edit/delete GLOBAL events&#10;                    val uid = auth.currentUser?.uid&#10;                    val allowEdit = when (event.source) {&#10;                        EventSource.USER -&gt; event.ownerId == uid&#10;                        EventSource.GLOBAL -&gt; role == Role.DOCENTE&#10;                    }&#10;                    val allowDelete = allowEdit&#10;                    EventCard(event,&#10;                        onEdit = if (allowEdit) { ev -&gt; editingEvent = ev; showEditEventDialog = true } else null,&#10;                        onDelete = if (allowDelete) { ev -&gt; eventToDelete = ev; showDeleteConfirm = true } else null&#10;                    )&#10;                }&#10;                item {&#10;                    Spacer(Modifier.height(6.dp))&#10;                    Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.Center) {&#10;                        val courseIds = userCourses.map { it.first }&#10;                        if (upcomingLastSnapshot != null) {&#10;                            Button(onClick = { loadMoreUpcoming(db, auth, upcomingEvents, role, courseIds) { doc -&gt; upcomingLastSnapshot = doc } }) { Text(&quot;Cargar más&quot;) }&#10;                        }&#10;                    }&#10;                 }&#10;             }&#10;         }&#10;     }&#10;&#10;    // Bottom sheet para eventos del día seleccionado (simple Modal)&#10;    if (bottomSheetVisible &amp;&amp; selectedDay != null) {&#10;        val selLocal = LocalDate.of(selectedDay!!.get(Calendar.YEAR), selectedDay!!.get(Calendar.MONTH)+1, selectedDay!!.get(Calendar.DAY_OF_MONTH))&#10;        val dayEvents = events.filter { ev -&gt;&#10;            val evLocal = Instant.ofEpochMilli(ev.date.time).atZone(ZoneId.systemDefault()).toLocalDate()&#10;            evLocal == selLocal&#10;        }.sortedBy { it.date }&#10;&#10;        ModalBottomSheet(&#10;            onDismissRequest = { bottomSheetVisible = false }&#10;        ) {&#10;            Column(modifier = Modifier.padding(16.dp)) {&#10;                Text(&quot;Eventos en ${SimpleDateFormat(&quot;dd/MM/yyyy&quot;, Locale.getDefault()).format(selectedDay!!.time)}&quot;, style = MaterialTheme.typography.titleMedium, fontWeight = FontWeight.Bold)&#10;                Spacer(Modifier.height(8.dp))&#10;                if (dayEvents.isEmpty()) {&#10;                    Text(&quot;No hay eventos para este día&quot;, color = MaterialTheme.colorScheme.onSurfaceVariant)&#10;                } else {&#10;                    dayEvents.forEach { ev -&gt;&#10;                        val uid = auth.currentUser?.uid&#10;                        val allowEdit = when (ev.source) {&#10;                            EventSource.USER -&gt; ev.ownerId == uid&#10;                            EventSource.GLOBAL -&gt; role == Role.DOCENTE&#10;                        }&#10;                        val allowDelete = allowEdit&#10;                        EventCard(ev,&#10;                            onEdit = if (allowEdit) { e -&gt; editingEvent = e; showEditEventDialog = true } else null,&#10;                            onDelete = if (allowDelete) { e -&gt; eventToDelete = e; showDeleteConfirm = true } else null&#10;                        )&#10;                        Spacer(Modifier.height(8.dp))&#10;                    }&#10;                }&#10;                Spacer(Modifier.height(8.dp))&#10;                Row(horizontalArrangement = Arrangement.End, modifier = Modifier.fillMaxWidth()) {&#10;                    TextButton(onClick = { bottomSheetVisible = false }) { Text(&quot;Cerrar&quot;) }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    if (showAddEventDialog) {&#10;        AddEventDialog(&#10;            initialDate = selectedDay?.time ?: displayedMonth.time,&#10;            onDismiss = { showAddEventDialog = false },&#10;            onSave = { title, description, date, type, targetCourseId -&gt;&#10;                val userId = auth.currentUser?.uid&#10;                if (userId == null) {&#10;                    scope.launch { snackbarHostState.showSnackbar(&quot;Debes iniciar sesión para agregar eventos&quot;) }&#10;                    return@AddEventDialog&#10;                }&#10;                val db = FirebaseFirestore.getInstance()&#10;                val eventId = UUID.randomUUID().toString()&#10;                val eventData = hashMapOf&lt;String, Any?&gt;(&#10;                    &quot;id&quot; to eventId,&#10;                    &quot;title&quot; to title,&#10;                    &quot;description&quot; to description,&#10;                    &quot;date&quot; to Timestamp(date),&#10;                    &quot;type&quot; to type.name,&#10;                    &quot;createdAt&quot; to Timestamp.now(),&#10;                    &quot;ownerId&quot; to userId&#10;                )&#10;                // If teacher selected a course target, save as global event in top-level collection&#10;                if (role == Role.DOCENTE &amp;&amp; !targetCourseId.isNullOrBlank()) {&#10;                    eventData[&quot;courseId&quot;] = targetCourseId&#10;                    db.collection(&quot;events&quot;).document(eventId)&#10;                        .set(eventData)&#10;                        .addOnSuccessListener {&#10;                            events.add(CalendarEvent(eventId, title, description, date, type, EventSource.GLOBAL, targetCourseId))&#10;                            showAddEventDialog = false&#10;                            scope.launch { snackbarHostState.showSnackbar(&quot;Evento de curso agregado&quot;) }&#10;                        }&#10;                        .addOnFailureListener { e -&gt;&#10;                            Log.e(&quot;CalendarScreen&quot;, &quot;Error saving global event: ${e.message}&quot;, e)&#10;                            scope.launch { snackbarHostState.showSnackbar(&quot;Error guardando evento&quot;) }&#10;                        }&#10;                } else {&#10;                    // save personal event under users/{uid}/events&#10;                    db.collection(&quot;users&quot;).document(userId).collection(&quot;events&quot;).document(eventId)&#10;                        .set(eventData)&#10;                        .addOnSuccessListener {&#10;                            events.add(CalendarEvent(eventId, title, description, date, type, EventSource.USER, userId))&#10;                            showAddEventDialog = false&#10;                            scope.launch { snackbarHostState.showSnackbar(&quot;Evento agregado&quot;) }&#10;                        }&#10;                        .addOnFailureListener { e -&gt;&#10;                            Log.e(&quot;CalendarScreen&quot;, &quot;Error saving personal event: ${e.message}&quot;, e)&#10;                            scope.launch { snackbarHostState.showSnackbar(&quot;Error guardando evento&quot;) }&#10;                        }&#10;                }&#10;            },&#10;            role = role,&#10;            userCourses = userCourses.toList()&#10;        )&#10;    }&#10;&#10;    // handle actual deletion when confirmed&#10;    if (showDeleteConfirm &amp;&amp; eventToDelete != null) {&#10;        AlertDialog(onDismissRequest = { showDeleteConfirm = false; eventToDelete = null }, title = { Text(&quot;Confirmar eliminación&quot;) }, text = { Text(&quot;Eliminar evento '${eventToDelete!!.title}'?&quot;) }, confirmButton = {&#10;            TextButton(onClick = {&#10;                val uid = auth.currentUser?.uid ?: run { showDeleteConfirm = false; eventToDelete = null; return@TextButton }&#10;                val ev = eventToDelete&#10;                if (ev == null) return@TextButton&#10;                if (ev.source == EventSource.USER) {&#10;                    // delete under owner user's events&#10;                    val owner = ev.ownerId ?: uid&#10;                    db.collection(&quot;users&quot;).document(owner).collection(&quot;events&quot;).document(ev.id)&#10;                        .delete()&#10;                        .addOnSuccessListener {&#10;                            events.removeAll { it.id == ev.id }&#10;                            upcomingEvents.removeAll { it.id == ev.id }&#10;                            showDeleteConfirm = false&#10;                            eventToDelete = null&#10;                        }&#10;                        .addOnFailureListener { ex -&gt;&#10;                            scope.launch { snackbarHostState.showSnackbar(&quot;Error eliminando: ${ex.localizedMessage}&quot;) }&#10;                            showDeleteConfirm = false; eventToDelete = null&#10;                        }&#10;                } else {&#10;                    // global event stored in top-level 'events'&#10;                    db.collection(&quot;events&quot;).document(ev.id)&#10;                        .delete()&#10;                        .addOnSuccessListener {&#10;                            events.removeAll { it.id == ev.id }&#10;                            upcomingEvents.removeAll { it.id == ev.id }&#10;                            showDeleteConfirm = false&#10;                            eventToDelete = null&#10;                        }&#10;                        .addOnFailureListener { ex -&gt;&#10;                            scope.launch { snackbarHostState.showSnackbar(&quot;Error eliminando: ${ex.localizedMessage}&quot;) }&#10;                            showDeleteConfirm = false; eventToDelete = null&#10;                        }&#10;                }&#10;            }) { Text(&quot;Eliminar&quot;) }&#10;        }, dismissButton = { TextButton(onClick = { showDeleteConfirm = false; eventToDelete = null }) { Text(&quot;Cancelar&quot;) } })&#10;    }&#10;&#10;    // Edit dialog&#10;    if (showEditEventDialog &amp;&amp; editingEvent != null) {&#10;        EditEventDialog(event = editingEvent!!, onDismiss = { showEditEventDialog = false; editingEvent = null }, onSave = { updated -&gt;&#10;             val uid = auth.currentUser?.uid ?: return@EditEventDialog&#10;             val map = mapOf(&quot;title&quot; to updated.title, &quot;description&quot; to updated.description, &quot;date&quot; to Timestamp(updated.date), &quot;type&quot; to updated.type.name)&#10;             // update in appropriate collection based on source&#10;             if (updated.source == EventSource.USER) {&#10;                // actualizar en la colección del owner (no asumir uid actual)&#10;                val owner = updated.ownerId ?: uid&#10;                db.collection(&quot;users&quot;).document(owner).collection(&quot;events&quot;).document(updated.id)&#10;                    .update(map)&#10;                    .addOnSuccessListener {&#10;                        fun replace(list: MutableList&lt;CalendarEvent&gt;) {&#10;                            val idx = list.indexOfFirst { it.id == updated.id }&#10;                            if (idx &gt;= 0) list[idx] = updated&#10;                        }&#10;                        replace(events)&#10;                        replace(upcomingEvents)&#10;                        showEditEventDialog = false; editingEvent = null&#10;                    }&#10;                    .addOnFailureListener { ex -&gt; scope.launch { snackbarHostState.showSnackbar(&quot;Error actualizando: ${ex.localizedMessage}&quot;) } }&#10;             } else {&#10;                 // teacher editing global event&#10;                 val mapWithCourse = hashMapOf&lt;String, Any?&gt;()&#10;                 mapWithCourse.putAll(map)&#10;                 if (!updated.ownerId.isNullOrBlank()) mapWithCourse[&quot;courseId&quot;] = updated.ownerId&#10;                 db.collection(&quot;events&quot;).document(updated.id).update(mapWithCourse as Map&lt;String, Any?&gt;)&#10;                      .addOnSuccessListener {&#10;                          fun replace(list: MutableList&lt;CalendarEvent&gt;) {&#10;                              val idx = list.indexOfFirst { it.id == updated.id }&#10;                              if (idx &gt;= 0) list[idx] = updated&#10;                          }&#10;                          replace(events)&#10;                          replace(upcomingEvents)&#10;                          showEditEventDialog = false; editingEvent = null&#10;                      }&#10;                      .addOnFailureListener { ex -&gt; scope.launch { snackbarHostState.showSnackbar(&quot;Error actualizando: ${ex.localizedMessage}&quot;) } }&#10;             }&#10;         }, role = role, userCourses = userCourses.toList())&#10;      }&#10;}&#10;&#10;// Generador simple de ocurrencias para recurrencia básica&#10;fun generateOccurrences(startDate: Date, recurrence: String, rangeStart: Date, rangeEnd: Date): List&lt;Date&gt; {&#10;     val res = mutableListOf&lt;Date&gt;()&#10;     val cal = Calendar.getInstance().apply { time = startDate }&#10;     val endRangeCal = Calendar.getInstance().apply { time = rangeEnd }&#10;     val startRangeCal = Calendar.getInstance().apply { time = rangeStart }&#10;&#10;     when (recurrence.uppercase(Locale.getDefault())) {&#10;         &quot;DAILY&quot; -&gt; {&#10;             // avanzar hasta &gt;= startRange&#10;             while (cal.before(startRangeCal)) cal.add(Calendar.DAY_OF_MONTH, 1)&#10;             while (!cal.after(endRangeCal)) {&#10;                 res.add(cal.time)&#10;                 cal.add(Calendar.DAY_OF_MONTH, 1)&#10;             }&#10;         }&#10;         &quot;WEEKLY&quot; -&gt; {&#10;             while (cal.before(startRangeCal)) cal.add(Calendar.WEEK_OF_YEAR, 1)&#10;             while (!cal.after(endRangeCal)) {&#10;                 res.add(cal.time)&#10;                 cal.add(Calendar.WEEK_OF_YEAR, 1)&#10;             }&#10;         }&#10;         &quot;MONTHLY&quot; -&gt; {&#10;             while (cal.before(startRangeCal)) cal.add(Calendar.MONTH, 1)&#10;             while (!cal.after(endRangeCal)) {&#10;                 res.add(cal.time)&#10;                 cal.add(Calendar.MONTH, 1)&#10;             }&#10;         }&#10;         else -&gt; { /* no soportado */ }&#10;     }&#10;&#10;     return res&#10; }&#10;&#10;@Composable&#10;private fun CalendarGrid(&#10;    displayedMonth: Calendar,&#10;    selectedDay: Calendar?,&#10;    events: List&lt;CalendarEvent&gt;,&#10;    onDateSelected: (Calendar) -&gt; Unit&#10;) {&#10;    val calendar = (displayedMonth.clone() as Calendar).apply { set(Calendar.DAY_OF_MONTH, 1) }&#10;    // determinar primer día de semana según locale/WeekFields&#10;    val firstDowField = WeekFields.of(Locale.getDefault()).firstDayOfWeek&#10;    val firstDayOfWeek = (firstDowField.value - 1) // DayOfWeek.MONDAY.value==1&#10;    val daysInMonth = calendar.getActualMaximum(Calendar.DAY_OF_MONTH)&#10;&#10;    val today = Calendar.getInstance()&#10;&#10;    LazyVerticalGrid(&#10;        columns = GridCells.Fixed(7),&#10;        modifier = Modifier.height(300.dp)&#10;    ) {&#10;        // Espacios en blanco antes del primer día&#10;        items(firstDayOfWeek) {&#10;            Box(modifier = Modifier.aspectRatio(1f))&#10;        }&#10;&#10;        // Días del mes&#10;        items(daysInMonth) { day -&gt;&#10;            val dayNumber = day + 1&#10;            val thisDay = (calendar.clone() as Calendar).apply { set(Calendar.DAY_OF_MONTH, dayNumber) }&#10;&#10;            // usar LocalDate para evitar problemas de zona/hora&#10;            val thisLocal = Instant.ofEpochMilli(thisDay.time.time).atZone(ZoneId.systemDefault()).toLocalDate()&#10;&#10;            val dayEvents = events.filter { ev -&gt;&#10;                val evLocal = Instant.ofEpochMilli(ev.date.time).atZone(ZoneId.systemDefault()).toLocalDate()&#10;                evLocal == thisLocal&#10;            }&#10;            val hasEvent = dayEvents.isNotEmpty()&#10;&#10;            val isToday = Instant.ofEpochMilli(today.time.time).atZone(ZoneId.systemDefault()).toLocalDate() == thisLocal&#10;&#10;            val isSelected = selectedDay?.let { sel -&gt;&#10;                val selLocal = Instant.ofEpochMilli(sel.time.time).atZone(ZoneId.systemDefault()).toLocalDate()&#10;                selLocal == thisLocal&#10;            } ?: false&#10;&#10;            Box(&#10;                modifier = Modifier&#10;                    .aspectRatio(1f)&#10;                    .padding(2.dp)&#10;                    .clip(CircleShape)&#10;                    .background(&#10;                        color = when {&#10;                            isSelected -&gt; MaterialTheme.colorScheme.primary.copy(alpha = 0.25f)&#10;                            isToday -&gt; MaterialTheme.colorScheme.primaryContainer&#10;                            hasEvent -&gt; MaterialTheme.colorScheme.secondaryContainer.copy(alpha = 0.5f)&#10;                            else -&gt; Color.Transparent&#10;                        }&#10;                    )&#10;                    .clickable { onDateSelected(thisDay) },&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Column(&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    Text(&#10;                        text = dayNumber.toString(),&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        fontWeight = if (isToday || isSelected) FontWeight.Bold else FontWeight.Normal,&#10;                        color = if (isToday || isSelected) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.onSurface&#10;                    )&#10;                    if (hasEvent) {&#10;                        // mostrar hasta 3 puntos de colores según tipos distintos&#10;                        val types = dayEvents.map { it.type }.distinct()&#10;                        val maxDots = 3&#10;                        Row(horizontalArrangement = Arrangement.Center, verticalAlignment = Alignment.CenterVertically) {&#10;                            types.take(maxDots).forEach { t -&gt;&#10;                                val dotColor = when (t) {&#10;                                    EventType.CLASE -&gt; Color(0xFF2196F3)&#10;                                    EventType.EXAMEN -&gt; Color(0xFFF44336)&#10;                                    EventType.TAREA -&gt; Color(0xFFFFC107)&#10;                                    EventType.EVENTO -&gt; Color(0xFF4CAF50)&#10;                                }&#10;                                Box(modifier = Modifier.size(6.dp).background(dotColor, CircleShape))&#10;                                Spacer(Modifier.width(4.dp))&#10;                            }&#10;                            if (types.size &gt; maxDots) {&#10;                                Text(&quot;+${types.size - maxDots}&quot;, style = MaterialTheme.typography.bodySmall)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun EventCard(event: CalendarEvent, onEdit: ((CalendarEvent) -&gt; Unit)? = null, onDelete: ((CalendarEvent) -&gt; Unit)? = null) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Icon(&#10;                imageVector = when (event.type) {&#10;                    EventType.CLASE -&gt; Icons.Filled.School&#10;                    EventType.EXAMEN -&gt; Icons.Filled.Warning&#10;                    EventType.TAREA -&gt; Icons.AutoMirrored.Filled.Assignment&#10;                    EventType.EVENTO -&gt; Icons.AutoMirrored.Filled.EventNote&#10;                },&#10;                contentDescription = null,&#10;                tint = when (event.type) {&#10;                    EventType.CLASE -&gt; Color(0xFF2196F3)&#10;                    EventType.EXAMEN -&gt; Color(0xFFF44336)&#10;                    EventType.TAREA -&gt; Color(0xFFFFC107)&#10;                    EventType.EVENTO -&gt; Color(0xFF4CAF50)&#10;                }&#10;            )&#10;            Spacer(Modifier.width(12.dp))&#10;            Column(modifier = Modifier.weight(1f)) {&#10;                Text(event.title, style = MaterialTheme.typography.titleSmall, fontWeight = FontWeight.SemiBold)&#10;                Text(SimpleDateFormat(&quot;dd/MM/yyyy HH:mm&quot;, Locale.getDefault()).format(event.date), style = MaterialTheme.typography.bodySmall, color = MaterialTheme.colorScheme.onSurfaceVariant)&#10;                if (event.description.isNotBlank()) Text(event.description, style = MaterialTheme.typography.bodyMedium)&#10;            }&#10;            // acciones opcionales&#10;            if (onEdit != null) IconButton(onClick = { onEdit(event) }) { Icon(Icons.Filled.Edit, contentDescription = &quot;Editar&quot;) }&#10;            if (onDelete != null) IconButton(onClick = { onDelete(event) }) { Icon(Icons.Filled.Delete, contentDescription = &quot;Eliminar&quot;) }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun AddEventDialog(&#10;     initialDate: Date,&#10;     onDismiss: () -&gt; Unit,&#10;     onSave: (String, String, Date, EventType, String?) -&gt; Unit,&#10;     role: Role?,&#10;     userCourses: List&lt;Pair&lt;String,String&gt;&gt; = emptyList()&#10; ) {&#10;    val context = LocalContext.current&#10;    var title by remember { mutableStateOf(&quot;&quot;) }&#10;    var description by remember { mutableStateOf(&quot;&quot;) }&#10;    // fecha y hora seleccionadas separadas&#10;    var dateCal by remember { mutableStateOf(Calendar.getInstance().apply { time = initialDate }) }&#10;    var type by remember { mutableStateOf(EventType.EVENTO) }&#10;    var targetCourseId by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;    // funciones auxiliares para abrir pickers nativos&#10;    fun openDatePicker() {&#10;        val c = dateCal&#10;        android.app.DatePickerDialog(context, { _, y, m, d -&gt;&#10;            c.set(Calendar.YEAR, y)&#10;            c.set(Calendar.MONTH, m)&#10;            c.set(Calendar.DAY_OF_MONTH, d)&#10;            dateCal = c&#10;        }, c.get(Calendar.YEAR), c.get(Calendar.MONTH), c.get(Calendar.DAY_OF_MONTH)).show()&#10;    }&#10;&#10;    fun openTimePicker() {&#10;        val c = dateCal&#10;        android.app.TimePickerDialog(context, { _, hour, minute -&gt;&#10;            c.set(Calendar.HOUR_OF_DAY, hour)&#10;            c.set(Calendar.MINUTE, minute)&#10;            c.set(Calendar.SECOND, 0)&#10;            dateCal = c&#10;        }, c.get(Calendar.HOUR_OF_DAY), c.get(Calendar.MINUTE), true).show()&#10;    }&#10;&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = { Text(&quot;Agregar Evento&quot;) },&#10;        text = {&#10;            Column {&#10;                OutlinedTextField(value = title, onValueChange = { title = it }, label = { Text(&quot;Título&quot;) }, singleLine = true)&#10;                Spacer(Modifier.height(8.dp))&#10;                OutlinedTextField(value = description, onValueChange = { description = it }, label = { Text(&quot;Descripción&quot;) })&#10;                Spacer(Modifier.height(8.dp))&#10;                Row(verticalAlignment = Alignment.CenterVertically) {&#10;                    Text(&quot;Fecha: ${SimpleDateFormat(&quot;dd/MM/yyyy&quot;, Locale.getDefault()).format(dateCal.time)}&quot;)&#10;                    Spacer(Modifier.width(8.dp))&#10;                    TextButton(onClick = { openDatePicker() }) { Text(&quot;Seleccionar fecha&quot;) }&#10;                }&#10;                Spacer(Modifier.height(8.dp))&#10;                Row(verticalAlignment = Alignment.CenterVertically) {&#10;                    Text(&quot;Hora: ${String.format(Locale.getDefault(), &quot;%02d:%02d&quot;, dateCal.get(Calendar.HOUR_OF_DAY), dateCal.get(Calendar.MINUTE))}&quot;)&#10;                    Spacer(Modifier.width(8.dp))&#10;                    TextButton(onClick = { openTimePicker() }) { Text(&quot;Seleccionar hora&quot;) }&#10;                }&#10;                Spacer(Modifier.height(8.dp))&#10;                Row { EventType.entries.forEach { ev -&gt;&#10;                    Row(verticalAlignment = Alignment.CenterVertically, modifier = Modifier.padding(end = 8.dp)) {&#10;                        RadioButton(selected = type == ev, onClick = { type = ev })&#10;                        Text(ev.name)&#10;                    }&#10;                }}&#10;                // target course selection for teachers&#10;                if (role == Role.DOCENTE) {&#10;                    Spacer(Modifier.height(8.dp))&#10;                    Text(&quot;Curso objetivo (opcional):&quot;, style = MaterialTheme.typography.labelMedium)&#10;                    // mostrar cursos disponibles para el docente&#10;                    LazyColumn(&#10;                        modifier = Modifier.heightIn(max = 200.dp),&#10;                        verticalArrangement = Arrangement.spacedBy(4.dp)&#10;                    ) {&#10;                        items(userCourses) { course -&gt;&#10;                            val isSelected = targetCourseId == course.first&#10;                            Row(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .clickable { targetCourseId = if (isSelected) null else course.first }&#10;                                    .padding(8.dp)&#10;                                    .background(&#10;                                        color = if (isSelected) MaterialTheme.colorScheme.primary.copy(alpha = 0.2f) else Color.Transparent,&#10;                                        shape = CircleShape&#10;                                    ),&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                Text(course.second, modifier = Modifier.weight(1f))&#10;                                if (isSelected) {&#10;                                    Icon(Icons.Filled.Check, contentDescription = &quot;Seleccionado&quot;, tint = MaterialTheme.colorScheme.primary)&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        },&#10;        confirmButton = {&#10;            TextButton(onClick = {&#10;                if (title.isBlank()) return@TextButton&#10;                onSave(title, description, dateCal.time, type, targetCourseId)&#10;            }) { Text(&quot;Guardar&quot;) }&#10;        },&#10;        dismissButton = {&#10;            TextButton(onClick = onDismiss) { Text(&quot;Cerrar&quot;) }&#10;        }&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun EditEventDialog(event: CalendarEvent, onDismiss: () -&gt; Unit, onSave: (CalendarEvent) -&gt; Unit, role: Role?, userCourses: List&lt;Pair&lt;String,String&gt;&gt; = emptyList()) {&#10;    val context = LocalContext.current&#10;    var title by remember { mutableStateOf(event.title) }&#10;    var description by remember { mutableStateOf(event.description) }&#10;    var dateCal by remember { mutableStateOf(Calendar.getInstance().apply { time = event.date }) }&#10;    var type by remember { mutableStateOf(event.type) }&#10;    var targetCourseId by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;    // cargar id de curso objetivo si es evento global&#10;    LaunchedEffect(event) {&#10;        targetCourseId = if (event.source == EventSource.GLOBAL) event.ownerId else null&#10;    }&#10;&#10;    fun openDatePicker() {&#10;        val c = dateCal&#10;        android.app.DatePickerDialog(context, { _, y, m, d -&gt; c.set(y, m, d); dateCal = c }, c.get(Calendar.YEAR), c.get(Calendar.MONTH), c.get(Calendar.DAY_OF_MONTH)).show()&#10;    }&#10;    fun openTimePicker() {&#10;        val c = dateCal&#10;        android.app.TimePickerDialog(context, { _, h, min -&gt; c.set(Calendar.HOUR_OF_DAY, h); c.set(Calendar.MINUTE, min); dateCal = c }, c.get(Calendar.HOUR_OF_DAY), c.get(Calendar.MINUTE), true).show()&#10;    }&#10;&#10;    AlertDialog(onDismissRequest = onDismiss, title = { Text(&quot;Editar Evento&quot;) }, text = {&#10;        Column {&#10;            OutlinedTextField(value = title, onValueChange = { title = it }, label = { Text(&quot;Título&quot;) }, singleLine = true)&#10;            Spacer(Modifier.height(8.dp))&#10;            OutlinedTextField(value = description, onValueChange = { description = it }, label = { Text(&quot;Descripción&quot;) })&#10;            Spacer(Modifier.height(8.dp))&#10;            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                Text(&quot;Fecha: ${SimpleDateFormat(&quot;dd/MM/yyyy&quot;, Locale.getDefault()).format(dateCal.time)}&quot;)&#10;                Spacer(Modifier.width(8.dp))&#10;                TextButton(onClick = { openDatePicker() }) { Text(&quot;Seleccionar fecha&quot;) }&#10;            }&#10;            Spacer(Modifier.height(8.dp))&#10;            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                Text(&quot;Hora: ${String.format(Locale.getDefault(), &quot;%02d:%02d&quot;, dateCal.get(Calendar.HOUR_OF_DAY), dateCal.get(Calendar.MINUTE))}&quot;)&#10;                Spacer(Modifier.width(8.dp))&#10;                TextButton(onClick = { openTimePicker() }) { Text(&quot;Seleccionar hora&quot;) }&#10;            }&#10;            Spacer(Modifier.height(8.dp))&#10;            Row { EventType.entries.forEach { ev -&gt; Row(verticalAlignment = Alignment.CenterVertically, modifier = Modifier.padding(end = 8.dp)) { RadioButton(selected = type == ev, onClick = { type = ev }); Text(ev.name) } } }&#10;            // target course selection for teachers&#10;            if (role == Role.DOCENTE) {&#10;                Spacer(Modifier.height(8.dp))&#10;                Text(&quot;Curso objetivo (opcional):&quot;, style = MaterialTheme.typography.labelMedium)&#10;                // mostrar cursos disponibles para el docente&#10;                LazyColumn(&#10;                    modifier = Modifier.heightIn(max = 200.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(4.dp)&#10;                ) {&#10;                    items(userCourses) { course -&gt;&#10;                        val isSelected = targetCourseId == course.first&#10;                        Row(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .clickable { targetCourseId = if (isSelected) null else course.first }&#10;                                .padding(8.dp)&#10;                                .background(&#10;                                    color = if (isSelected) MaterialTheme.colorScheme.primary.copy(alpha = 0.2f) else Color.Transparent,&#10;                                    shape = CircleShape&#10;                                ),&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            Text(course.second, modifier = Modifier.weight(1f))&#10;                            if (isSelected) {&#10;                                Icon(Icons.Filled.Check, contentDescription = &quot;Seleccionado&quot;, tint = MaterialTheme.colorScheme.primary)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }, confirmButton = {&#10;        TextButton(onClick = { onSave(CalendarEvent(event.id, title, description, dateCal.time, type, event.source, targetCourseId)) }) { Text(&quot;Guardar&quot;) }&#10;    }, dismissButton = { TextButton(onClick = onDismiss) { Text(&quot;Cerrar&quot;) } })&#10;}&#10;&#10;// helper to load upcoming events paginated&#10;private fun loadMoreUpcoming(db: FirebaseFirestore, auth: FirebaseAuth, dest: MutableList&lt;CalendarEvent&gt;, role: com.example.appcolegios.data.model.Role?, courseIds: List&lt;String&gt; = emptyList(), lastSnapshot: DocumentSnapshot? = null, cbLast: (DocumentSnapshot?) -&gt; Unit) {&#10;    val uid = auth.currentUser?.uid ?: return&#10;    val col = db.collection(&quot;users&quot;).document(uid).collection(&quot;events&quot;)&#10;    val PAGE_SIZE = 25&#10;    try {&#10;        var q = col.whereGreaterThanOrEqualTo(&quot;date&quot;, Timestamp.now()).orderBy(&quot;date&quot;)&#10;        if (lastSnapshot != null) q = q.startAfter(lastSnapshot)&#10;        q = q.limit(PAGE_SIZE.toLong())&#10;        q.get().addOnSuccessListener { snap -&gt;&#10;            val docs = snap.documents&#10;            for (doc in docs) {&#10;                val id = doc.id&#10;                val title = doc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                val description = doc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                val ts = doc.get(&quot;date&quot;)&#10;                val d = when (ts) {&#10;                    is com.google.firebase.Timestamp -&gt; ts.toDate()&#10;                    is Date -&gt; ts&#10;                    else -&gt; null&#10;                }&#10;                val type = try { EventType.valueOf(doc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                val owner = doc.getString(&quot;ownerId&quot;)&#10;                if (d != null) dest.add(CalendarEvent(id, title, description, d, type, EventSource.USER, owner))&#10;            }&#10;            cbLast(docs.lastOrNull())&#10;            // additionally fetch upcoming global events for user's courses (no strict pagination)&#10;            if (courseIds.isNotEmpty()) {&#10;                courseIds.chunked(10).forEach { chunk -&gt;&#10;                    db.collection(&quot;events&quot;).whereIn(&quot;courseId&quot;, chunk).whereGreaterThanOrEqualTo(&quot;date&quot;, Timestamp.now()).orderBy(&quot;date&quot;).limit(PAGE_SIZE.toLong()).get().addOnSuccessListener { gsnap -&gt;&#10;                        for (gdoc in gsnap.documents) {&#10;                            val id = gdoc.id&#10;                            if (dest.any { it.id == id }) continue&#10;                            val title = gdoc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                            val description = gdoc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                            val ts = gdoc.get(&quot;date&quot;)&#10;                            val d = when (ts) { is com.google.firebase.Timestamp -&gt; ts.toDate(); is Date -&gt; ts; else -&gt; null }&#10;                            val type = try { EventType.valueOf(gdoc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                            val courseId = gdoc.getString(&quot;courseId&quot;)&#10;                            if (d != null) dest.add(CalendarEvent(id, title, description, d, type, EventSource.GLOBAL, courseId))&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    } catch (e: Exception) {&#10;        // ignore&#10;        cbLast(null)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.appcolegios.academico&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.gestures.detectHorizontalDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.grid.GridCells&#10;import androidx.compose.foundation.lazy.grid.LazyVerticalGrid&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import kotlinx.coroutines.launch&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.appcolegios.perfil.ProfileViewModel&#10;import com.example.appcolegios.data.UserPreferencesRepository&#10;import com.example.appcolegios.data.UserData&#10;import com.example.appcolegios.data.model.Role&#10;import androidx.compose.ui.platform.LocalContext&#10;import android.util.Log&#10;import com.google.firebase.Timestamp&#10;import com.google.firebase.firestore.ListenerRegistration&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.animation.AnimatedContent&#10;import androidx.compose.animation.ExperimentalAnimationApi&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.animation.slideInHorizontally&#10;import androidx.compose.animation.slideOutHorizontally&#10;import androidx.compose.animation.with&#10;import androidx.compose.material.icons.automirrored.filled.Assignment&#10;import androidx.compose.material.icons.automirrored.filled.EventNote&#10;import java.time.Instant&#10;import java.time.LocalDate&#10;import java.time.ZoneId&#10;import java.time.temporal.WeekFields&#10;import com.google.firebase.firestore.DocumentSnapshot&#10;import java.util.Locale&#10;&#10;enum class EventSource { USER, GLOBAL }&#10;&#10;data class CalendarEvent(&#10;    val id: String,&#10;    val title: String,&#10;    val description: String,&#10;    val date: Date,&#10;    val type: EventType,&#10;    val source: EventSource = EventSource.USER,&#10;    val ownerId: String? = null // for USER -&gt; userId; for GLOBAL -&gt; courseId or owner&#10;)&#10;&#10;enum class EventType {&#10;    CLASE, EXAMEN, TAREA, EVENTO&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class, ExperimentalAnimationApi::class)&#10;@Composable&#10;fun CalendarScreen() {&#10;    // Separamos mes mostrado y fecha seleccionada&#10;    var displayedMonth by remember { mutableStateOf(Calendar.getInstance()) }&#10;    var selectedDay by remember { mutableStateOf&lt;Calendar?&gt;(Calendar.getInstance()) }&#10;    var showAddEventDialog by remember { mutableStateOf(false) }&#10;    val context = LocalContext.current&#10;&#10;    // Eventos para el mes mostrado (se cargan por rango mediante snapshot listener)&#10;    val events = remember { mutableStateListOf&lt;CalendarEvent&gt;() }&#10;    val auth = FirebaseAuth.getInstance()&#10;    val db = FirebaseFirestore.getInstance()&#10;    // user role and preferences&#10;    val userPrefs = remember { UserPreferencesRepository(context) }&#10;    val userData by userPrefs.userData.collectAsState(initial = UserData(null, null, null))&#10;    val role = userData.roleEnum&#10;    // courses for teacher/student/child selection&#10;    val userCourses = remember { mutableStateListOf&lt;Pair&lt;String,String&gt;&gt;() }&#10;    // Próximos eventos paginados y filtro por tipo&#10;    val upcomingEvents = remember { mutableStateListOf&lt;CalendarEvent&gt;() }&#10;    var upcomingLastSnapshot by remember { mutableStateOf&lt;DocumentSnapshot?&gt;(null) }&#10;    var selectedFilterType by remember { mutableStateOf&lt;EventType?&gt;(null) }&#10;&#10;    // Estado del bottom sheet para mostrar eventos del día seleccionado&#10;    var bottomSheetVisible by remember { mutableStateOf(false) }&#10;&#10;    // Estados para edición / borrado (deben existir para las acciones de la lista y bottom sheet)&#10;    var editingEvent by remember { mutableStateOf&lt;CalendarEvent?&gt;(null) }&#10;    var showEditEventDialog by remember { mutableStateOf(false) }&#10;    var eventToDelete by remember { mutableStateOf&lt;CalendarEvent?&gt;(null) }&#10;    var showDeleteConfirm by remember { mutableStateOf(false) }&#10;&#10;    // Profile VM: para padres (lista de hijos)&#10;    val profileVm: ProfileViewModel = viewModel()&#10;    val children by profileVm.children.collectAsState()&#10;    var selectedChildIndex by remember { mutableStateOf(0) }&#10;&#10;    // Listener registration manejado con DisposableEffect: soporta múltiples listeners según rol&#10;    DisposableEffect(displayedMonth.timeInMillis, auth.currentUser?.uid, role, selectedChildIndex) {&#10;        val userId = auth.currentUser?.uid&#10;        val regs = mutableListOf&lt;ListenerRegistration&gt;()&#10;        events.clear()&#10;&#10;        if (userId != null) {&#10;            // calcular primer y ultimo día del mes mostrado&#10;            val start = (displayedMonth.clone() as Calendar).apply {&#10;                set(Calendar.DAY_OF_MONTH, 1)&#10;                set(Calendar.HOUR_OF_DAY, 0)&#10;                set(Calendar.MINUTE, 0)&#10;                set(Calendar.SECOND, 0)&#10;                set(Calendar.MILLISECOND, 0)&#10;            }&#10;            val end = (displayedMonth.clone() as Calendar).apply {&#10;                set(Calendar.DAY_OF_MONTH, getActualMaximum(Calendar.DAY_OF_MONTH))&#10;                set(Calendar.HOUR_OF_DAY, 23)&#10;                set(Calendar.MINUTE, 59)&#10;                set(Calendar.SECOND, 59)&#10;                set(Calendar.MILLISECOND, 999)&#10;            }&#10;            val startTs = Timestamp(start.time)&#10;            val endTs = Timestamp(end.time)&#10;&#10;            try {&#10;                // 1) listener to personal events of the viewed user (teacher sees own personal too)&#10;                val personalListener = db.collection(&quot;users&quot;).document(userId).collection(&quot;events&quot;)&#10;                    .whereGreaterThanOrEqualTo(&quot;date&quot;, startTs)&#10;                    .whereLessThanOrEqualTo(&quot;date&quot;, endTs)&#10;                    .addSnapshotListener { snap, e -&gt;&#10;                        if (e != null) { Log.e(&quot;CalendarScreen&quot;, &quot;Personal listener error: ${e.message}&quot;); return@addSnapshotListener }&#10;                        if (snap != null) {&#10;                            for (doc in snap.documents) {&#10;                                val id = doc.id&#10;                                val title = doc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                                val description = doc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                                val ts = doc.get(&quot;date&quot;)&#10;                                val d = when (ts) { is Timestamp -&gt; ts.toDate(); is Date -&gt; ts; else -&gt; null }&#10;                                val type = try { EventType.valueOf(doc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                                if (d != null &amp;&amp; events.none { it.id == id }) events.add(CalendarEvent(id, title, description, d, type, EventSource.USER, userId))&#10;                                val rec = doc.getString(&quot;recurrence&quot;)&#10;                                if (!rec.isNullOrBlank() &amp;&amp; d != null) {&#10;                                    try { val occ = generateOccurrences(d, rec, start.time, end.time); occ.forEachIndexed { idx, occDate -&gt; if (events.none { it.id == &quot;${id}_occ_$idx&quot; }) events.add(CalendarEvent(&quot;${id}_occ_$idx&quot;, title, description, occDate, type, EventSource.USER, userId)) } } catch (_: Exception) {}&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                regs.add(personalListener)&#10;&#10;                // 2) role-specific: teacher -&gt; events for their courses; student -&gt; events for courses enrolled; parent -&gt; events for selected child&#10;                when (role) {&#10;                    Role.DOCENTE -&gt; {&#10;                        // get course ids taught by teacher&#10;                        val courseIds = mutableListOf&lt;String&gt;()&#10;                        try {&#10;                            val q = db.collection(&quot;courses&quot;).whereEqualTo(&quot;teacherId&quot;, userId).get()&#10;                            q.addOnSuccessListener { snap -&gt;&#10;                                userCourses.clear()&#10;                                for (doc in snap.documents) {&#10;                                    val cid = doc.id&#10;                                    courseIds.add(cid)&#10;                                    val cname = doc.getString(&quot;name&quot;) ?: doc.getString(&quot;title&quot;) ?: cid&#10;                                    userCourses.add(Pair(cid, cname))&#10;                                }&#10;                                // query top-level events where courseId in courseIds, chunked by 10&#10;                                if (courseIds.isNotEmpty()) {&#10;                                    courseIds.chunked(10).forEach { chunk -&gt;&#10;                                        val evQuery = db.collection(&quot;events&quot;).whereIn(&quot;courseId&quot;, chunk).whereGreaterThanOrEqualTo(&quot;date&quot;, startTs).whereLessThanOrEqualTo(&quot;date&quot;, endTs)&#10;                                        val r = evQuery.addSnapshotListener { snap2, e2 -&gt;&#10;                                            if (e2 != null) { Log.e(&quot;CalendarScreen&quot;,&quot;Course events listener err: ${e2.message}&quot;); return@addSnapshotListener }&#10;                                            if (snap2 != null) {&#10;                                                for (doc in snap2.documents) {&#10;                                                    val id = doc.id&#10;                                                    val title = doc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                                                    val description = doc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                                                    val ts = doc.get(&quot;date&quot;)&#10;                                                    val d = when (ts) { is Timestamp -&gt; ts.toDate(); is Date -&gt; ts; else -&gt; null }&#10;                                                    val type = try { EventType.valueOf(doc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                                                    if (d != null &amp;&amp; events.none { it.id == id }) events.add(CalendarEvent(id, title, description, d, type, EventSource.GLOBAL, null))&#10;                                                }&#10;                                            }&#10;                                        }&#10;                                        regs.add(r)&#10;                                    }&#10;                                }&#10;                            }&#10;                        } catch (_: Exception) { }&#10;                    }&#10;                    Role.ESTUDIANTE -&gt; {&#10;                        // student: read student doc for courses&#10;                        try {&#10;                            val sdocTask = db.collection(&quot;students&quot;).document(userId).get()&#10;                            sdocTask.addOnSuccessListener { sdoc -&gt;&#10;                                val courseIds = (sdoc.get(&quot;courses&quot;) as? List&lt;*&gt;)?.mapNotNull { it?.toString() } ?: emptyList()&#10;                                // populate userCourses with names&#10;                                userCourses.clear()&#10;                                for (cid in courseIds) {&#10;                                    db.collection(&quot;courses&quot;).document(cid).get().addOnSuccessListener { cdoc -&gt;&#10;                                        if (cdoc.exists()) userCourses.add(Pair(cid, cdoc.getString(&quot;name&quot;) ?: cid))&#10;                                    }&#10;                                }&#10;                                if (courseIds.isNotEmpty()) {&#10;                                    courseIds.chunked(10).forEach { chunk -&gt;&#10;                                        val evQuery = db.collection(&quot;events&quot;).whereIn(&quot;courseId&quot;, chunk).whereGreaterThanOrEqualTo(&quot;date&quot;, startTs).whereLessThanOrEqualTo(&quot;date&quot;, endTs)&#10;                                        val r = evQuery.addSnapshotListener { snap2, e2 -&gt;&#10;                                            if (e2 != null) return@addSnapshotListener&#10;                                            if (snap2 != null) {&#10;                                                for (doc in snap2.documents) {&#10;                                                    val id = doc.id&#10;                                                    val title = doc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                                                    val description = doc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                                                    val ts = doc.get(&quot;date&quot;)&#10;                                                    val d = when (ts) { is Timestamp -&gt; ts.toDate(); is Date -&gt; ts; else -&gt; null }&#10;                                                    val type = try { EventType.valueOf(doc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                                                    if (d != null &amp;&amp; events.none { it.id == id }) events.add(CalendarEvent(id, title, description, d, type, EventSource.GLOBAL, null))&#10;                                                }&#10;                                            }&#10;                                        }&#10;                                        regs.add(r)&#10;                                    }&#10;                                }&#10;                            }&#10;                        } catch (_: Exception) { }&#10;                    }&#10;                    Role.PADRE -&gt; {&#10;                        // parent: use selected child&#10;                        val childId = children.getOrNull(selectedChildIndex)?.id&#10;                        if (!childId.isNullOrBlank()) {&#10;                            // personal events of child&#10;                            val childListener = db.collection(&quot;users&quot;).document(childId).collection(&quot;events&quot;)&#10;                                .whereGreaterThanOrEqualTo(&quot;date&quot;, startTs)&#10;                                .whereLessThanOrEqualTo(&quot;date&quot;, endTs)&#10;                                .addSnapshotListener { snap, e -&gt;&#10;                                    if (e != null) { Log.e(&quot;CalendarScreen&quot;, &quot;Child listener error: ${e.message}&quot;); return@addSnapshotListener }&#10;                                    if (snap != null) {&#10;                                        for (doc in snap.documents) {&#10;                                            val id = doc.id&#10;                                            val title = doc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                                            val description = doc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                                            val ts = doc.get(&quot;date&quot;)&#10;                                            val d = when (ts) { is Timestamp -&gt; ts.toDate(); is Date -&gt; ts; else -&gt; null }&#10;                                            val type = try { EventType.valueOf(doc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                                            if (d != null &amp;&amp; events.none { it.id == id }) events.add(CalendarEvent(id, title, description, d, type, EventSource.USER, childId))&#10;                                        }&#10;                                    }&#10;                                }&#10;                            regs.add(childListener)&#10;&#10;                            // also load course events for that child (like student)&#10;                            try {&#10;                                val sdocTask = db.collection(&quot;students&quot;).document(childId).get()&#10;                                sdocTask.addOnSuccessListener { sdoc -&gt;&#10;                                    val courseIds = (sdoc.get(&quot;courses&quot;) as? List&lt;*&gt;)?.mapNotNull { it?.toString() } ?: emptyList()&#10;                                    if (courseIds.isNotEmpty()) {&#10;                                        courseIds.chunked(10).forEach { chunk -&gt;&#10;                                            val evQuery = db.collection(&quot;events&quot;).whereIn(&quot;courseId&quot;, chunk).whereGreaterThanOrEqualTo(&quot;date&quot;, startTs).whereLessThanOrEqualTo(&quot;date&quot;, endTs)&#10;                                            val r = evQuery.addSnapshotListener { snap2, e2 -&gt;&#10;                                                if (e2 != null) { Log.e(&quot;CalendarScreen&quot;, &quot;Child course events listener err: ${e2.message}&quot;); return@addSnapshotListener }&#10;                                                if (snap2 != null) {&#10;                                                    for (doc in snap2.documents) {&#10;                                                        val id = doc.id&#10;                                                        val title = doc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                                                        val description = doc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                                                        val ts = doc.get(&quot;date&quot;)&#10;                                                        val d = when (ts) { is Timestamp -&gt; ts.toDate(); is Date -&gt; ts; else -&gt; null }&#10;                                                        val type = try { EventType.valueOf(doc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                                                        if (d != null &amp;&amp; events.none { it.id == id }) events.add(CalendarEvent(id, title, description, d, type, EventSource.GLOBAL, doc.getString(&quot;courseId&quot;)))&#10;                                                    }&#10;                                                }&#10;                                            }&#10;                                            regs.add(r)&#10;                                        }&#10;                                    }&#10;                                }&#10;                            } catch (_: Exception) {}&#10;                        }&#10;                    }&#10;                    else -&gt; {&#10;                        // default: no extra listeners&#10;                    }&#10;                }&#10;            } catch (ex: Exception) {&#10;                Log.e(&quot;CalendarScreen&quot;, &quot;Error starting listeners: ${ex.message}&quot;, ex)&#10;            }&#10;        }&#10;&#10;        onDispose {&#10;            regs.forEach { try { it.remove() } catch (_: Exception) {} }&#10;        }&#10;    }&#10;&#10;    // Snackbar / scaffold&#10;    val snackbarHostState = remember { SnackbarHostState() }&#10;    val scope = rememberCoroutineScope()&#10;&#10;    Scaffold(&#10;        snackbarHost = { SnackbarHost(hostState = snackbarHostState) }&#10;    ) { innerPadding -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(innerPadding)&#10;                .padding(16.dp)&#10;        ) {&#10;            // Header con mes actual&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                IconButton(onClick = {&#10;                    displayedMonth = (displayedMonth.clone() as Calendar).apply { add(Calendar.MONTH, -1) }&#10;                }) {&#10;                    Icon(Icons.Filled.ChevronLeft, contentDescription = &quot;Mes anterior&quot;)&#10;                }&#10;&#10;                Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                    Text(&#10;                        text = SimpleDateFormat(&quot;MMMM yyyy&quot;, Locale.getDefault()).format(displayedMonth.time),&#10;                        style = MaterialTheme.typography.titleLarge,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;                    TextButton(onClick = { // volver a hoy&#10;                        displayedMonth = Calendar.getInstance()&#10;                        selectedDay = Calendar.getInstance()&#10;                    }) { Text(&quot;Hoy&quot;) }&#10;&#10;                    // selector de hijo para PADRE&#10;                    if (role == Role.PADRE) {&#10;                        Spacer(Modifier.height(8.dp))&#10;                        Row(verticalAlignment = Alignment.CenterVertically) {&#10;                            Text(&quot;Hijo: &quot;)&#10;                            if (children.isEmpty()) {&#10;                                Text(&quot;(sin hijos)&quot;)&#10;                            } else {&#10;                                var expanded by remember { mutableStateOf(false) }&#10;                                val label = children.getOrNull(selectedChildIndex)?.nombre ?: &quot;Seleccionar&quot;&#10;                                Box {&#10;                                    TextButton(onClick = { expanded = true }) { Text(label) }&#10;                                    DropdownMenu(expanded = expanded, onDismissRequest = { expanded = false }) {&#10;                                        children.forEachIndexed { idx, child -&gt;&#10;                                            DropdownMenuItem(text = { Text(child.nombre) }, onClick = { selectedChildIndex = idx; expanded = false })&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                IconButton(onClick = {&#10;                    displayedMonth = (displayedMonth.clone() as Calendar).apply { add(Calendar.MONTH, 1) }&#10;                }) {&#10;                    Icon(Icons.Filled.ChevronRight, contentDescription = &quot;Mes siguiente&quot;)&#10;                }&#10;            }&#10;&#10;            Spacer(Modifier.height(16.dp))&#10;&#10;            // Días de la semana -- respetar locale (primer día simplificado)&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceEvenly&#10;            ) {&#10;                // Obtener nombres de días desde locale&#10;                val df = SimpleDateFormat(&quot;EE&quot;, Locale.getDefault())&#10;                val headerCal = Calendar.getInstance()&#10;                // usar firstDayOfWeek del locale&#10;                val firstDow = headerCal.firstDayOfWeek&#10;                for (i in 0 until 7) {&#10;                    headerCal.set(Calendar.DAY_OF_WEEK, (firstDow + i - 1) % 7 + 1)&#10;                    Text(&#10;                        text = df.format(headerCal.time),&#10;                        modifier = Modifier.weight(1f),&#10;                        textAlign = TextAlign.Center,&#10;                        style = MaterialTheme.typography.labelMedium,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = MaterialTheme.colorScheme.primary&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(Modifier.height(8.dp))&#10;&#10;            // Grid del calendario con fecha seleccionada y soporte swipe/anim&#10;            Box(modifier = Modifier&#10;                .fillMaxWidth()&#10;                .height(320.dp)&#10;                .pointerInput(Unit) {&#10;                    detectHorizontalDragGestures { change, dragAmount -&gt;&#10;                        val threshold = 150&#10;                        if (dragAmount &gt; threshold) {&#10;                            // swipe derecha -&gt; mes anterior&#10;                            displayedMonth = (displayedMonth.clone() as Calendar).apply { add(Calendar.MONTH, -1) }&#10;                        } else if (dragAmount &lt; -threshold) {&#10;                            // swipe izquierda -&gt; mes siguiente&#10;                            displayedMonth = (displayedMonth.clone() as Calendar).apply { add(Calendar.MONTH, 1) }&#10;                        }&#10;                    }&#10;                }&#10;            ) {&#10;                AnimatedContent(targetState = displayedMonth.timeInMillis, transitionSpec = {&#10;                    slideInHorizontally(initialOffsetX = { fullWidth -&gt; if (targetState &gt; initialState) fullWidth else -fullWidth }, animationSpec = tween(300)) with&#10;                            slideOutHorizontally(targetOffsetX = { fullWidth -&gt; if (targetState &gt; initialState) -fullWidth else fullWidth }, animationSpec = tween(300))&#10;                }) { ts -&gt;&#10;                    // no-op para marcar uso del parámetro y evitar error&#10;                    if (ts == Long.MIN_VALUE) { /* noop */ }&#10;                      CalendarGrid(&#10;                          displayedMonth = displayedMonth,&#10;                          selectedDay = selectedDay,&#10;                          events = events,&#10;                          onDateSelected = { cal -&gt;&#10;                              selectedDay = cal&#10;                              bottomSheetVisible = true&#10;                          }&#10;                      )&#10;                  }&#10;             }&#10;&#10;            Spacer(Modifier.height(16.dp))&#10;&#10;            // Botón para agregar evento&#10;            Button(&#10;                onClick = { showAddEventDialog = true },&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Icon(Icons.Filled.Add, contentDescription = &quot;Agregar evento&quot;)&#10;                Spacer(Modifier.width(8.dp))&#10;                Text(&quot;Agregar Evento&quot;)&#10;            }&#10;&#10;            Spacer(Modifier.height(16.dp))&#10;&#10;            // Lista de próximos eventos (paginated) con filtro por tipo&#10;            Text(&#10;                &quot;Próximos Eventos&quot;,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;&#10;            Spacer(Modifier.height(8.dp))&#10;&#10;            // Filtro por tipo&#10;            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                Text(&quot;Filtrar: &quot;)&#10;                Spacer(Modifier.width(8.dp))&#10;                // botones simples para filtrar por tipo&#10;                EventType.entries.let { types -&gt;&#10;                    types.forEach { t -&gt;&#10;                         val selected = selectedFilterType == t&#10;                         TextButton(onClick = { selectedFilterType = if (selected) null else t }) {&#10;                             Text(t.name, color = if (selected) MaterialTheme.colorScheme.onPrimary else MaterialTheme.colorScheme.onSurface)&#10;                         }&#10;                     }&#10;                 }&#10;            }&#10;&#10;            Spacer(Modifier.height(8.dp))&#10;&#10;            // carga inicial de upcoming en background (no duplicar si ya cargado)&#10;            LaunchedEffect(auth.currentUser?.uid) {&#10;                upcomingEvents.clear()&#10;                upcomingLastSnapshot = null&#10;                // pasar los courseIds disponibles (si ya se cargaron) para traer también eventos globales&#10;                val courseIds = userCourses.map { it.first }&#10;                loadMoreUpcoming(db, auth, upcomingEvents, role, courseIds) { doc -&gt; upcomingLastSnapshot = doc }&#10;            }&#10;&#10;            val displayedUpcoming = if (selectedFilterType == null) upcomingEvents.toList() else upcomingEvents.filter { it.type == selectedFilterType }&#10;&#10;            LazyColumn(&#10;                 verticalArrangement = Arrangement.spacedBy(8.dp)&#10;             ) {&#10;                items(displayedUpcoming) { event -&gt;&#10;                    // per-event permissions: owner can edit/delete USER events; DOCENTE can edit/delete GLOBAL events&#10;                    val uid = auth.currentUser?.uid&#10;                    val allowEdit = when (event.source) {&#10;                        EventSource.USER -&gt; event.ownerId == uid&#10;                        EventSource.GLOBAL -&gt; role == Role.DOCENTE&#10;                    }&#10;                    val allowDelete = allowEdit&#10;                    EventCard(event,&#10;                        onEdit = if (allowEdit) { ev -&gt; editingEvent = ev; showEditEventDialog = true } else null,&#10;                        onDelete = if (allowDelete) { ev -&gt; eventToDelete = ev; showDeleteConfirm = true } else null&#10;                    )&#10;                }&#10;                item {&#10;                    Spacer(Modifier.height(6.dp))&#10;                    Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.Center) {&#10;                        val courseIds = userCourses.map { it.first }&#10;                        if (upcomingLastSnapshot != null) {&#10;                            Button(onClick = { loadMoreUpcoming(db, auth, upcomingEvents, role, courseIds) { doc -&gt; upcomingLastSnapshot = doc } }) { Text(&quot;Cargar más&quot;) }&#10;                        }&#10;                    }&#10;                 }&#10;             }&#10;         }&#10;     }&#10;&#10;    // Bottom sheet para eventos del día seleccionado (simple Modal)&#10;    if (bottomSheetVisible &amp;&amp; selectedDay != null) {&#10;        val selLocal = LocalDate.of(selectedDay!!.get(Calendar.YEAR), selectedDay!!.get(Calendar.MONTH)+1, selectedDay!!.get(Calendar.DAY_OF_MONTH))&#10;        val dayEvents = events.filter { ev -&gt;&#10;            val evLocal = Instant.ofEpochMilli(ev.date.time).atZone(ZoneId.systemDefault()).toLocalDate()&#10;            evLocal == selLocal&#10;        }.sortedBy { it.date }&#10;&#10;        ModalBottomSheet(&#10;            onDismissRequest = { bottomSheetVisible = false }&#10;        ) {&#10;            Column(modifier = Modifier.padding(16.dp)) {&#10;                Text(&quot;Eventos en ${SimpleDateFormat(&quot;dd/MM/yyyy&quot;, Locale.getDefault()).format(selectedDay!!.time)}&quot;, style = MaterialTheme.typography.titleMedium, fontWeight = FontWeight.Bold)&#10;                Spacer(Modifier.height(8.dp))&#10;                if (dayEvents.isEmpty()) {&#10;                    Text(&quot;No hay eventos para este día&quot;, color = MaterialTheme.colorScheme.onSurfaceVariant)&#10;                } else {&#10;                    dayEvents.forEach { ev -&gt;&#10;                        val uid = auth.currentUser?.uid&#10;                        val allowEdit = when (ev.source) {&#10;                            EventSource.USER -&gt; ev.ownerId == uid&#10;                            EventSource.GLOBAL -&gt; role == Role.DOCENTE&#10;                        }&#10;                        val allowDelete = allowEdit&#10;                        EventCard(ev,&#10;                            onEdit = if (allowEdit) { e -&gt; editingEvent = e; showEditEventDialog = true } else null,&#10;                            onDelete = if (allowDelete) { e -&gt; eventToDelete = e; showDeleteConfirm = true } else null&#10;                        )&#10;                        Spacer(Modifier.height(8.dp))&#10;                    }&#10;                }&#10;                Spacer(Modifier.height(8.dp))&#10;                Row(horizontalArrangement = Arrangement.End, modifier = Modifier.fillMaxWidth()) {&#10;                    TextButton(onClick = { bottomSheetVisible = false }) { Text(&quot;Cerrar&quot;) }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    if (showAddEventDialog) {&#10;        AddEventDialog(&#10;            initialDate = selectedDay?.time ?: displayedMonth.time,&#10;            onDismiss = { showAddEventDialog = false },&#10;            onSave = { title, description, date, type, targetCourseId -&gt;&#10;                val userId = auth.currentUser?.uid&#10;                if (userId == null) {&#10;                    scope.launch { snackbarHostState.showSnackbar(&quot;Debes iniciar sesión para agregar eventos&quot;) }&#10;                    return@AddEventDialog&#10;                }&#10;                val db = FirebaseFirestore.getInstance()&#10;                val eventId = UUID.randomUUID().toString()&#10;                val eventData = hashMapOf&lt;String, Any?&gt;(&#10;                    &quot;id&quot; to eventId,&#10;                    &quot;title&quot; to title,&#10;                    &quot;description&quot; to description,&#10;                    &quot;date&quot; to Timestamp(date),&#10;                    &quot;type&quot; to type.name,&#10;                    &quot;createdAt&quot; to Timestamp.now(),&#10;                    &quot;ownerId&quot; to userId&#10;                )&#10;                // If teacher selected a course target, save as global event in top-level collection&#10;                if (role == Role.DOCENTE &amp;&amp; !targetCourseId.isNullOrBlank()) {&#10;                    eventData[&quot;courseId&quot;] = targetCourseId&#10;                    db.collection(&quot;events&quot;).document(eventId)&#10;                        .set(eventData)&#10;                        .addOnSuccessListener {&#10;                            events.add(CalendarEvent(eventId, title, description, date, type, EventSource.GLOBAL, targetCourseId))&#10;                            showAddEventDialog = false&#10;                            scope.launch { snackbarHostState.showSnackbar(&quot;Evento de curso agregado&quot;) }&#10;                        }&#10;                        .addOnFailureListener { e -&gt;&#10;                            Log.e(&quot;CalendarScreen&quot;, &quot;Error saving global event: ${e.message}&quot;, e)&#10;                            scope.launch { snackbarHostState.showSnackbar(&quot;Error guardando evento&quot;) }&#10;                        }&#10;                } else {&#10;                    // save personal event under users/{uid}/events&#10;                    db.collection(&quot;users&quot;).document(userId).collection(&quot;events&quot;).document(eventId)&#10;                        .set(eventData)&#10;                        .addOnSuccessListener {&#10;                            events.add(CalendarEvent(eventId, title, description, date, type, EventSource.USER, userId))&#10;                            showAddEventDialog = false&#10;                            scope.launch { snackbarHostState.showSnackbar(&quot;Evento agregado&quot;) }&#10;                        }&#10;                        .addOnFailureListener { e -&gt;&#10;                            Log.e(&quot;CalendarScreen&quot;, &quot;Error saving personal event: ${e.message}&quot;, e)&#10;                            scope.launch { snackbarHostState.showSnackbar(&quot;Error guardando evento&quot;) }&#10;                        }&#10;                }&#10;            },&#10;            role = role,&#10;            userCourses = userCourses.toList()&#10;        )&#10;    }&#10;&#10;    // handle actual deletion when confirmed&#10;    if (showDeleteConfirm &amp;&amp; eventToDelete != null) {&#10;        AlertDialog(onDismissRequest = { showDeleteConfirm = false; eventToDelete = null }, title = { Text(&quot;Confirmar eliminación&quot;) }, text = { Text(&quot;Eliminar evento '${eventToDelete!!.title}'?&quot;) }, confirmButton = {&#10;            TextButton(onClick = {&#10;                val uid = auth.currentUser?.uid ?: run { showDeleteConfirm = false; eventToDelete = null; return@TextButton }&#10;                val ev = eventToDelete&#10;                if (ev == null) return@TextButton&#10;                if (ev.source == EventSource.USER) {&#10;                    // delete under owner user's events&#10;                    val owner = ev.ownerId ?: uid&#10;                    db.collection(&quot;users&quot;).document(owner).collection(&quot;events&quot;).document(ev.id)&#10;                        .delete()&#10;                        .addOnSuccessListener {&#10;                            events.removeAll { it.id == ev.id }&#10;                            upcomingEvents.removeAll { it.id == ev.id }&#10;                            showDeleteConfirm = false&#10;                            eventToDelete = null&#10;                        }&#10;                        .addOnFailureListener { ex -&gt;&#10;                            scope.launch { snackbarHostState.showSnackbar(&quot;Error eliminando: ${ex.localizedMessage}&quot;) }&#10;                            showDeleteConfirm = false; eventToDelete = null&#10;                        }&#10;                } else {&#10;                    // global event stored in top-level 'events'&#10;                    db.collection(&quot;events&quot;).document(ev.id)&#10;                        .delete()&#10;                        .addOnSuccessListener {&#10;                            events.removeAll { it.id == ev.id }&#10;                            upcomingEvents.removeAll { it.id == ev.id }&#10;                            showDeleteConfirm = false&#10;                            eventToDelete = null&#10;                        }&#10;                        .addOnFailureListener { ex -&gt;&#10;                            scope.launch { snackbarHostState.showSnackbar(&quot;Error eliminando: ${ex.localizedMessage}&quot;) }&#10;                            showDeleteConfirm = false; eventToDelete = null&#10;                        }&#10;                }&#10;            }) { Text(&quot;Eliminar&quot;) }&#10;        }, dismissButton = { TextButton(onClick = { showDeleteConfirm = false; eventToDelete = null }) { Text(&quot;Cancelar&quot;) } })&#10;    }&#10;&#10;    // Edit dialog&#10;    if (showEditEventDialog &amp;&amp; editingEvent != null) {&#10;        EditEventDialog(event = editingEvent!!, onDismiss = { showEditEventDialog = false; editingEvent = null }, onSave = { updated -&gt;&#10;             val uid = auth.currentUser?.uid ?: return@EditEventDialog&#10;             val map = mapOf(&quot;title&quot; to updated.title, &quot;description&quot; to updated.description, &quot;date&quot; to Timestamp(updated.date), &quot;type&quot; to updated.type.name)&#10;             // update in appropriate collection based on source&#10;             if (updated.source == EventSource.USER) {&#10;                // actualizar en la colección del owner (no asumir uid actual)&#10;                val owner = updated.ownerId ?: uid&#10;                db.collection(&quot;users&quot;).document(owner).collection(&quot;events&quot;).document(updated.id)&#10;                    .update(map)&#10;                    .addOnSuccessListener {&#10;                        fun replace(list: MutableList&lt;CalendarEvent&gt;) {&#10;                            val idx = list.indexOfFirst { it.id == updated.id }&#10;                            if (idx &gt;= 0) list[idx] = updated&#10;                        }&#10;                        replace(events)&#10;                        replace(upcomingEvents)&#10;                        showEditEventDialog = false; editingEvent = null&#10;                    }&#10;                    .addOnFailureListener { ex -&gt; scope.launch { snackbarHostState.showSnackbar(&quot;Error actualizando: ${ex.localizedMessage}&quot;) } }&#10;             } else {&#10;                 // teacher editing global event&#10;                 val mapWithCourse = hashMapOf&lt;String, Any?&gt;()&#10;                 mapWithCourse.putAll(map)&#10;                 if (!updated.ownerId.isNullOrBlank()) mapWithCourse[&quot;courseId&quot;] = updated.ownerId&#10;                 db.collection(&quot;events&quot;).document(updated.id).update(mapWithCourse as Map&lt;String, Any?&gt;)&#10;                      .addOnSuccessListener {&#10;                          fun replace(list: MutableList&lt;CalendarEvent&gt;) {&#10;                              val idx = list.indexOfFirst { it.id == updated.id }&#10;                              if (idx &gt;= 0) list[idx] = updated&#10;                          }&#10;                          replace(events)&#10;                          replace(upcomingEvents)&#10;                          showEditEventDialog = false; editingEvent = null&#10;                      }&#10;                      .addOnFailureListener { ex -&gt; scope.launch { snackbarHostState.showSnackbar(&quot;Error actualizando: ${ex.localizedMessage}&quot;) } }&#10;             }&#10;         }, role = role, userCourses = userCourses.toList())&#10;      }&#10;}&#10;&#10;// Generador simple de ocurrencias para recurrencia básica&#10;fun generateOccurrences(startDate: Date, recurrence: String, rangeStart: Date, rangeEnd: Date): List&lt;Date&gt; {&#10;     val res = mutableListOf&lt;Date&gt;()&#10;     val cal = Calendar.getInstance().apply { time = startDate }&#10;     val endRangeCal = Calendar.getInstance().apply { time = rangeEnd }&#10;     val startRangeCal = Calendar.getInstance().apply { time = rangeStart }&#10;&#10;     when (recurrence.uppercase(Locale.getDefault())) {&#10;         &quot;DAILY&quot; -&gt; {&#10;             // avanzar hasta &gt;= startRange&#10;             while (cal.before(startRangeCal)) cal.add(Calendar.DAY_OF_MONTH, 1)&#10;             while (!cal.after(endRangeCal)) {&#10;                 res.add(cal.time)&#10;                 cal.add(Calendar.DAY_OF_MONTH, 1)&#10;             }&#10;         }&#10;         &quot;WEEKLY&quot; -&gt; {&#10;             while (cal.before(startRangeCal)) cal.add(Calendar.WEEK_OF_YEAR, 1)&#10;             while (!cal.after(endRangeCal)) {&#10;                 res.add(cal.time)&#10;                 cal.add(Calendar.WEEK_OF_YEAR, 1)&#10;             }&#10;         }&#10;         &quot;MONTHLY&quot; -&gt; {&#10;             while (cal.before(startRangeCal)) cal.add(Calendar.MONTH, 1)&#10;             while (!cal.after(endRangeCal)) {&#10;                 res.add(cal.time)&#10;                 cal.add(Calendar.MONTH, 1)&#10;             }&#10;         }&#10;         else -&gt; { /* no soportado */ }&#10;     }&#10;&#10;     return res&#10; }&#10;&#10;@Composable&#10;private fun CalendarGrid(&#10;    displayedMonth: Calendar,&#10;    selectedDay: Calendar?,&#10;    events: List&lt;CalendarEvent&gt;,&#10;    onDateSelected: (Calendar) -&gt; Unit&#10;) {&#10;    val calendar = (displayedMonth.clone() as Calendar).apply { set(Calendar.DAY_OF_MONTH, 1) }&#10;    // determinar primer día de semana según locale/WeekFields&#10;    val firstDowField = WeekFields.of(Locale.getDefault()).firstDayOfWeek&#10;    val firstDayOfWeek = (firstDowField.value - 1) // DayOfWeek.MONDAY.value==1&#10;    val daysInMonth = calendar.getActualMaximum(Calendar.DAY_OF_MONTH)&#10;&#10;    val today = Calendar.getInstance()&#10;&#10;    LazyVerticalGrid(&#10;        columns = GridCells.Fixed(7),&#10;        modifier = Modifier.height(300.dp)&#10;    ) {&#10;        // Espacios en blanco antes del primer día&#10;        items(firstDayOfWeek) {&#10;            Box(modifier = Modifier.aspectRatio(1f))&#10;        }&#10;&#10;        // Días del mes&#10;        items(daysInMonth) { day -&gt;&#10;            val dayNumber = day + 1&#10;            val thisDay = (calendar.clone() as Calendar).apply { set(Calendar.DAY_OF_MONTH, dayNumber) }&#10;&#10;            // usar LocalDate para evitar problemas de zona/hora&#10;            val thisLocal = Instant.ofEpochMilli(thisDay.time.time).atZone(ZoneId.systemDefault()).toLocalDate()&#10;&#10;            val dayEvents = events.filter { ev -&gt;&#10;                val evLocal = Instant.ofEpochMilli(ev.date.time).atZone(ZoneId.systemDefault()).toLocalDate()&#10;                evLocal == thisLocal&#10;            }&#10;            val hasEvent = dayEvents.isNotEmpty()&#10;&#10;            val isToday = Instant.ofEpochMilli(today.time.time).atZone(ZoneId.systemDefault()).toLocalDate() == thisLocal&#10;&#10;            val isSelected = selectedDay?.let { sel -&gt;&#10;                val selLocal = Instant.ofEpochMilli(sel.time.time).atZone(ZoneId.systemDefault()).toLocalDate()&#10;                selLocal == thisLocal&#10;            } ?: false&#10;&#10;            Box(&#10;                modifier = Modifier&#10;                    .aspectRatio(1f)&#10;                    .padding(2.dp)&#10;                    .clip(CircleShape)&#10;                    .background(&#10;                        color = when {&#10;                            isSelected -&gt; MaterialTheme.colorScheme.primary.copy(alpha = 0.25f)&#10;                            isToday -&gt; MaterialTheme.colorScheme.primaryContainer&#10;                            hasEvent -&gt; MaterialTheme.colorScheme.secondaryContainer.copy(alpha = 0.5f)&#10;                            else -&gt; Color.Transparent&#10;                        }&#10;                    )&#10;                    .clickable { onDateSelected(thisDay) },&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Column(&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    Text(&#10;                        text = dayNumber.toString(),&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        fontWeight = if (isToday || isSelected) FontWeight.Bold else FontWeight.Normal,&#10;                        color = if (isToday || isSelected) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.onSurface&#10;                    )&#10;                    if (hasEvent) {&#10;                        // mostrar hasta 3 puntos de colores según tipos distintos&#10;                        val types = dayEvents.map { it.type }.distinct()&#10;                        val maxDots = 3&#10;                        Row(horizontalArrangement = Arrangement.Center, verticalAlignment = Alignment.CenterVertically) {&#10;                            types.take(maxDots).forEach { t -&gt;&#10;                                val dotColor = when (t) {&#10;                                    EventType.CLASE -&gt; Color(0xFF2196F3)&#10;                                    EventType.EXAMEN -&gt; Color(0xFFF44336)&#10;                                    EventType.TAREA -&gt; Color(0xFFFFC107)&#10;                                    EventType.EVENTO -&gt; Color(0xFF4CAF50)&#10;                                }&#10;                                Box(modifier = Modifier.size(6.dp).background(dotColor, CircleShape))&#10;                                Spacer(Modifier.width(4.dp))&#10;                            }&#10;                            if (types.size &gt; maxDots) {&#10;                                Text(&quot;+${types.size - maxDots}&quot;, style = MaterialTheme.typography.bodySmall)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun EventCard(event: CalendarEvent, onEdit: ((CalendarEvent) -&gt; Unit)? = null, onDelete: ((CalendarEvent) -&gt; Unit)? = null) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Icon(&#10;                imageVector = when (event.type) {&#10;                    EventType.CLASE -&gt; Icons.Filled.School&#10;                    EventType.EXAMEN -&gt; Icons.Filled.Warning&#10;                    EventType.TAREA -&gt; Icons.AutoMirrored.Filled.Assignment&#10;                    EventType.EVENTO -&gt; Icons.AutoMirrored.Filled.EventNote&#10;                },&#10;                contentDescription = null,&#10;                tint = when (event.type) {&#10;                    EventType.CLASE -&gt; Color(0xFF2196F3)&#10;                    EventType.EXAMEN -&gt; Color(0xFFF44336)&#10;                    EventType.TAREA -&gt; Color(0xFFFFC107)&#10;                    EventType.EVENTO -&gt; Color(0xFF4CAF50)&#10;                }&#10;            )&#10;            Spacer(Modifier.width(12.dp))&#10;            Column(modifier = Modifier.weight(1f)) {&#10;                Text(event.title, style = MaterialTheme.typography.titleSmall, fontWeight = FontWeight.SemiBold)&#10;                Text(SimpleDateFormat(&quot;dd/MM/yyyy HH:mm&quot;, Locale.getDefault()).format(event.date), style = MaterialTheme.typography.bodySmall, color = MaterialTheme.colorScheme.onSurfaceVariant)&#10;                if (event.description.isNotBlank()) Text(event.description, style = MaterialTheme.typography.bodyMedium)&#10;            }&#10;            // acciones opcionales&#10;            if (onEdit != null) IconButton(onClick = { onEdit(event) }) { Icon(Icons.Filled.Edit, contentDescription = &quot;Editar&quot;) }&#10;            if (onDelete != null) IconButton(onClick = { onDelete(event) }) { Icon(Icons.Filled.Delete, contentDescription = &quot;Eliminar&quot;) }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun AddEventDialog(&#10;     initialDate: Date,&#10;     onDismiss: () -&gt; Unit,&#10;     onSave: (String, String, Date, EventType, String?) -&gt; Unit,&#10;     role: Role?,&#10;     userCourses: List&lt;Pair&lt;String,String&gt;&gt; = emptyList()&#10; ) {&#10;    val context = LocalContext.current&#10;    var title by remember { mutableStateOf(&quot;&quot;) }&#10;    var description by remember { mutableStateOf(&quot;&quot;) }&#10;    // fecha y hora seleccionadas separadas&#10;    var dateCal by remember { mutableStateOf(Calendar.getInstance().apply { time = initialDate }) }&#10;    var type by remember { mutableStateOf(EventType.EVENTO) }&#10;    var targetCourseId by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;    // funciones auxiliares para abrir pickers nativos&#10;    fun openDatePicker() {&#10;        val c = dateCal&#10;        android.app.DatePickerDialog(context, { _, y, m, d -&gt;&#10;            c.set(Calendar.YEAR, y)&#10;            c.set(Calendar.MONTH, m)&#10;            c.set(Calendar.DAY_OF_MONTH, d)&#10;            dateCal = c&#10;        }, c.get(Calendar.YEAR), c.get(Calendar.MONTH), c.get(Calendar.DAY_OF_MONTH)).show()&#10;    }&#10;&#10;    fun openTimePicker() {&#10;        val c = dateCal&#10;        android.app.TimePickerDialog(context, { _, hour, minute -&gt;&#10;            c.set(Calendar.HOUR_OF_DAY, hour)&#10;            c.set(Calendar.MINUTE, minute)&#10;            c.set(Calendar.SECOND, 0)&#10;            dateCal = c&#10;        }, c.get(Calendar.HOUR_OF_DAY), c.get(Calendar.MINUTE), true).show()&#10;    }&#10;&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = { Text(&quot;Agregar Evento&quot;) },&#10;        text = {&#10;            Column {&#10;                OutlinedTextField(value = title, onValueChange = { title = it }, label = { Text(&quot;Título&quot;) }, singleLine = true)&#10;                Spacer(Modifier.height(8.dp))&#10;                OutlinedTextField(value = description, onValueChange = { description = it }, label = { Text(&quot;Descripción&quot;) })&#10;                Spacer(Modifier.height(8.dp))&#10;                Row(verticalAlignment = Alignment.CenterVertically) {&#10;                    Text(&quot;Fecha: ${SimpleDateFormat(&quot;dd/MM/yyyy&quot;, Locale.getDefault()).format(dateCal.time)}&quot;)&#10;                    Spacer(Modifier.width(8.dp))&#10;                    TextButton(onClick = { openDatePicker() }) { Text(&quot;Seleccionar fecha&quot;) }&#10;                }&#10;                Spacer(Modifier.height(8.dp))&#10;                Row(verticalAlignment = Alignment.CenterVertically) {&#10;                    Text(&quot;Hora: ${String.format(Locale.getDefault(), &quot;%02d:%02d&quot;, dateCal.get(Calendar.HOUR_OF_DAY), dateCal.get(Calendar.MINUTE))}&quot;)&#10;                    Spacer(Modifier.width(8.dp))&#10;                    TextButton(onClick = { openTimePicker() }) { Text(&quot;Seleccionar hora&quot;) }&#10;                }&#10;                Spacer(Modifier.height(8.dp))&#10;                Row { EventType.entries.forEach { ev -&gt;&#10;                    Row(verticalAlignment = Alignment.CenterVertically, modifier = Modifier.padding(end = 8.dp)) {&#10;                        RadioButton(selected = type == ev, onClick = { type = ev })&#10;                        Text(ev.name)&#10;                    }&#10;                }}&#10;                // target course selection for teachers&#10;                if (role == Role.DOCENTE) {&#10;                    Spacer(Modifier.height(8.dp))&#10;                    Text(&quot;Curso objetivo (opcional):&quot;, style = MaterialTheme.typography.labelMedium)&#10;                    // mostrar cursos disponibles para el docente&#10;                    LazyColumn(&#10;                        modifier = Modifier.heightIn(max = 200.dp),&#10;                        verticalArrangement = Arrangement.spacedBy(4.dp)&#10;                    ) {&#10;                        items(userCourses) { course -&gt;&#10;                            val isSelected = targetCourseId == course.first&#10;                            Row(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .clickable { targetCourseId = if (isSelected) null else course.first }&#10;                                    .padding(8.dp)&#10;                                    .background(&#10;                                        color = if (isSelected) MaterialTheme.colorScheme.primary.copy(alpha = 0.2f) else Color.Transparent,&#10;                                        shape = CircleShape&#10;                                    ),&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                Text(course.second, modifier = Modifier.weight(1f))&#10;                                if (isSelected) {&#10;                                    Icon(Icons.Filled.Check, contentDescription = &quot;Seleccionado&quot;, tint = MaterialTheme.colorScheme.primary)&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        },&#10;        confirmButton = {&#10;            TextButton(onClick = {&#10;                if (title.isBlank()) return@TextButton&#10;                onSave(title, description, dateCal.time, type, targetCourseId)&#10;            }) { Text(&quot;Guardar&quot;) }&#10;        },&#10;        dismissButton = {&#10;            TextButton(onClick = onDismiss) { Text(&quot;Cerrar&quot;) }&#10;        }&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun EditEventDialog(event: CalendarEvent, onDismiss: () -&gt; Unit, onSave: (CalendarEvent) -&gt; Unit, role: Role?, userCourses: List&lt;Pair&lt;String,String&gt;&gt; = emptyList()) {&#10;    val context = LocalContext.current&#10;    var title by remember { mutableStateOf(event.title) }&#10;    var description by remember { mutableStateOf(event.description) }&#10;    var dateCal by remember { mutableStateOf(Calendar.getInstance().apply { time = event.date }) }&#10;    var type by remember { mutableStateOf(event.type) }&#10;    var targetCourseId by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;    // cargar id de curso objetivo si es evento global&#10;    LaunchedEffect(event) {&#10;        targetCourseId = if (event.source == EventSource.GLOBAL) event.ownerId else null&#10;    }&#10;&#10;    fun openDatePicker() {&#10;        val c = dateCal&#10;        android.app.DatePickerDialog(context, { _, y, m, d -&gt; c.set(y, m, d); dateCal = c }, c.get(Calendar.YEAR), c.get(Calendar.MONTH), c.get(Calendar.DAY_OF_MONTH)).show()&#10;    }&#10;    fun openTimePicker() {&#10;        val c = dateCal&#10;        android.app.TimePickerDialog(context, { _, h, min -&gt; c.set(Calendar.HOUR_OF_DAY, h); c.set(Calendar.MINUTE, min); dateCal = c }, c.get(Calendar.HOUR_OF_DAY), c.get(Calendar.MINUTE), true).show()&#10;    }&#10;&#10;    AlertDialog(onDismissRequest = onDismiss, title = { Text(&quot;Editar Evento&quot;) }, text = {&#10;        Column {&#10;            OutlinedTextField(value = title, onValueChange = { title = it }, label = { Text(&quot;Título&quot;) }, singleLine = true)&#10;            Spacer(Modifier.height(8.dp))&#10;            OutlinedTextField(value = description, onValueChange = { description = it }, label = { Text(&quot;Descripción&quot;) })&#10;            Spacer(Modifier.height(8.dp))&#10;            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                Text(&quot;Fecha: ${SimpleDateFormat(&quot;dd/MM/yyyy&quot;, Locale.getDefault()).format(dateCal.time)}&quot;)&#10;                Spacer(Modifier.width(8.dp))&#10;                TextButton(onClick = { openDatePicker() }) { Text(&quot;Seleccionar fecha&quot;) }&#10;            }&#10;            Spacer(Modifier.height(8.dp))&#10;            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                Text(&quot;Hora: ${String.format(Locale.getDefault(), &quot;%02d:%02d&quot;, dateCal.get(Calendar.HOUR_OF_DAY), dateCal.get(Calendar.MINUTE))}&quot;)&#10;                Spacer(Modifier.width(8.dp))&#10;                TextButton(onClick = { openTimePicker() }) { Text(&quot;Seleccionar hora&quot;) }&#10;            }&#10;            Spacer(Modifier.height(8.dp))&#10;            Row { EventType.entries.forEach { ev -&gt; Row(verticalAlignment = Alignment.CenterVertically, modifier = Modifier.padding(end = 8.dp)) { RadioButton(selected = type == ev, onClick = { type = ev }); Text(ev.name) } } }&#10;            // target course selection for teachers&#10;            if (role == Role.DOCENTE) {&#10;                Spacer(Modifier.height(8.dp))&#10;                Text(&quot;Curso objetivo (opcional):&quot;, style = MaterialTheme.typography.labelMedium)&#10;                // mostrar cursos disponibles para el docente&#10;                LazyColumn(&#10;                    modifier = Modifier.heightIn(max = 200.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(4.dp)&#10;                ) {&#10;                    items(userCourses) { course -&gt;&#10;                        val isSelected = targetCourseId == course.first&#10;                        Row(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .clickable { targetCourseId = if (isSelected) null else course.first }&#10;                                .padding(8.dp)&#10;                                .background(&#10;                                    color = if (isSelected) MaterialTheme.colorScheme.primary.copy(alpha = 0.2f) else Color.Transparent,&#10;                                    shape = CircleShape&#10;                                ),&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            Text(course.second, modifier = Modifier.weight(1f))&#10;                            if (isSelected) {&#10;                                Icon(Icons.Filled.Check, contentDescription = &quot;Seleccionado&quot;, tint = MaterialTheme.colorScheme.primary)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }, confirmButton = {&#10;        TextButton(onClick = { onSave(CalendarEvent(event.id, title, description, dateCal.time, type, event.source, targetCourseId)) }) { Text(&quot;Guardar&quot;) }&#10;    }, dismissButton = { TextButton(onClick = onDismiss) { Text(&quot;Cerrar&quot;) } })&#10;}&#10;&#10;// helper to load upcoming events paginated&#10;private fun loadMoreUpcoming(db: FirebaseFirestore, auth: FirebaseAuth, dest: MutableList&lt;CalendarEvent&gt;, _role: Role?, courseIds: List&lt;String&gt; = emptyList(), lastSnapshot: DocumentSnapshot? = null, cbLast: (DocumentSnapshot?) -&gt; Unit) {&#10;    val uid = auth.currentUser?.uid ?: return&#10;    val col = db.collection(&quot;users&quot;).document(uid).collection(&quot;events&quot;)&#10;    val PAGE_SIZE = 25&#10;    try {&#10;        var q = col.whereGreaterThanOrEqualTo(&quot;date&quot;, Timestamp.now()).orderBy(&quot;date&quot;)&#10;        if (lastSnapshot != null) q = q.startAfter(lastSnapshot)&#10;        q = q.limit(PAGE_SIZE.toLong())&#10;        q.get().addOnSuccessListener { snap -&gt;&#10;            val docs = snap.documents&#10;            for (doc in docs) {&#10;                val id = doc.id&#10;                val title = doc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                val description = doc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                val ts = doc.get(&quot;date&quot;)&#10;                val d = when (ts) {&#10;                    is Timestamp -&gt; ts.toDate()&#10;                    is Date -&gt; ts&#10;                    else -&gt; null&#10;                }&#10;                val type = try { EventType.valueOf(doc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                val owner = doc.getString(&quot;ownerId&quot;)&#10;                if (d != null) dest.add(CalendarEvent(id, title, description, d, type, EventSource.USER, owner))&#10;            }&#10;            cbLast(docs.lastOrNull())&#10;            // usar _role para evitar advertencia de parámetro no usado&#10;            if (_role != null &amp;&amp; _role == Role.DOCENTE) { /* noop */ }&#10;             // additionally fetch upcoming global events for user's courses (no strict pagination)&#10;             if (courseIds.isNotEmpty()) {&#10;                 courseIds.chunked(10).forEach { chunk -&gt;&#10;                     db.collection(&quot;events&quot;).whereIn(&quot;courseId&quot;, chunk).whereGreaterThanOrEqualTo(&quot;date&quot;, Timestamp.now()).orderBy(&quot;date&quot;).limit(PAGE_SIZE.toLong()).get().addOnSuccessListener { gsnap -&gt;&#10;                         for (gdoc in gsnap.documents) {&#10;                             val id = gdoc.id&#10;                             if (dest.any { it.id == id }) continue&#10;                             val title = gdoc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                             val description = gdoc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                             val ts = gdoc.get(&quot;date&quot;)&#10;                             val d = when (ts) { is Timestamp -&gt; ts.toDate(); is Date -&gt; ts; else -&gt; null }&#10;                             val type = try { EventType.valueOf(gdoc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                             val courseId = gdoc.getString(&quot;courseId&quot;)&#10;                             if (d != null) dest.add(CalendarEvent(id, title, description, d, type, EventSource.GLOBAL, courseId))&#10;                         }&#10;                     }&#10;                 }&#10;             }&#10;         }&#10;     } catch (e: Exception) {&#10;         // ignore&#10;         cbLast(null)&#10;     }&#10; }" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/appcolegios/auth/SplashActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/appcolegios/auth/SplashActivity.kt" />
              <option name="updatedContent" value="package com.example.appcolegios.auth&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.os.Handler&#10;import android.os.Looper&#10;import android.view.animation.Animation&#10;import android.view.animation.AnimationUtils&#10;import android.widget.ImageView&#10;import androidx.appcompat.app.AppCompatActivity&#10;import com.example.appcolegios.R&#10;&#10;class SplashActivity : AppCompatActivity() {&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_splash)&#10;&#10;        // Animación de fade in para el logo&#10;        val logoView: ImageView = findViewById(R.id.splashLogo)&#10;        val fadeIn: Animation = AnimationUtils.loadAnimation(this, R.anim.fade_in)&#10;        logoView.startAnimation(fadeIn)&#10;&#10;        // Al terminar la animación, iniciar LoginActivity&#10;        fadeIn.setAnimationListener(object : Animation.AnimationListener {&#10;            override fun onAnimationStart(animation: Animation) {}&#10;            override fun onAnimationRepeat(animation: Animation) {}&#10;            override fun onAnimationEnd(animation: Animation) {&#10;                // Retardo breve antes de iniciar&#10;                Handler(Looper.getMainLooper()).postDelayed({&#10;                    startActivity(Intent(this@SplashActivity, com.example.appcolegios.auth.LoginActivity::class.java))&#10;                    finish()&#10;                }, 300)&#10;            }&#10;        })&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/appcolegios/data/model/Models.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/appcolegios/data/model/Models.kt" />
              <option name="originalContent" value="@file:Suppress(&quot;unused&quot;) // Suprime warnings de modelos aún no referenciados (Guardian, enums y constantes) conservándolos para futuras funcionalidades&#10;&#10;package com.example.appcolegios.data.model&#10;&#10;import com.google.firebase.firestore.DocumentId&#10;import java.util.Date&#10;&#10;data class Student(&#10;    val id: String,&#10;    val nombre: String,&#10;    val curso: String,&#10;    val grupo: String,&#10;    val numeroLista: Int,&#10;    val correoInstitucional: String,&#10;    val eps: String,&#10;    val estadoMatricula: String,&#10;    val promedio: Double,&#10;    val avatarUrl: String? = null&#10;)&#10;&#10;data class Guardian(&#10;    val id: String,&#10;    val nombre: String,&#10;    val telefono: String,&#10;    val parentesco: String&#10;)&#10;&#10;data class Grade(&#10;    val materiaId: String,&#10;    val materia: String,&#10;    val periodo: Int,&#10;    val calificacion: Double,&#10;    val ponderacion: Double&#10;)&#10;&#10;data class AttendanceEntry(&#10;    val fecha: Date,&#10;    val estado: AttendanceStatus&#10;)&#10;&#10;enum class AttendanceStatus {&#10;    PRESENTE, AUSENTE, TARDE&#10;}&#10;&#10;data class Homework(&#10;    val id: String,&#10;    val materia: String,&#10;    val titulo: String,&#10;    val descripcion: String,&#10;    val deadline: Date,&#10;    val progreso: Float,&#10;    val completada: Boolean&#10;)&#10;&#10;data class Notification(&#10;    @DocumentId val id: String = &quot;&quot;,&#10;    val titulo: String = &quot;&quot;,&#10;    val cuerpo: String = &quot;&quot;,&#10;    val remitente: String = &quot;&quot;,&#10;    val fechaHora: Date = Date(0),&#10;    val avatarUrl: String? = null,&#10;    val leida: Boolean = false&#10;)&#10;&#10;data class Message(&#10;    val id: String = &quot;&quot;,&#10;    val fromId: String = &quot;&quot;,&#10;    val toId: String = &quot;&quot;,&#10;    val texto: String = &quot;&quot;,&#10;    val fechaHora: Date = Date(0),&#10;    val tipo: MessageType = MessageType.TEXTO,&#10;    val estado: MessageStatus = MessageStatus.ENVIADO&#10;)&#10;&#10;enum class MessageType {&#10;    TEXTO, IMAGEN&#10;}&#10;&#10;enum class MessageStatus {&#10;    ENVIADO, ENTREGADO, LEIDO&#10;}&#10;&#10;data class Event(&#10;    val id: String,&#10;    val titulo: String,&#10;    val fechaHora: Date,&#10;    val categoria: EventCategory,&#10;    val descripcion: String,&#10;    val icon: String? = null&#10;)&#10;&#10;enum class EventCategory {&#10;    ACADEMICO, ADMINISTRATIVO&#10;}&#10;&#10;enum class TransportMode {&#10;    A_PIE, BICICLETA, PUBLICO, PARTICULAR&#10;}&#10;&#10;enum class ArrivalStatus {&#10;    EN_CAMINO, LLEGADO&#10;}&#10;" />
              <option name="updatedContent" value="@file:Suppress(&quot;unused&quot;) // Suprime warnings de modelos aún no referenciados (Guardian, enums y constantes) conservándolos para futuras funcionalidades&#13;&#10;&#13;&#10;package com.example.appcolegios.data.model&#13;&#10;&#13;&#10;import com.google.firebase.firestore.DocumentId&#13;&#10;import java.util.Date&#13;&#10;&#13;&#10;data class Student(&#13;&#10;    val id: String = &quot;&quot;,&#13;&#10;    val nombre: String = &quot;&quot;,&#13;&#10;    val curso: String = &quot;&quot;,&#13;&#10;    val grupo: String = &quot;&quot;,&#13;&#10;    val numeroLista: Int = 0,&#13;&#10;    val correoInstitucional: String = &quot;&quot;,&#13;&#10;    val eps: String = &quot;&quot;,&#13;&#10;    val estadoMatricula: String = &quot;&quot;,&#13;&#10;    val promedio: Double = 0.0,&#13;&#10;    val avatarUrl: String? = null&#13;&#10;)&#13;&#10;&#13;&#10;data class Guardian(&#13;&#10;    val id: String,&#13;&#10;    val nombre: String,&#13;&#10;    val telefono: String,&#13;&#10;    val parentesco: String&#13;&#10;)&#13;&#10;&#13;&#10;data class Grade(&#13;&#10;    val materiaId: String,&#13;&#10;    val materia: String,&#13;&#10;    val periodo: Int,&#13;&#10;    val calificacion: Double,&#13;&#10;    val ponderacion: Double&#13;&#10;)&#13;&#10;&#13;&#10;data class AttendanceEntry(&#13;&#10;    val fecha: Date,&#13;&#10;    val estado: AttendanceStatus&#13;&#10;)&#13;&#10;&#13;&#10;enum class AttendanceStatus {&#13;&#10;    PRESENTE, AUSENTE, TARDE&#13;&#10;}&#13;&#10;&#13;&#10;data class Homework(&#13;&#10;    val id: String,&#13;&#10;    val materia: String,&#13;&#10;    val titulo: String,&#13;&#10;    val descripcion: String,&#13;&#10;    val deadline: Date,&#13;&#10;    val progreso: Float,&#13;&#10;    val completada: Boolean&#13;&#10;)&#13;&#10;&#13;&#10;data class Notification(&#13;&#10;    @DocumentId val id: String = &quot;&quot;,&#13;&#10;    val titulo: String = &quot;&quot;,&#13;&#10;    val cuerpo: String = &quot;&quot;,&#13;&#10;    val remitente: String = &quot;&quot;,&#13;&#10;    val fechaHora: Date = Date(0),&#13;&#10;    val avatarUrl: String? = null,&#13;&#10;    val leida: Boolean = false&#13;&#10;)&#13;&#10;&#13;&#10;data class Message(&#13;&#10;    val id: String = &quot;&quot;,&#13;&#10;    val fromId: String = &quot;&quot;,&#13;&#10;    val toId: String = &quot;&quot;,&#13;&#10;    val texto: String = &quot;&quot;,&#13;&#10;    val fechaHora: Date = Date(0),&#13;&#10;    val tipo: MessageType = MessageType.TEXTO,&#13;&#10;    val estado: MessageStatus = MessageStatus.ENVIADO&#13;&#10;)&#13;&#10;&#13;&#10;enum class MessageType {&#13;&#10;    TEXTO, IMAGEN&#13;&#10;}&#13;&#10;&#13;&#10;enum class MessageStatus {&#13;&#10;    ENVIADO, ENTREGADO, LEIDO&#13;&#10;}&#13;&#10;&#13;&#10;data class Event(&#13;&#10;    val id: String,&#13;&#10;    val titulo: String,&#13;&#10;    val fechaHora: Date,&#13;&#10;    val categoria: EventCategory,&#13;&#10;    val descripcion: String,&#13;&#10;    val icon: String? = null&#13;&#10;)&#13;&#10;&#13;&#10;enum class EventCategory {&#13;&#10;    ACADEMICO, ADMINISTRATIVO&#13;&#10;}&#13;&#10;&#13;&#10;enum class TransportMode {&#13;&#10;    A_PIE, BICICLETA, PUBLICO, PARTICULAR&#13;&#10;}&#13;&#10;&#13;&#10;enum class ArrivalStatus {&#13;&#10;    EN_CAMINO, LLEGADO&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/appcolegios/ui/AnimatedMaterialButton.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/appcolegios/ui/AnimatedMaterialButton.kt" />
              <option name="updatedContent" value="package com.example.appcolegios.ui&#10;&#10;import android.content.Context&#10;import android.util.AttributeSet&#10;import android.view.MotionEvent&#10;import com.google.android.material.button.MaterialButton&#10;&#10;class AnimatedMaterialButton @JvmOverloads constructor(&#10;    context: Context,&#10;    attrs: AttributeSet? = null,&#10;    defStyleAttr: Int = com.google.android.material.R.attr.materialButtonStyle&#10;) : MaterialButton(context, attrs, defStyleAttr) {&#10;&#10;    override fun onTouchEvent(event: MotionEvent): Boolean {&#10;        when (event.action) {&#10;            MotionEvent.ACTION_DOWN -&gt; {&#10;                this.animate().scaleX(0.97f).scaleY(0.97f).setDuration(50).start()&#10;            }&#10;            MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -&gt; {&#10;                this.animate().scaleX(1f).scaleY(1f).setDuration(50).start()&#10;            }&#10;        }&#10;        return super.onTouchEvent(event)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>