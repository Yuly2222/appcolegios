<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/SOLUCION_DEFINITIVA.bat">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/SOLUCION_DEFINITIVA.bat" />
              <option name="updatedContent" value="@echo off&#10;echo ==========================================&#10;echo SOLUCION DEFINITIVA - ERROR GRADLE TASKS&#10;echo ==========================================&#10;cd /d &quot;%~dp0&quot;&#10;&#10;echo.&#10;echo Este script resolvera: &quot;Unable to find Gradle tasks to build&quot;&#10;echo.&#10;pause&#10;&#10;echo.&#10;echo [1/8] Cerrando Android Studio si esta abierto...&#10;echo Por favor, CIERRA Android Studio ahora si esta abierto.&#10;echo.&#10;pause&#10;&#10;echo.&#10;echo [2/8] Deteniendo procesos de Gradle...&#10;call gradlew.bat --stop&#10;timeout /t 3 /nobreak &gt; nul&#10;&#10;echo.&#10;echo [3/8] Eliminando cache del proyecto...&#10;if exist .gradle rmdir /s /q .gradle&#10;if exist .idea rmdir /s /q .idea&#10;if exist .kotlin rmdir /s /q .kotlin&#10;if exist build rmdir /s /q build&#10;if exist app\build rmdir /s /q app\build&#10;&#10;echo.&#10;echo [4/8] Eliminando archivos de configuracion del IDE...&#10;if exist *.iml del /q *.iml&#10;if exist app\*.iml del /q app\*.iml&#10;&#10;echo.&#10;echo [5/8] Limpiando con Gradle...&#10;call gradlew.bat clean&#10;&#10;echo.&#10;echo [6/8] Verificando estructura del proyecto...&#10;call gradlew.bat projects&#10;&#10;echo.&#10;echo [7/8] Listando tareas disponibles...&#10;call gradlew.bat tasks&#10;&#10;echo.&#10;echo [8/8] Compilando el proyecto...&#10;call gradlew.bat assembleDebug&#10;&#10;echo.&#10;echo ==========================================&#10;echo COMPLETADO!&#10;echo ==========================================&#10;echo.&#10;echo Ahora ABRE Android Studio y:&#10;echo 1. Abre este proyecto&#10;echo 2. File ^&gt; Sync Project with Gradle Files&#10;echo 3. Build ^&gt; Rebuild Project&#10;echo.&#10;echo El error deberia estar resuelto.&#10;echo ==========================================&#10;pause&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/appcolegios/academico/CalendarScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/appcolegios/academico/CalendarScreen.kt" />
              <option name="originalContent" value="package com.example.appcolegios.academico&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.gestures.detectHorizontalDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.grid.GridCells&#10;import androidx.compose.foundation.lazy.grid.LazyVerticalGrid&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import kotlinx.coroutines.launch&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.appcolegios.perfil.ProfileViewModel&#10;import com.example.appcolegios.data.UserPreferencesRepository&#10;import com.example.appcolegios.data.UserData&#10;import com.example.appcolegios.data.model.Role&#10;import androidx.compose.ui.platform.LocalContext&#10;import android.util.Log&#10;import com.google.firebase.Timestamp&#10;import com.google.firebase.firestore.ListenerRegistration&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.animation.AnimatedContent&#10;import androidx.compose.animation.ExperimentalAnimationApi&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.animation.slideInHorizontally&#10;import androidx.compose.animation.slideOutHorizontally&#10;import androidx.compose.animation.togetherWith&#10;import androidx.compose.material.icons.automirrored.filled.Assignment&#10;import androidx.compose.material.icons.automirrored.filled.EventNote&#10;import androidx.compose.runtime.key&#10;import java.time.Instant&#10;import java.time.LocalDate&#10;import java.time.ZoneId&#10;import java.time.temporal.WeekFields&#10;import com.google.firebase.firestore.DocumentSnapshot&#10;import java.util.Locale&#10; import kotlinx.coroutines.tasks.await&#10;&#10;enum class EventSource { USER, GLOBAL }&#10;&#10;data class CalendarEvent(&#10;    val id: String,&#10;    val title: String,&#10;    val description: String,&#10;    val date: Date,&#10;    val type: EventType,&#10;    val source: EventSource = EventSource.USER,&#10;    val ownerId: String? = null // for USER -&gt; userId; for GLOBAL -&gt; courseId or owner&#10;)&#10;&#10;enum class EventType {&#10;    CLASE, EXAMEN, TAREA, EVENTO&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class, ExperimentalAnimationApi::class)&#10;@Composable&#10;fun CalendarScreen(eventId: String? = null) {&#10;    // Separamos mes mostrado y fecha seleccionada&#10;    var displayedMonth by remember { mutableStateOf(Calendar.getInstance()) }&#10;    var selectedDay by remember { mutableStateOf&lt;Calendar?&gt;(Calendar.getInstance()) }&#10;    var showAddEventDialog by remember { mutableStateOf(false) }&#10;    val context = LocalContext.current&#10;&#10;    // Eventos para el mes mostrado (se cargan por rango mediante snapshot listener)&#10;    val events = remember { mutableStateListOf&lt;CalendarEvent&gt;() }&#10;    val auth = FirebaseAuth.getInstance()&#10;    val db = FirebaseFirestore.getInstance()&#10;    // user role and preferences&#10;    val userPrefs = remember { UserPreferencesRepository(context) }&#10;    val userData by userPrefs.userData.collectAsState(initial = UserData(null, null, null))&#10;    val role = userData.roleEnum&#10;    // courses for teacher/student/child selection&#10;    val userCourses = remember { mutableStateListOf&lt;Pair&lt;String,String&gt;&gt;() }&#10;    // Próximos eventos paginados y filtro por tipo&#10;    val upcomingEvents = remember { mutableStateListOf&lt;CalendarEvent&gt;() }&#10;    var upcomingLastSnapshot by remember { mutableStateOf&lt;DocumentSnapshot?&gt;(null) }&#10;    var selectedFilterType by remember { mutableStateOf&lt;EventType?&gt;(null) }&#10;&#10;    // Estado del bottom sheet para mostrar eventos del día seleccionado&#10;    var bottomSheetVisible by remember { mutableStateOf(false) }&#10;&#10;    // Estados para edición / borrado (deben existir para las acciones de la lista y bottom sheet)&#10;    var editingEvent by remember { mutableStateOf&lt;CalendarEvent?&gt;(null) }&#10;    var showEditEventDialog by remember { mutableStateOf(false) }&#10;    var eventToDelete by remember { mutableStateOf&lt;CalendarEvent?&gt;(null) }&#10;    var showDeleteConfirm by remember { mutableStateOf(false) }&#10;&#10;    // Profile VM: para padres (lista de hijos)&#10;    val profileVm: ProfileViewModel = viewModel()&#10;    val children: List&lt;com.example.appcolegios.data.model.Student&gt; by profileVm.children.collectAsState()&#10;    var selectedChildIndex by remember { mutableStateOf(0) }&#10;&#10;    // Listener registration manejado con DisposableEffect: soporta múltiples listeners según rol&#10;    DisposableEffect(displayedMonth.timeInMillis, auth.currentUser?.uid, role, selectedChildIndex) {&#10;        val userId = auth.currentUser?.uid&#10;        val regs = mutableListOf&lt;ListenerRegistration&gt;()&#10;        events.clear()&#10;&#10;        if (userId != null) {&#10;            // calcular primer y ultimo día del mes mostrado&#10;            val start = (displayedMonth.clone() as Calendar).apply {&#10;                set(Calendar.DAY_OF_MONTH, 1)&#10;                set(Calendar.HOUR_OF_DAY, 0)&#10;                set(Calendar.MINUTE, 0)&#10;                set(Calendar.SECOND, 0)&#10;                set(Calendar.MILLISECOND, 0)&#10;            }&#10;            val end = (displayedMonth.clone() as Calendar).apply {&#10;                set(Calendar.DAY_OF_MONTH, getActualMaximum(Calendar.DAY_OF_MONTH))&#10;                set(Calendar.HOUR_OF_DAY, 23)&#10;                set(Calendar.MINUTE, 59)&#10;                set(Calendar.SECOND, 59)&#10;                set(Calendar.MILLISECOND, 999)&#10;            }&#10;            val startTs = Timestamp(start.time)&#10;            val endTs = Timestamp(end.time)&#10;&#10;            try {&#10;                // 1) listener to personal events of the viewed user (teacher sees own personal too)&#10;                val personalListener = db.collection(&quot;users&quot;).document(userId).collection(&quot;events&quot;)&#10;                    .whereGreaterThanOrEqualTo(&quot;date&quot;, startTs)&#10;                    .whereLessThanOrEqualTo(&quot;date&quot;, endTs)&#10;                    .addSnapshotListener { snap, e -&gt;&#10;                        if (e != null) { Log.e(&quot;CalendarScreen&quot;, &quot;Personal listener error: ${e.message}&quot;); return@addSnapshotListener }&#10;                        if (snap != null) {&#10;                            for (doc in snap.documents) {&#10;                                val id = doc.id&#10;                                val title = doc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                                val description = doc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                                val ts = doc.get(&quot;date&quot;)&#10;                                val d = when (ts) { is Timestamp -&gt; ts.toDate(); is Date -&gt; ts; else -&gt; null }&#10;                                val type = try { EventType.valueOf(doc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                                if (d != null &amp;&amp; events.none { it.id == id }) events.add(CalendarEvent(id, title, description, d, type, EventSource.USER, userId))&#10;                                val rec = doc.getString(&quot;recurrence&quot;)&#10;                                if (!rec.isNullOrBlank() &amp;&amp; d != null) {&#10;                                    try { val occ = generateOccurrences(d, rec, start.time, end.time); occ.forEachIndexed { idx, occDate -&gt; if (events.none { it.id == &quot;${id}_occ_$idx&quot; }) events.add(CalendarEvent(&quot;${id}_occ_$idx&quot;, title, description, occDate, type, EventSource.USER, userId)) } } catch (_: Exception) {}&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                regs.add(personalListener)&#10;&#10;                // 2) role-specific: teacher -&gt; events for their courses; student -&gt; events for courses enrolled; parent -&gt; events for selected child&#10;                when (role) {&#10;                    Role.DOCENTE -&gt; {&#10;                        // get course ids taught by teacher&#10;                        val courseIds = mutableListOf&lt;String&gt;()&#10;                        try {&#10;                            val q = db.collection(&quot;courses&quot;).whereEqualTo(&quot;teacherId&quot;, userId).get()&#10;                            q.addOnSuccessListener { snap -&gt;&#10;                                userCourses.clear()&#10;                                for (doc in snap.documents) {&#10;                                    val cid = doc.id&#10;                                    courseIds.add(cid)&#10;                                    val cname = doc.getString(&quot;name&quot;) ?: doc.getString(&quot;title&quot;) ?: cid&#10;                                    userCourses.add(Pair(cid, cname))&#10;                                }&#10;                                // query top-level events where courseId in courseIds, chunked by 10&#10;                                if (courseIds.isNotEmpty()) {&#10;                                    courseIds.chunked(10).forEach { chunk -&gt;&#10;                                        val evQuery = db.collection(&quot;events&quot;).whereIn(&quot;courseId&quot;, chunk).whereGreaterThanOrEqualTo(&quot;date&quot;, startTs).whereLessThanOrEqualTo(&quot;date&quot;, endTs)&#10;                                        val r = evQuery.addSnapshotListener { snap2, e2 -&gt;&#10;                                            if (e2 != null) { Log.e(&quot;CalendarScreen&quot;,&quot;Course events listener err: ${e2.message}&quot;); return@addSnapshotListener }&#10;                                            if (snap2 != null) {&#10;                                                for (doc in snap2.documents) {&#10;                                                    val id = doc.id&#10;                                                    val title = doc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                                                    val description = doc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                                                    val ts = doc.get(&quot;date&quot;)&#10;                                                    val d = when (ts) { is Timestamp -&gt; ts.toDate(); is Date -&gt; ts; else -&gt; null }&#10;                                                    val type = try { EventType.valueOf(doc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                                                    if (d != null &amp;&amp; events.none { it.id == id }) events.add(CalendarEvent(id, title, description, d, type, EventSource.GLOBAL, null))&#10;                                                }&#10;                                            }&#10;                                        }&#10;                                        regs.add(r)&#10;                                    }&#10;                                }&#10;                            }&#10;                        } catch (_: Exception) { }&#10;                    }&#10;                    Role.ESTUDIANTE -&gt; {&#10;                        // student: read student doc for courses&#10;                        try {&#10;                            val sdocTask = db.collection(&quot;students&quot;).document(userId).get()&#10;                            sdocTask.addOnSuccessListener { sdoc -&gt;&#10;                                val courseIds = (sdoc.get(&quot;courses&quot;) as? List&lt;*&gt;)?.mapNotNull { it?.toString() } ?: emptyList()&#10;                                // populate userCourses with names&#10;                                userCourses.clear()&#10;                                for (cid in courseIds) {&#10;                                    db.collection(&quot;courses&quot;).document(cid).get().addOnSuccessListener { cdoc -&gt;&#10;                                        if (cdoc.exists()) userCourses.add(Pair(cid, cdoc.getString(&quot;name&quot;) ?: cid))&#10;                                    }&#10;                                }&#10;                                if (courseIds.isNotEmpty()) {&#10;                                    courseIds.chunked(10).forEach { chunk -&gt;&#10;                                        val evQuery = db.collection(&quot;events&quot;).whereIn(&quot;courseId&quot;, chunk).whereGreaterThanOrEqualTo(&quot;date&quot;, startTs).whereLessThanOrEqualTo(&quot;date&quot;, endTs)&#10;                                        val r = evQuery.addSnapshotListener { snap2, e2 -&gt;&#10;                                            if (e2 != null) return@addSnapshotListener&#10;                                            if (snap2 != null) {&#10;                                                for (doc in snap2.documents) {&#10;                                                    val id = doc.id&#10;                                                    val title = doc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                                                    val description = doc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                                                    val ts = doc.get(&quot;date&quot;)&#10;                                                    val d = when (ts) { is Timestamp -&gt; ts.toDate(); is Date -&gt; ts; else -&gt; null }&#10;                                                    val type = try { EventType.valueOf(doc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                                                    if (d != null &amp;&amp; events.none { it.id == id }) events.add(CalendarEvent(id, title, description, d, type, EventSource.GLOBAL, null))&#10;                                                }&#10;                                            }&#10;                                        }&#10;                                        regs.add(r)&#10;                                    }&#10;                                }&#10;                            }&#10;                        } catch (_: Exception) { }&#10;                    }&#10;                    Role.PADRE -&gt; {&#10;                        // parent: use selected child&#10;                        val childId = children.getOrNull(selectedChildIndex)?.id&#10;                        if (!childId.isNullOrBlank()) {&#10;                            // personal events of child&#10;                            val childListener = db.collection(&quot;users&quot;).document(childId).collection(&quot;events&quot;)&#10;                                .whereGreaterThanOrEqualTo(&quot;date&quot;, startTs)&#10;                                .whereLessThanOrEqualTo(&quot;date&quot;, endTs)&#10;                                .addSnapshotListener { snap, e -&gt;&#10;                                    if (e != null) { Log.e(&quot;CalendarScreen&quot;, &quot;Child listener error: ${e.message}&quot;); return@addSnapshotListener }&#10;                                    if (snap != null) {&#10;                                        for (doc in snap.documents) {&#10;                                            val id = doc.id&#10;                                            val title = doc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                                            val description = doc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                                            val ts = doc.get(&quot;date&quot;)&#10;                                            val d = when (ts) { is Timestamp -&gt; ts.toDate(); is Date -&gt; ts; else -&gt; null }&#10;                                            val type = try { EventType.valueOf(doc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                                            if (d != null &amp;&amp; events.none { it.id == id }) events.add(CalendarEvent(id, title, description, d, type, EventSource.USER, childId))&#10;                                        }&#10;                                    }&#10;                                }&#10;                            regs.add(childListener)&#10;&#10;                            // also load course events for that child (like student)&#10;                            try {&#10;                                val sdocTask = db.collection(&quot;students&quot;).document(childId).get()&#10;                                sdocTask.addOnSuccessListener { sdoc -&gt;&#10;                                    val courseIds = (sdoc.get(&quot;courses&quot;) as? List&lt;*&gt;)?.mapNotNull { it?.toString() } ?: emptyList()&#10;                                    if (courseIds.isNotEmpty()) {&#10;                                        courseIds.chunked(10).forEach { chunk -&gt;&#10;                                            val evQuery = db.collection(&quot;events&quot;).whereIn(&quot;courseId&quot;, chunk).whereGreaterThanOrEqualTo(&quot;date&quot;, startTs).whereLessThanOrEqualTo(&quot;date&quot;, endTs)&#10;                                            val r = evQuery.addSnapshotListener { snap2, e2 -&gt;&#10;                                                if (e2 != null) { Log.e(&quot;CalendarScreen&quot;, &quot;Child course events listener err: ${e2.message}&quot;); return@addSnapshotListener }&#10;                                                if (snap2 != null) {&#10;                                                    for (doc in snap2.documents) {&#10;                                                        val id = doc.id&#10;                                                        val title = doc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                                                        val description = doc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                                                        val ts = doc.get(&quot;date&quot;)&#10;                                                        val d = when (ts) { is Timestamp -&gt; ts.toDate(); is Date -&gt; ts; else -&gt; null }&#10;                                                        val type = try { EventType.valueOf(doc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                                                        if (d != null &amp;&amp; events.none { it.id == id }) events.add(CalendarEvent(id, title, description, d, type, EventSource.GLOBAL, doc.getString(&quot;courseId&quot;)))&#10;                                                    }&#10;                                                }&#10;                                            }&#10;                                            regs.add(r)&#10;                                        }&#10;                                    }&#10;                                }&#10;                            } catch (_: Exception) {}&#10;                        }&#10;                    }&#10;                    else -&gt; {&#10;                        // default: no extra listeners&#10;                    }&#10;                }&#10;            } catch (ex: Exception) {&#10;                Log.e(&quot;CalendarScreen&quot;, &quot;Error starting listeners: ${ex.message}&quot;, ex)&#10;            }&#10;        }&#10;&#10;        onDispose {&#10;            regs.forEach { try { it.remove() } catch (_: Exception) {} }&#10;        }&#10;    }&#10;&#10;    // Snackbar / scaffold&#10;    val snackbarHostState = remember { SnackbarHostState() }&#10;    val scope = rememberCoroutineScope()&#10;&#10;    Scaffold(&#10;        snackbarHost = { SnackbarHost(hostState = snackbarHostState) }&#10;    ) { innerPadding -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(innerPadding)&#10;                .padding(16.dp)&#10;        ) {&#10;            // Header con mes actual&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                IconButton(onClick = {&#10;                    displayedMonth = (displayedMonth.clone() as Calendar).apply { add(Calendar.MONTH, -1) }&#10;                }) {&#10;                    Icon(Icons.Filled.ChevronLeft, contentDescription = &quot;Mes anterior&quot;)&#10;                }&#10;&#10;                Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                    Text(&#10;                        text = SimpleDateFormat(&quot;MMMM yyyy&quot;, Locale.getDefault()).format(displayedMonth.time),&#10;                        style = MaterialTheme.typography.titleLarge,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;                    TextButton(onClick = { // volver a hoy&#10;                        displayedMonth = Calendar.getInstance()&#10;                        selectedDay = Calendar.getInstance()&#10;                    }) { Text(&quot;Hoy&quot;) }&#10;&#10;                    // selector de hijo para PADRE&#10;                    if (role == Role.PADRE) {&#10;                        Spacer(Modifier.height(8.dp))&#10;                        Row(verticalAlignment = Alignment.CenterVertically) {&#10;                            Text(&quot;Hijo: &quot;)&#10;                            if (children.isEmpty()) {&#10;                                Text(&quot;(sin hijos)&quot;)&#10;                            } else {&#10;                                var expanded by remember { mutableStateOf(false) }&#10;                                val label = children.getOrNull(selectedChildIndex)?.nombre ?: &quot;Seleccionar&quot;&#10;                                Box {&#10;                                    TextButton(onClick = { expanded = true }) { Text(label) }&#10;                                    DropdownMenu(expanded = expanded, onDismissRequest = { expanded = false }) {&#10;                                        children.forEachIndexed { idx, child -&gt;&#10;                                            DropdownMenuItem(text = { Text(child.nombre) }, onClick = { selectedChildIndex = idx; expanded = false })&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                IconButton(onClick = {&#10;                    displayedMonth = (displayedMonth.clone() as Calendar).apply { add(Calendar.MONTH, 1) }&#10;                }) {&#10;                    Icon(Icons.Filled.ChevronRight, contentDescription = &quot;Mes siguiente&quot;)&#10;                }&#10;            }&#10;&#10;            Spacer(Modifier.height(16.dp))&#10;&#10;            // Días de la semana -- respetar locale (primer día simplificado)&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceEvenly&#10;            ) {&#10;                // Obtener nombres de días desde locale&#10;                val df = SimpleDateFormat(&quot;EE&quot;, Locale.getDefault())&#10;                val headerCal = Calendar.getInstance()&#10;                // usar firstDayOfWeek del locale&#10;                val firstDow = headerCal.firstDayOfWeek&#10;                for (i in 0 until 7) {&#10;                    headerCal.set(Calendar.DAY_OF_WEEK, (firstDow + i - 1) % 7 + 1)&#10;                    Text(&#10;                        text = df.format(headerCal.time),&#10;                        modifier = Modifier.weight(1f),&#10;                        textAlign = TextAlign.Center,&#10;                        style = MaterialTheme.typography.labelMedium,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = MaterialTheme.colorScheme.primary&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(Modifier.height(8.dp))&#10;&#10;            // Grid del calendario con fecha seleccionada y soporte swipe/anim&#10;            Box(modifier = Modifier&#10;                .fillMaxWidth()&#10;                .height(320.dp)&#10;                .pointerInput(Unit) {&#10;                    detectHorizontalDragGestures { change, dragAmount -&gt;&#10;                        val threshold = 150&#10;                        if (dragAmount &gt; threshold) {&#10;                            // swipe derecha -&gt; mes anterior&#10;                            displayedMonth = (displayedMonth.clone() as Calendar).apply { add(Calendar.MONTH, -1) }&#10;                        } else if (dragAmount &lt; -threshold) {&#10;                            // swipe izquierda -&gt; mes siguiente&#10;                            displayedMonth = (displayedMonth.clone() as Calendar).apply { add(Calendar.MONTH, 1) }&#10;                        }&#10;                    }&#10;                }&#10;            ) {&#10;                AnimatedContent(targetState = displayedMonth.timeInMillis, transitionSpec = {&#10;                    slideInHorizontally(initialOffsetX = { fullWidth -&gt; if (targetState &gt; initialState) fullWidth else -fullWidth }, animationSpec = tween(300))&#10;                        .togetherWith(&#10;                            slideOutHorizontally(targetOffsetX = { fullWidth -&gt; if (targetState &gt; initialState) -fullWidth else fullWidth }, animationSpec = tween(300))&#10;                        )&#10;                }) { ts -&gt;&#10;                       key(ts) {&#10;                           CalendarGrid(&#10;                               displayedMonth = displayedMonth,&#10;                               selectedDay = selectedDay,&#10;                               events = events,&#10;                               onDateSelected = { cal -&gt;&#10;                                   selectedDay = cal&#10;                                   bottomSheetVisible = true&#10;                               }&#10;                           )&#10;                       }&#10;                   }&#10;             }&#10;&#10;            Spacer(Modifier.height(16.dp))&#10;&#10;            // Botón para agregar evento&#10;            Button(&#10;                onClick = { showAddEventDialog = true },&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Icon(Icons.Filled.Add, contentDescription = &quot;Agregar evento&quot;)&#10;                Spacer(Modifier.width(8.dp))&#10;                Text(&quot;Agregar Evento&quot;)&#10;            }&#10;&#10;            Spacer(Modifier.height(16.dp))&#10;&#10;            // Lista de próximos eventos (paginated) con filtro por tipo&#10;            Text(&#10;                &quot;Próximos Eventos&quot;,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;&#10;            Spacer(Modifier.height(8.dp))&#10;&#10;            // Filtro por tipo&#10;            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                Text(&quot;Filtrar: &quot;)&#10;                Spacer(Modifier.width(8.dp))&#10;                // botones simples para filtrar por tipo&#10;                EventType.entries.let { types -&gt;&#10;                    types.forEach { t -&gt;&#10;                         val selected = selectedFilterType == t&#10;                         TextButton(onClick = { selectedFilterType = if (selected) null else t }) {&#10;                             Text(t.name, color = if (selected) MaterialTheme.colorScheme.onPrimary else MaterialTheme.colorScheme.onSurface)&#10;                         }&#10;                     }&#10;                 }&#10;            }&#10;&#10;            Spacer(Modifier.height(8.dp))&#10;&#10;            // carga inicial de upcoming en background (no duplicar si ya cargado)&#10;            LaunchedEffect(auth.currentUser?.uid) {&#10;                upcomingEvents.clear()&#10;                upcomingLastSnapshot = null&#10;                // pasar los courseIds disponibles (si ya se cargaron) para traer también eventos globales&#10;                val courseIds = userCourses.map { it.first }&#10;                loadMoreUpcoming(db, auth, upcomingEvents, courseIds) { doc -&gt; upcomingLastSnapshot = doc }&#10;            }&#10;&#10;            val displayedUpcoming = if (selectedFilterType == null) upcomingEvents.toList() else upcomingEvents.filter { it.type == selectedFilterType }&#10;&#10;            LazyColumn(&#10;                 verticalArrangement = Arrangement.spacedBy(8.dp)&#10;             ) {&#10;                items(displayedUpcoming) { event -&gt;&#10;                    // per-event permissions: owner can edit/delete USER events; DOCENTE can edit/delete GLOBAL events&#10;                    val uid = auth.currentUser?.uid&#10;                    val allowEdit = when (event.source) {&#10;                        EventSource.USER -&gt; event.ownerId == uid&#10;                        EventSource.GLOBAL -&gt; role == Role.DOCENTE&#10;                    }&#10;                    val allowDelete = allowEdit&#10;                    EventCard(event,&#10;                        onEdit = if (allowEdit) { ev -&gt; editingEvent = ev; showEditEventDialog = true } else null,&#10;                        onDelete = if (allowDelete) { ev -&gt; eventToDelete = ev; showDeleteConfirm = true } else null&#10;                    )&#10;                }&#10;                item {&#10;                    Spacer(Modifier.height(6.dp))&#10;                    Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.Center) {&#10;                        val courseIds = userCourses.map { it.first }&#10;                        if (upcomingLastSnapshot != null) {&#10;                            Button(onClick = { loadMoreUpcoming(db, auth, upcomingEvents, courseIds) { doc -&gt; upcomingLastSnapshot = doc } }) { Text(&quot;Cargar más&quot;) }&#10;                        }&#10;                    }&#10;                 }&#10;             }&#10;         }&#10;     }&#10;&#10;    // Bottom sheet para eventos del día seleccionado (simple Modal)&#10;    if (bottomSheetVisible &amp;&amp; selectedDay != null) {&#10;        val selLocal = LocalDate.of(selectedDay!!.get(Calendar.YEAR), selectedDay!!.get(Calendar.MONTH)+1, selectedDay!!.get(Calendar.DAY_OF_MONTH))&#10;        val dayEvents = events.filter { ev -&gt;&#10;            val evLocal = Instant.ofEpochMilli(ev.date.time).atZone(ZoneId.systemDefault()).toLocalDate()&#10;            evLocal == selLocal&#10;        }.sortedBy { it.date }&#10;&#10;        ModalBottomSheet(&#10;            onDismissRequest = { bottomSheetVisible = false }&#10;        ) {&#10;            Column(modifier = Modifier.padding(16.dp)) {&#10;                Text(&quot;Eventos en ${SimpleDateFormat(&quot;dd/MM/yyyy&quot;, Locale.getDefault()).format(selectedDay!!.time)}&quot;, style = MaterialTheme.typography.titleMedium, fontWeight = FontWeight.Bold)&#10;                Spacer(Modifier.height(8.dp))&#10;                if (dayEvents.isEmpty()) {&#10;                    Text(&quot;No hay eventos para este día&quot;, color = MaterialTheme.colorScheme.onSurfaceVariant)&#10;                } else {&#10;                    dayEvents.forEach { ev -&gt;&#10;                        val uid = auth.currentUser?.uid&#10;                        val allowEdit = when (ev.source) {&#10;                            EventSource.USER -&gt; ev.ownerId == uid&#10;                            EventSource.GLOBAL -&gt; role == Role.DOCENTE&#10;                        }&#10;                        val allowDelete = allowEdit&#10;                        EventCard(ev,&#10;                            onEdit = if (allowEdit) { e -&gt; editingEvent = e; showEditEventDialog = true } else null,&#10;                            onDelete = if (allowDelete) { e -&gt; eventToDelete = e; showDeleteConfirm = true } else null&#10;                        )&#10;                        Spacer(Modifier.height(8.dp))&#10;                    }&#10;                }&#10;                Spacer(Modifier.height(8.dp))&#10;                Row(horizontalArrangement = Arrangement.End, modifier = Modifier.fillMaxWidth()) {&#10;                    TextButton(onClick = { bottomSheetVisible = false }) { Text(&quot;Cerrar&quot;) }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    if (showAddEventDialog) {&#10;        AddEventDialog(&#10;            initialDate = selectedDay?.time ?: displayedMonth.time,&#10;            onDismiss = { showAddEventDialog = false },&#10;            onSave = { title, description, date, type, targetCourseId -&gt;&#10;                val userId = auth.currentUser?.uid&#10;                if (userId == null) {&#10;                    scope.launch { snackbarHostState.showSnackbar(&quot;Debes iniciar sesión para agregar eventos&quot;) }&#10;                    return@AddEventDialog&#10;                }&#10;                val db = FirebaseFirestore.getInstance()&#10;                val eventId = UUID.randomUUID().toString()&#10;                val eventData = hashMapOf&lt;String, Any?&gt;(&#10;                    &quot;id&quot; to eventId,&#10;                    &quot;title&quot; to title,&#10;                    &quot;description&quot; to description,&#10;                    &quot;date&quot; to Timestamp(date),&#10;                    &quot;type&quot; to type.name,&#10;                    &quot;createdAt&quot; to Timestamp.now(),&#10;                    &quot;ownerId&quot; to userId&#10;                )&#10;                // If teacher selected a course target, save as global event in top-level collection&#10;                if (role == Role.DOCENTE &amp;&amp; !targetCourseId.isNullOrBlank()) {&#10;                    eventData[&quot;courseId&quot;] = targetCourseId&#10;                    db.collection(&quot;events&quot;).document(eventId)&#10;                        .set(eventData)&#10;                        .addOnSuccessListener {&#10;                            events.add(CalendarEvent(eventId, title, description, date, type, EventSource.GLOBAL, targetCourseId))&#10;                            showAddEventDialog = false&#10;                            scope.launch { snackbarHostState.showSnackbar(&quot;Evento de curso agregado&quot;) }&#10;&#10;                            // Crear notificaciones para estudiantes del curso (solo si el creador no es estudiante)&#10;                            try {&#10;                                // obtener estudiantes desde subcolección courses/{courseId}/students&#10;                                val tcid = targetCourseId&#10;                                db.collection(&quot;courses&quot;).document(tcid).collection(&quot;students&quot;).get()&#10;                                    .addOnSuccessListener { studsSnap -&gt;&#10;                                        val studentIds = if (!studsSnap.isEmpty) studsSnap.documents.mapNotNull { it.id } else emptyList()&#10;                                        if (studentIds.isEmpty()) {&#10;                                            // fallback: si no hay subcoleccion, intentar buscar en students collection por courseId&#10;                                            db.collection(&quot;students&quot;).whereEqualTo(&quot;courseId&quot;, tcid).get()&#10;                                                .addOnSuccessListener { altSnap -&gt;&#10;                                                    val altIds = altSnap.documents.mapNotNull { it.id }&#10;                                                    // resolver senderName y crear notifs&#10;                                                    resolveAndCreateNotifs(altIds, title, description, eventId, db, auth)&#10;                                                }&#10;                                        } else {&#10;                                            resolveAndCreateNotifs(studentIds, title, description, eventId, db, auth)&#10;                                        }&#10;                                    }&#10;                            } catch (e: Exception) {&#10;                                Log.w(&quot;CalendarScreen&quot;, &quot;Error creando notificaciones de curso: ${e.message}&quot;)&#10;                            }&#10;                        }&#10;                        .addOnFailureListener { e -&gt;&#10;                            Log.e(&quot;CalendarScreen&quot;, &quot;Error saving global event: ${e.message}&quot;, e)&#10;                            scope.launch { snackbarHostState.showSnackbar(&quot;Error guardando evento&quot;) }&#10;                        }&#10;                } else {&#10;                    // save personal event under users/{uid}/events&#10;                    db.collection(&quot;users&quot;).document(userId).collection(&quot;events&quot;).document(eventId)&#10;                        .set(eventData)&#10;                        .addOnSuccessListener {&#10;                            events.add(CalendarEvent(eventId, title, description, date, type, EventSource.USER, userId))&#10;                            showAddEventDialog = false&#10;                            scope.launch { snackbarHostState.showSnackbar(&quot;Evento agregado&quot;) }&#10;                        }&#10;                        .addOnFailureListener { e -&gt;&#10;                            Log.e(&quot;CalendarScreen&quot;, &quot;Error saving personal event: ${e.message}&quot;, e)&#10;                            scope.launch { snackbarHostState.showSnackbar(&quot;Error guardando evento&quot;) }&#10;                        }&#10;                }&#10;            },&#10;            role = role,&#10;            userCourses = userCourses.toList()&#10;        )&#10;    }&#10;&#10;    // handle actual deletion when confirmed&#10;    if (showDeleteConfirm &amp;&amp; eventToDelete != null) {&#10;        AlertDialog(onDismissRequest = { showDeleteConfirm = false; eventToDelete = null }, title = { Text(&quot;Confirmar eliminación&quot;) }, text = { Text(&quot;Eliminar evento '${eventToDelete!!.title}'?&quot;) }, confirmButton = {&#10;            TextButton(onClick = {&#10;                val uid = auth.currentUser?.uid ?: run { showDeleteConfirm = false; eventToDelete = null; return@TextButton }&#10;                val ev = eventToDelete&#10;                if (ev == null) return@TextButton&#10;                if (ev.source == EventSource.USER) {&#10;                    // delete under owner user's events&#10;                    val owner = ev.ownerId ?: uid&#10;                    db.collection(&quot;users&quot;).document(owner).collection(&quot;events&quot;).document(ev.id)&#10;                        .delete()&#10;                        .addOnSuccessListener {&#10;                            events.removeAll { it.id == ev.id }&#10;                            upcomingEvents.removeAll { it.id == ev.id }&#10;                            showDeleteConfirm = false&#10;                            eventToDelete = null&#10;                        }&#10;                        .addOnFailureListener { ex -&gt;&#10;                            scope.launch { snackbarHostState.showSnackbar(&quot;Error eliminando: ${ex.localizedMessage}&quot;) }&#10;                            showDeleteConfirm = false; eventToDelete = null&#10;                        }&#10;                } else {&#10;                    // global event stored in top-level 'events'&#10;                    db.collection(&quot;events&quot;).document(ev.id)&#10;                        .delete()&#10;                        .addOnSuccessListener {&#10;                            events.removeAll { it.id == ev.id }&#10;                            upcomingEvents.removeAll { it.id == ev.id }&#10;                            showDeleteConfirm = false&#10;                            eventToDelete = null&#10;                        }&#10;                        .addOnFailureListener { ex -&gt;&#10;                            scope.launch { snackbarHostState.showSnackbar(&quot;Error eliminando: ${ex.localizedMessage}&quot;) }&#10;                            showDeleteConfirm = false; eventToDelete = null&#10;                        }&#10;                }&#10;            }) { Text(&quot;Eliminar&quot;) }&#10;        }, dismissButton = { TextButton(onClick = { showDeleteConfirm = false; eventToDelete = null }) { Text(&quot;Cancelar&quot;) } })&#10;    }&#10;&#10;    // Edit dialog&#10;    if (showEditEventDialog &amp;&amp; editingEvent != null) {&#10;        EditEventDialog(event = editingEvent!!, onDismiss = { showEditEventDialog = false; editingEvent = null }, onSave = { updated -&gt;&#10;             val uid = auth.currentUser?.uid ?: return@EditEventDialog&#10;             val map = mapOf(&quot;title&quot; to updated.title, &quot;description&quot; to updated.description, &quot;date&quot; to Timestamp(updated.date), &quot;type&quot; to updated.type.name)&#10;             // update in appropriate collection based on source&#10;             if (updated.source == EventSource.USER) {&#10;                // actualizar en la colección del owner (no asumir uid actual)&#10;                val owner = updated.ownerId ?: uid&#10;                db.collection(&quot;users&quot;).document(owner).collection(&quot;events&quot;).document(updated.id)&#10;                    .update(map)&#10;                    .addOnSuccessListener {&#10;                        fun replace(list: MutableList&lt;CalendarEvent&gt;) {&#10;                            val idx = list.indexOfFirst { it.id == updated.id }&#10;                            if (idx &gt;= 0) list[idx] = updated&#10;                        }&#10;                        replace(events)&#10;                        replace(upcomingEvents)&#10;                        showEditEventDialog = false; editingEvent = null&#10;                    }&#10;                    .addOnFailureListener { ex -&gt; scope.launch { snackbarHostState.showSnackbar(&quot;Error actualizando: ${ex.localizedMessage}&quot;) } }&#10;             } else {&#10;                 // teacher editing global event&#10;                 val mapWithCourse = hashMapOf&lt;String, Any?&gt;()&#10;                 mapWithCourse.putAll(map)&#10;                 if (!updated.ownerId.isNullOrBlank()) mapWithCourse[&quot;courseId&quot;] = updated.ownerId&#10;                 db.collection(&quot;events&quot;).document(updated.id).update(mapWithCourse as Map&lt;String, Any?&gt;)&#10;                      .addOnSuccessListener {&#10;                          fun replace(list: MutableList&lt;CalendarEvent&gt;) {&#10;                              val idx = list.indexOfFirst { it.id == updated.id }&#10;                              if (idx &gt;= 0) list[idx] = updated&#10;                          }&#10;                          replace(events)&#10;                          replace(upcomingEvents)&#10;                          showEditEventDialog = false&#10;                          editingEvent = null&#10;                      }&#10;                      .addOnFailureListener { ex -&gt; scope.launch { snackbarHostState.showSnackbar(&quot;Error actualizando: ${ex.localizedMessage}&quot;) } }&#10;             }&#10;         }, role = role, userCourses = userCourses.toList())&#10;      }&#10;&#10;    // After listeners are set up, if an eventId was provided attempt to locate and select it&#10;    LaunchedEffect(eventId) {&#10;        if (eventId.isNullOrBlank()) return@LaunchedEffect&#10;        // try to find locally first&#10;        val found = events.find { it.id == eventId }&#10;        if (found != null) {&#10;            selectedDay = Calendar.getInstance().apply { time = found.date }&#10;            bottomSheetVisible = true&#10;        } else {&#10;            // try to fetch from top-level events&#10;            try {&#10;                val doc = db.collection(&quot;events&quot;).document(eventId).get().await()&#10;                if (doc.exists()) {&#10;                    val title = doc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                    val description = doc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                    val ts = doc.get(&quot;date&quot;)&#10;                    val d = when (ts) { is Timestamp -&gt; ts.toDate(); is Date -&gt; ts; else -&gt; null }&#10;                    val type = try { EventType.valueOf(doc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                    if (d != null) {&#10;                        selectedDay = Calendar.getInstance().apply { time = d }&#10;                        events.add(CalendarEvent(eventId, title, description, d, type, EventSource.GLOBAL, doc.getString(&quot;courseId&quot;)))&#10;                        bottomSheetVisible = true&#10;                    }&#10;                } else {&#10;                    // try users/{uid}/events&#10;                    val uid = auth.currentUser?.uid&#10;                    if (!uid.isNullOrBlank()) {&#10;                        val ud = db.collection(&quot;users&quot;).document(uid).collection(&quot;events&quot;).document(eventId).get().await()&#10;                        if (ud.exists()) {&#10;                            val title = ud.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                            val description = ud.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                            val ts = ud.get(&quot;date&quot;)&#10;                            val d = when (ts) { is Timestamp -&gt; ts.toDate(); is Date -&gt; ts; else -&gt; null }&#10;                            val type = try { EventType.valueOf(ud.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                            if (d != null) {&#10;                                selectedDay = Calendar.getInstance().apply { time = d }&#10;                                events.add(CalendarEvent(eventId, title, description, d, type, EventSource.USER, uid))&#10;                                bottomSheetVisible = true&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            } catch (_: Exception) { }&#10;        }&#10;    }&#10;}&#10;&#10;// Generador simple de ocurrencias para recurrencia básica&#10;fun generateOccurrences(startDate: Date, recurrence: String, rangeStart: Date, rangeEnd: Date): List&lt;Date&gt; {&#10;     val res = mutableListOf&lt;Date&gt;()&#10;     val cal = Calendar.getInstance().apply { time = startDate }&#10;     val endRangeCal = Calendar.getInstance().apply { time = rangeEnd }&#10;     val startRangeCal = Calendar.getInstance().apply { time = rangeStart }&#10;&#10;     when (recurrence.uppercase(Locale.getDefault())) {&#10;         &quot;DAILY&quot; -&gt; {&#10;             // avanzar hasta &gt;= startRange&#10;             while (cal.before(startRangeCal)) cal.add(Calendar.DAY_OF_MONTH, 1)&#10;             while (!cal.after(endRangeCal)) {&#10;                 res.add(cal.time)&#10;                 cal.add(Calendar.DAY_OF_MONTH, 1)&#10;             }&#10;         }&#10;         &quot;WEEKLY&quot; -&gt; {&#10;             while (cal.before(startRangeCal)) cal.add(Calendar.WEEK_OF_YEAR, 1)&#10;             while (!cal.after(endRangeCal)) {&#10;                 res.add(cal.time)&#10;                 cal.add(Calendar.WEEK_OF_YEAR, 1)&#10;             }&#10;         }&#10;         &quot;MONTHLY&quot; -&gt; {&#10;             while (cal.before(startRangeCal)) cal.add(Calendar.MONTH, 1)&#10;             while (!cal.after(endRangeCal)) {&#10;                 res.add(cal.time)&#10;                 cal.add(Calendar.MONTH, 1)&#10;             }&#10;         }&#10;         else -&gt; { /* no soportado */ }&#10;     }&#10;&#10;     return res&#10; }&#10;&#10;@Composable&#10;private fun CalendarGrid(&#10;    displayedMonth: Calendar,&#10;    selectedDay: Calendar?,&#10;    events: List&lt;CalendarEvent&gt;,&#10;    onDateSelected: (Calendar) -&gt; Unit&#10;) {&#10;    val calendar = (displayedMonth.clone() as Calendar).apply { set(Calendar.DAY_OF_MONTH, 1) }&#10;    // determinar primer día de semana según locale/WeekFields&#10;    val firstDowField = WeekFields.of(Locale.getDefault()).firstDayOfWeek&#10;    val firstDayOfWeek = (firstDowField.value - 1) // DayOfWeek.MONDAY.value==1&#10;    val daysInMonth = calendar.getActualMaximum(Calendar.DAY_OF_MONTH)&#10;&#10;    val today = Calendar.getInstance()&#10;&#10;    LazyVerticalGrid(&#10;        columns = GridCells.Fixed(7),&#10;        modifier = Modifier.height(300.dp)&#10;    ) {&#10;        // Espacios en blanco antes del primer día&#10;        items(firstDayOfWeek) {&#10;            Box(modifier = Modifier.aspectRatio(1f))&#10;        }&#10;&#10;        // Días del mes&#10;        items(daysInMonth) { day -&gt;&#10;            val dayNumber = day + 1&#10;            val thisDay = (calendar.clone() as Calendar).apply { set(Calendar.DAY_OF_MONTH, dayNumber) }&#10;&#10;            // usar LocalDate para evitar problemas de zona/hora&#10;            val thisLocal = Instant.ofEpochMilli(thisDay.time.time).atZone(ZoneId.systemDefault()).toLocalDate()&#10;&#10;            val dayEvents = events.filter { ev -&gt;&#10;                val evLocal = Instant.ofEpochMilli(ev.date.time).atZone(ZoneId.systemDefault()).toLocalDate()&#10;                evLocal == thisLocal&#10;            }&#10;            val hasEvent = dayEvents.isNotEmpty()&#10;&#10;            val isToday = Instant.ofEpochMilli(today.time.time).atZone(ZoneId.systemDefault()).toLocalDate() == thisLocal&#10;&#10;            val isSelected = selectedDay?.let { sel -&gt;&#10;                val selLocal = Instant.ofEpochMilli(sel.time.time).atZone(ZoneId.systemDefault()).toLocalDate()&#10;                selLocal == thisLocal&#10;            } ?: false&#10;&#10;            Box(&#10;                modifier = Modifier&#10;                    .aspectRatio(1f)&#10;                    .padding(2.dp)&#10;                    .clip(CircleShape)&#10;                    .background(&#10;                        color = when {&#10;                            isSelected -&gt; MaterialTheme.colorScheme.primary.copy(alpha = 0.25f)&#10;                            isToday -&gt; MaterialTheme.colorScheme.primaryContainer&#10;                            hasEvent -&gt; MaterialTheme.colorScheme.secondaryContainer.copy(alpha = 0.5f)&#10;                            else -&gt; Color.Transparent&#10;                        }&#10;                    )&#10;                    .clickable { onDateSelected(thisDay) },&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Column(&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    Text(&#10;                        text = dayNumber.toString(),&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        fontWeight = if (isToday || isSelected) FontWeight.Bold else FontWeight.Normal,&#10;                        color = if (isToday || isSelected) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.onSurface&#10;                    )&#10;                    if (hasEvent) {&#10;                        // mostrar hasta 3 puntos de colores según tipos distintos&#10;                        val types = dayEvents.map { it.type }.distinct()&#10;                        val maxDots = 3&#10;                        Row(horizontalArrangement = Arrangement.Center, verticalAlignment = Alignment.CenterVertically) {&#10;                            types.take(maxDots).forEach { t -&gt;&#10;                                val dotColor = when (t) {&#10;                                    EventType.CLASE -&gt; Color(0xFF2196F3)&#10;                                    EventType.EXAMEN -&gt; Color(0xFFF44336)&#10;                                    EventType.TAREA -&gt; Color(0xFFFFC107)&#10;                                    EventType.EVENTO -&gt; Color(0xFF4CAF50)&#10;                                }&#10;                                Box(modifier = Modifier.size(6.dp).background(dotColor, CircleShape))&#10;                                Spacer(Modifier.width(4.dp))&#10;                            }&#10;                            if (types.size &gt; maxDots) {&#10;                                Text(&quot;+${types.size - maxDots}&quot;, style = MaterialTheme.typography.bodySmall)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun EventCard(event: CalendarEvent, onEdit: ((CalendarEvent) -&gt; Unit)? = null, onDelete: ((CalendarEvent) -&gt; Unit)? = null) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Icon(&#10;                imageVector = when (event.type) {&#10;                    EventType.CLASE -&gt; Icons.Filled.School&#10;                    EventType.EXAMEN -&gt; Icons.Filled.Warning&#10;                    EventType.TAREA -&gt; Icons.AutoMirrored.Filled.Assignment&#10;                    EventType.EVENTO -&gt; Icons.AutoMirrored.Filled.EventNote&#10;                },&#10;                contentDescription = null,&#10;                tint = when (event.type) {&#10;                    EventType.CLASE -&gt; Color(0xFF2196F3)&#10;                    EventType.EXAMEN -&gt; Color(0xFFF44336)&#10;                    EventType.TAREA -&gt; Color(0xFFFFC107)&#10;                    EventType.EVENTO -&gt; Color(0xFF4CAF50)&#10;                }&#10;            )&#10;            Spacer(Modifier.width(12.dp))&#10;            Column(modifier = Modifier.weight(1f)) {&#10;                Text(event.title, style = MaterialTheme.typography.titleSmall, fontWeight = FontWeight.SemiBold)&#10;                Text(SimpleDateFormat(&quot;dd/MM/yyyy HH:mm&quot;, Locale.getDefault()).format(event.date), style = MaterialTheme.typography.bodySmall, color = MaterialTheme.colorScheme.onSurfaceVariant)&#10;                if (event.description.isNotBlank()) Text(event.description, style = MaterialTheme.typography.bodyMedium)&#10;            }&#10;            // acciones opcionales&#10;            if (onEdit != null) IconButton(onClick = { onEdit(event) }) { Icon(Icons.Filled.Edit, contentDescription = &quot;Editar&quot;) }&#10;            if (onDelete != null) IconButton(onClick = { onDelete(event) }) { Icon(Icons.Filled.Delete, contentDescription = &quot;Eliminar&quot;) }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun AddEventDialog(&#10;     initialDate: Date,&#10;     onDismiss: () -&gt; Unit,&#10;     onSave: (String, String, Date, EventType, String?) -&gt; Unit,&#10;     role: Role?,&#10;     userCourses: List&lt;Pair&lt;String,String&gt;&gt; = emptyList()&#10; ) {&#10;    val context = LocalContext.current&#10;    var title by remember { mutableStateOf(&quot;&quot;) }&#10;    var description by remember { mutableStateOf(&quot;&quot;) }&#10;    // fecha y hora seleccionadas separadas&#10;    var dateCal by remember { mutableStateOf(Calendar.getInstance().apply { time = initialDate }) }&#10;    var type by remember { mutableStateOf(EventType.EVENTO) }&#10;    var targetCourseId by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;    // funciones auxiliares para abrir pickers nativos&#10;    fun openDatePicker() {&#10;        val c = dateCal&#10;        android.app.DatePickerDialog(context, { _, y, m, d -&gt;&#10;            c.set(Calendar.YEAR, y)&#10;            c.set(Calendar.MONTH, m)&#10;            c.set(Calendar.DAY_OF_MONTH, d)&#10;            dateCal = c&#10;        }, c.get(Calendar.YEAR), c.get(Calendar.MONTH), c.get(Calendar.DAY_OF_MONTH)).show()&#10;    }&#10;&#10;    fun openTimePicker() {&#10;        val c = dateCal&#10;        android.app.TimePickerDialog(context, { _, hour, minute -&gt;&#10;            c.set(Calendar.HOUR_OF_DAY, hour)&#10;            c.set(Calendar.MINUTE, minute)&#10;            c.set(Calendar.SECOND, 0)&#10;            dateCal = c&#10;        }, c.get(Calendar.HOUR_OF_DAY), c.get(Calendar.MINUTE), true).show()&#10;    }&#10;&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = { Text(&quot;Agregar Evento&quot;) },&#10;        text = {&#10;            Column {&#10;                OutlinedTextField(value = title, onValueChange = { title = it }, label = { Text(&quot;Título&quot;) }, singleLine = true)&#10;                Spacer(Modifier.height(8.dp))&#10;                OutlinedTextField(value = description, onValueChange = { description = it }, label = { Text(&quot;Descripción&quot;) })&#10;                Spacer(Modifier.height(8.dp))&#10;                Row(verticalAlignment = Alignment.CenterVertically) {&#10;                    Text(&quot;Fecha: ${SimpleDateFormat(&quot;dd/MM/yyyy&quot;, Locale.getDefault()).format(dateCal.time)}&quot;)&#10;                    Spacer(Modifier.width(8.dp))&#10;                    TextButton(onClick = { openDatePicker() }) { Text(&quot;Seleccionar fecha&quot;) }&#10;                }&#10;                Spacer(Modifier.height(8.dp))&#10;                Row(verticalAlignment = Alignment.CenterVertically) {&#10;                    Text(&quot;Hora: ${String.format(Locale.getDefault(), &quot;%02d:%02d&quot;, dateCal.get(Calendar.HOUR_OF_DAY), dateCal.get(Calendar.MINUTE))}&quot;)&#10;                    Spacer(Modifier.width(8.dp))&#10;                    TextButton(onClick = { openTimePicker() }) { Text(&quot;Seleccionar hora&quot;) }&#10;                }&#10;                Spacer(Modifier.height(8.dp))&#10;                Column(modifier = Modifier.fillMaxWidth()) {&#10;                    EventType.entries.forEach { ev -&gt;&#10;                        Row(&#10;                            verticalAlignment = Alignment.CenterVertically,&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(vertical = 4.dp)&#10;                        ) {&#10;                            RadioButton(selected = type == ev, onClick = { type = ev })&#10;                            Spacer(Modifier.width(8.dp))&#10;                            Text(ev.name, modifier = Modifier.weight(1f))&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // target course selection for teachers&#10;                if (role == Role.DOCENTE) {&#10;                    Spacer(Modifier.height(8.dp))&#10;                    Text(&quot;Curso objetivo (opcional):&quot;, style = MaterialTheme.typography.labelMedium)&#10;                    // mostrar cursos disponibles para el docente&#10;                    LazyColumn(&#10;                        modifier = Modifier.heightIn(max = 200.dp),&#10;                        verticalArrangement = Arrangement.spacedBy(4.dp)&#10;                    ) {&#10;                        items(userCourses) { course -&gt;&#10;                            val isSelected = targetCourseId == course.first&#10;                            Row(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .clickable { targetCourseId = if (isSelected) null else course.first }&#10;                                    .padding(8.dp)&#10;                                    .background(&#10;                                        color = if (isSelected) MaterialTheme.colorScheme.primary.copy(alpha = 0.2f) else Color.Transparent,&#10;                                        shape = CircleShape&#10;                                    ),&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                Text(course.second, modifier = Modifier.weight(1f))&#10;                                if (isSelected) {&#10;                                    Icon(Icons.Filled.Check, contentDescription = &quot;Seleccionado&quot;, tint = MaterialTheme.colorScheme.primary)&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        },&#10;        confirmButton = {&#10;            TextButton(onClick = {&#10;                if (title.isBlank()) return@TextButton&#10;                onSave(title, description, dateCal.time, type, targetCourseId)&#10;            }) { Text(&quot;Guardar&quot;) }&#10;        },&#10;        dismissButton = {&#10;            TextButton(onClick = onDismiss) { Text(&quot;Cerrar&quot;) }&#10;        }&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun EditEventDialog(event: CalendarEvent, onDismiss: () -&gt; Unit, onSave: (CalendarEvent) -&gt; Unit, role: Role?, userCourses: List&lt;Pair&lt;String,String&gt;&gt; = emptyList()) {&#10;    val context = LocalContext.current&#10;    var title by remember { mutableStateOf(event.title) }&#10;    var description by remember { mutableStateOf(event.description) }&#10;    var dateCal by remember { mutableStateOf(Calendar.getInstance().apply { time = event.date }) }&#10;    var type by remember { mutableStateOf(event.type) }&#10;    var targetCourseId by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;    // cargar id de curso objetivo si es evento global&#10;    LaunchedEffect(event) {&#10;        targetCourseId = if (event.source == EventSource.GLOBAL) event.ownerId else null&#10;    }&#10;&#10;    fun openDatePicker() {&#10;        val c = dateCal&#10;        android.app.DatePickerDialog(context, { _, y, m, d -&gt; c.set(y, m, d); dateCal = c }, c.get(Calendar.YEAR), c.get(Calendar.MONTH), c.get(Calendar.DAY_OF_MONTH)).show()&#10;    }&#10;    fun openTimePicker() {&#10;        val c = dateCal&#10;        android.app.TimePickerDialog(context, { _, h, min -&gt; c.set(Calendar.HOUR_OF_DAY, h); c.set(Calendar.MINUTE, min); dateCal = c }, c.get(Calendar.HOUR_OF_DAY), c.get(Calendar.MINUTE), true).show()&#10;    }&#10;&#10;    AlertDialog(onDismissRequest = onDismiss, title = { Text(&quot;Editar Evento&quot;) }, text = {&#10;        Column {&#10;            OutlinedTextField(value = title, onValueChange = { title = it }, label = { Text(&quot;Título&quot;) }, singleLine = true)&#10;            Spacer(Modifier.height(8.dp))&#10;            OutlinedTextField(value = description, onValueChange = { description = it }, label = { Text(&quot;Descripción&quot;) })&#10;            Spacer(Modifier.height(8.dp))&#10;            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                Text(&quot;Fecha: ${SimpleDateFormat(&quot;dd/MM/yyyy&quot;, Locale.getDefault()).format(dateCal.time)}&quot;)&#10;                Spacer(Modifier.width(8.dp))&#10;                TextButton(onClick = { openDatePicker() }) { Text(&quot;Seleccionar fecha&quot;) }&#10;            }&#10;            Spacer(Modifier.height(8.dp))&#10;            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                Text(&quot;Hora: ${String.format(Locale.getDefault(), &quot;%02d:%02d&quot;, dateCal.get(Calendar.HOUR_OF_DAY), dateCal.get(Calendar.MINUTE))}&quot;)&#10;                Spacer(Modifier.width(8.dp))&#10;                TextButton(onClick = { openTimePicker() }) { Text(&quot;Seleccionar hora&quot;) }&#10;            }&#10;            Spacer(Modifier.height(8.dp))&#10;            Column(modifier = Modifier.fillMaxWidth()) {&#10;                EventType.entries.forEach { ev -&gt;&#10;                    Row(&#10;                        verticalAlignment = Alignment.CenterVertically,&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(vertical = 4.dp)&#10;                    ) {&#10;                        RadioButton(selected = type == ev, onClick = { type = ev })&#10;                        Spacer(Modifier.width(8.dp))&#10;                        Text(ev.name, modifier = Modifier.weight(1f))&#10;                    }&#10;                }&#10;            }&#10;&#10;            // target course selection for teachers&#10;            if (role == Role.DOCENTE) {&#10;                Spacer(Modifier.height(8.dp))&#10;                Text(&quot;Curso objetivo (opcional):&quot;, style = MaterialTheme.typography.labelMedium)&#10;                // mostrar cursos disponibles para el docente&#10;                LazyColumn(&#10;                    modifier = Modifier.heightIn(max = 200.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(4.dp)&#10;                ) {&#10;                    items(userCourses) { course -&gt;&#10;                        val isSelected = targetCourseId == course.first&#10;                        Row(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .clickable { targetCourseId = if (isSelected) null else course.first }&#10;                                .padding(8.dp)&#10;                                .background(&#10;                                    color = if (isSelected) MaterialTheme.colorScheme.primary.copy(alpha = 0.2f) else Color.Transparent,&#10;                                    shape = CircleShape&#10;                                ),&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            Text(course.second, modifier = Modifier.weight(1f))&#10;                            if (isSelected) {&#10;                                Icon(Icons.Filled.Check, contentDescription = &quot;Seleccionado&quot;, tint = MaterialTheme.colorScheme.primary)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }, confirmButton = {&#10;        TextButton(onClick = { onSave(CalendarEvent(event.id, title, description, dateCal.time, type, event.source, targetCourseId)) }) { Text(&quot;Guardar&quot;) }&#10;    }, dismissButton = { TextButton(onClick = onDismiss) { Text(&quot;Cerrar&quot;) } })&#10;}&#10;&#10;// helper to load upcoming events paginated&#10;private fun loadMoreUpcoming(db: FirebaseFirestore, auth: FirebaseAuth, dest: MutableList&lt;CalendarEvent&gt;, courseIds: List&lt;String&gt; = emptyList(), lastSnapshot: DocumentSnapshot? = null, cbLast: (DocumentSnapshot?) -&gt; Unit) {&#10;    val uid = auth.currentUser?.uid ?: return&#10;    val col = db.collection(&quot;users&quot;).document(uid).collection(&quot;events&quot;)&#10;    val PAGE_SIZE = 25&#10;    try {&#10;        var q = col.whereGreaterThanOrEqualTo(&quot;date&quot;, Timestamp.now()).orderBy(&quot;date&quot;)&#10;        if (lastSnapshot != null) q = q.startAfter(lastSnapshot)&#10;        q = q.limit(PAGE_SIZE.toLong())&#10;        q.get().addOnSuccessListener { snap -&gt;&#10;            val docs = snap.documents&#10;            for (doc in docs) {&#10;                val id = doc.id&#10;                val title = doc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                val description = doc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                val ts = doc.get(&quot;date&quot;)&#10;                val d = when (ts) {&#10;                    is Timestamp -&gt; ts.toDate()&#10;                    is Date -&gt; ts&#10;                    else -&gt; null&#10;                }&#10;                val type = try { EventType.valueOf(doc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                val owner = doc.getString(&quot;ownerId&quot;)&#10;                if (d != null) dest.add(CalendarEvent(id, title, description, d, type, EventSource.USER, owner))&#10;            }&#10;            cbLast(docs.lastOrNull())&#10;             // additionally fetch upcoming global events for user's courses (no strict pagination)&#10;             if (courseIds.isNotEmpty()) {&#10;                 courseIds.chunked(10).forEach { chunk -&gt;&#10;                     db.collection(&quot;events&quot;).whereIn(&quot;courseId&quot;, chunk).whereGreaterThanOrEqualTo(&quot;date&quot;, Timestamp.now()).orderBy(&quot;date&quot;).limit(PAGE_SIZE.toLong()).get().addOnSuccessListener { gsnap -&gt;&#10;                         for (gdoc in gsnap.documents) {&#10;                             val id = gdoc.id&#10;                             if (dest.any { it.id == id }) continue&#10;                             val title = gdoc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                             val description = gdoc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                             val ts = gdoc.get(&quot;date&quot;)&#10;                             val d = when (ts) { is Timestamp -&gt; ts.toDate(); is Date -&gt; ts; else -&gt; null }&#10;                             val type = try { EventType.valueOf(gdoc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                             val courseId = gdoc.getString(&quot;courseId&quot;)&#10;                             if (d != null) dest.add(CalendarEvent(id, title, description, d, type, EventSource.GLOBAL, courseId))&#10;                         }&#10;                     }&#10;                 }&#10;             }&#10;         }&#10;     } catch (_: Exception) {&#10;         // ignore&#10;         cbLast(null)&#10;     }&#10; }&#10;&#10;// helper: crea notificaciones en users/{id}/notifications&#10;fun createNotifsForIds(ids: List&lt;String&gt;, title: String, body: String, relatedId: String, db: FirebaseFirestore, auth: FirebaseAuth) {&#10;     if (ids.isEmpty()) return&#10;    // fallback sender used if name lookup fails&#10;    val fallbackSender = auth.currentUser?.email ?: auth.currentUser?.uid ?: &quot;Profesor&quot;&#10;    for (sid in ids) {&#10;        try {&#10;            val notif = hashMapOf(&#10;                &quot;titulo&quot; to title,&#10;                &quot;cuerpo&quot; to body.take(200),&#10;                &quot;remitente&quot; to fallbackSender,&#10;                &quot;senderName&quot; to fallbackSender,&#10;                &quot;fechaHora&quot; to Timestamp.now(),&#10;                &quot;leida&quot; to false,&#10;                &quot;relatedId&quot; to relatedId,&#10;                &quot;type&quot; to &quot;event&quot;&#10;            )&#10;            db.collection(&quot;users&quot;).document(sid).collection(&quot;notifications&quot;).add(notif)&#10;        } catch (_: Exception) { }&#10;    }&#10;}&#10;&#10;// Resolve current user's display name then call createNotifsForIds with senderName set&#10;fun resolveAndCreateNotifs(ids: List&lt;String&gt;, title: String, body: String, relatedId: String, db: FirebaseFirestore, auth: FirebaseAuth) {&#10;    val uid = auth.currentUser?.uid&#10;    if (uid == null) {&#10;        createNotifsForIds(ids, title, body, relatedId, db, auth)&#10;        return&#10;    }&#10;    try {&#10;        db.collection(&quot;users&quot;).document(uid).get().addOnSuccessListener { doc -&gt;&#10;            val name = doc.getString(&quot;name&quot;) ?: doc.getString(&quot;displayName&quot;) ?: auth.currentUser?.email ?: uid&#10;            // create notifications with senderName field&#10;            for (sid in ids) {&#10;                try {&#10;                    val notif = hashMapOf(&#10;                        &quot;titulo&quot; to title,&#10;                        &quot;cuerpo&quot; to body.take(200),&#10;                        &quot;remitente&quot; to uid,&#10;                        &quot;senderName&quot; to name,&#10;                        &quot;fechaHora&quot; to Timestamp.now(),&#10;                        &quot;leida&quot; to false,&#10;                        &quot;relatedId&quot; to relatedId,&#10;                        &quot;type&quot; to &quot;event&quot;&#10;                    )&#10;                    db.collection(&quot;users&quot;).document(sid).collection(&quot;notifications&quot;).add(notif)&#10;                } catch (_: Exception) {}&#10;            }&#10;        }.addOnFailureListener {&#10;            createNotifsForIds(ids, title, body, relatedId, db, auth)&#10;        }&#10;    } catch (_: Exception) {&#10;        createNotifsForIds(ids, title, body, relatedId, db, auth)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.appcolegios.academico&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.gestures.detectHorizontalDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.grid.GridCells&#10;import androidx.compose.foundation.lazy.grid.LazyVerticalGrid&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import kotlinx.coroutines.launch&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.appcolegios.perfil.ProfileViewModel&#10;import com.example.appcolegios.data.UserPreferencesRepository&#10;import com.example.appcolegios.data.UserData&#10;import com.example.appcolegios.data.model.Role&#10;import androidx.compose.ui.platform.LocalContext&#10;import android.util.Log&#10;import com.google.firebase.Timestamp&#10;import com.google.firebase.firestore.ListenerRegistration&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.animation.AnimatedContent&#10;import androidx.compose.animation.ExperimentalAnimationApi&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.animation.slideInHorizontally&#10;import androidx.compose.animation.slideOutHorizontally&#10;import androidx.compose.animation.togetherWith&#10;import androidx.compose.material.icons.automirrored.filled.Assignment&#10;import androidx.compose.material.icons.automirrored.filled.EventNote&#10;import androidx.compose.runtime.key&#10;import java.time.Instant&#10;import java.time.LocalDate&#10;import java.time.ZoneId&#10;import java.time.temporal.WeekFields&#10;import com.google.firebase.firestore.DocumentSnapshot&#10;import java.util.Locale&#10; import kotlinx.coroutines.tasks.await&#10;&#10;enum class EventSource { USER, GLOBAL }&#10;&#10;data class CalendarEvent(&#10;    val id: String,&#10;    val title: String,&#10;    val description: String,&#10;    val date: Date,&#10;    val type: EventType,&#10;    val source: EventSource = EventSource.USER,&#10;    val ownerId: String? = null // for USER -&gt; userId; for GLOBAL -&gt; courseId or owner&#10;)&#10;&#10;enum class EventType {&#10;    CLASE, EXAMEN, TAREA, EVENTO&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class, ExperimentalAnimationApi::class)&#10;@Composable&#10;fun CalendarScreen(eventId: String? = null) {&#10;    // Separamos mes mostrado y fecha seleccionada&#10;    var displayedMonth by remember { mutableStateOf(Calendar.getInstance()) }&#10;    var selectedDay by remember { mutableStateOf&lt;Calendar?&gt;(Calendar.getInstance()) }&#10;    var showAddEventDialog by remember { mutableStateOf(false) }&#10;    val context = LocalContext.current&#10;&#10;    // Eventos para el mes mostrado (se cargan por rango mediante snapshot listener)&#10;    val events = remember { mutableStateListOf&lt;CalendarEvent&gt;() }&#10;    val auth = FirebaseAuth.getInstance()&#10;    val db = FirebaseFirestore.getInstance()&#10;    // user role and preferences&#10;    val userPrefs = remember { UserPreferencesRepository(context) }&#10;    val userData by userPrefs.userData.collectAsState(initial = UserData(null, null, null))&#10;    val role = userData.roleEnum&#10;    // courses for teacher/student/child selection&#10;    val userCourses = remember { mutableStateListOf&lt;Pair&lt;String,String&gt;&gt;() }&#10;    // Próximos eventos paginados y filtro por tipo&#10;    val upcomingEvents = remember { mutableStateListOf&lt;CalendarEvent&gt;() }&#10;    var upcomingLastSnapshot by remember { mutableStateOf&lt;DocumentSnapshot?&gt;(null) }&#10;    var selectedFilterType by remember { mutableStateOf&lt;EventType?&gt;(null) }&#10;&#10;    // Estado del bottom sheet para mostrar eventos del día seleccionado&#10;    var bottomSheetVisible by remember { mutableStateOf(false) }&#10;&#10;    // Estados para edición / borrado (deben existir para las acciones de la lista y bottom sheet)&#10;    var editingEvent by remember { mutableStateOf&lt;CalendarEvent?&gt;(null) }&#10;    var showEditEventDialog by remember { mutableStateOf(false) }&#10;    var eventToDelete by remember { mutableStateOf&lt;CalendarEvent?&gt;(null) }&#10;    var showDeleteConfirm by remember { mutableStateOf(false) }&#10;&#10;    // Profile VM: para padres (lista de hijos)&#10;    val profileVm: ProfileViewModel = viewModel()&#10;    val children: List&lt;com.example.appcolegios.data.model.Student&gt; by profileVm.children.collectAsState()&#10;    var selectedChildIndex by remember { mutableStateOf(0) }&#10;&#10;    // Listener registration manejado con DisposableEffect: soporta múltiples listeners según rol&#10;    DisposableEffect(displayedMonth.timeInMillis, auth.currentUser?.uid, role, selectedChildIndex) {&#10;        val userId = auth.currentUser?.uid&#10;        val regs = mutableListOf&lt;ListenerRegistration&gt;()&#10;        events.clear()&#10;&#10;        if (userId != null) {&#10;            // calcular primer y ultimo día del mes mostrado&#10;            val start = (displayedMonth.clone() as Calendar).apply {&#10;                set(Calendar.DAY_OF_MONTH, 1)&#10;                set(Calendar.HOUR_OF_DAY, 0)&#10;                set(Calendar.MINUTE, 0)&#10;                set(Calendar.SECOND, 0)&#10;                set(Calendar.MILLISECOND, 0)&#10;            }&#10;            val end = (displayedMonth.clone() as Calendar).apply {&#10;                set(Calendar.DAY_OF_MONTH, getActualMaximum(Calendar.DAY_OF_MONTH))&#10;                set(Calendar.HOUR_OF_DAY, 23)&#10;                set(Calendar.MINUTE, 59)&#10;                set(Calendar.SECOND, 59)&#10;                set(Calendar.MILLISECOND, 999)&#10;            }&#10;            val startTs = Timestamp(start.time)&#10;            val endTs = Timestamp(end.time)&#10;&#10;            try {&#10;                // 1) listener to personal events of the viewed user (teacher sees own personal too)&#10;                val personalListener = db.collection(&quot;users&quot;).document(userId).collection(&quot;events&quot;)&#10;                    .whereGreaterThanOrEqualTo(&quot;date&quot;, startTs)&#10;                    .whereLessThanOrEqualTo(&quot;date&quot;, endTs)&#10;                    .addSnapshotListener { snap, e -&gt;&#10;                        if (e != null) { Log.e(&quot;CalendarScreen&quot;, &quot;Personal listener error: ${e.message}&quot;); return@addSnapshotListener }&#10;                        if (snap != null) {&#10;                            for (doc in snap.documents) {&#10;                                val id = doc.id&#10;                                val title = doc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                                val description = doc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                                val ts = doc.get(&quot;date&quot;)&#10;                                val d = when (ts) { is Timestamp -&gt; ts.toDate(); is Date -&gt; ts; else -&gt; null }&#10;                                val type = try { EventType.valueOf(doc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                                if (d != null &amp;&amp; events.none { it.id == id }) events.add(CalendarEvent(id, title, description, d, type, EventSource.USER, userId))&#10;                                val rec = doc.getString(&quot;recurrence&quot;)&#10;                                if (!rec.isNullOrBlank() &amp;&amp; d != null) {&#10;                                    try { val occ = generateOccurrences(d, rec, start.time, end.time); occ.forEachIndexed { idx, occDate -&gt; if (events.none { it.id == &quot;${id}_occ_$idx&quot; }) events.add(CalendarEvent(&quot;${id}_occ_$idx&quot;, title, description, occDate, type, EventSource.USER, userId)) } } catch (_: Exception) {}&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                regs.add(personalListener)&#10;&#10;                // 2) role-specific: teacher -&gt; events for their courses; student -&gt; events for courses enrolled; parent -&gt; events for selected child&#10;                when (role) {&#10;                    Role.DOCENTE -&gt; {&#10;                        // get course ids taught by teacher&#10;                        val courseIds = mutableListOf&lt;String&gt;()&#10;                        try {&#10;                            val q = db.collection(&quot;courses&quot;).whereEqualTo(&quot;teacherId&quot;, userId).get()&#10;                            q.addOnSuccessListener { snap -&gt;&#10;                                userCourses.clear()&#10;                                for (doc in snap.documents) {&#10;                                    val cid = doc.id&#10;                                    courseIds.add(cid)&#10;                                    val cname = doc.getString(&quot;name&quot;) ?: doc.getString(&quot;title&quot;) ?: cid&#10;                                    userCourses.add(Pair(cid, cname))&#10;                                }&#10;                                // query top-level events where courseId in courseIds, chunked by 10&#10;                                if (courseIds.isNotEmpty()) {&#10;                                    courseIds.chunked(10).forEach { chunk -&gt;&#10;                                        val evQuery = db.collection(&quot;events&quot;).whereIn(&quot;courseId&quot;, chunk).whereGreaterThanOrEqualTo(&quot;date&quot;, startTs).whereLessThanOrEqualTo(&quot;date&quot;, endTs)&#10;                                        val r = evQuery.addSnapshotListener { snap2, e2 -&gt;&#10;                                            if (e2 != null) { Log.e(&quot;CalendarScreen&quot;,&quot;Course events listener err: ${e2.message}&quot;); return@addSnapshotListener }&#10;                                            if (snap2 != null) {&#10;                                                for (doc in snap2.documents) {&#10;                                                    val id = doc.id&#10;                                                    val title = doc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                                                    val description = doc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                                                    val ts = doc.get(&quot;date&quot;)&#10;                                                    val d = when (ts) { is Timestamp -&gt; ts.toDate(); is Date -&gt; ts; else -&gt; null }&#10;                                                    val type = try { EventType.valueOf(doc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                                                    if (d != null &amp;&amp; events.none { it.id == id }) events.add(CalendarEvent(id, title, description, d, type, EventSource.GLOBAL, null))&#10;                                                }&#10;                                            }&#10;                                        }&#10;                                        regs.add(r)&#10;                                    }&#10;                                }&#10;                            }&#10;                        } catch (_: Exception) { }&#10;                    }&#10;                    Role.ESTUDIANTE -&gt; {&#10;                        // student: read student doc for courses&#10;                        try {&#10;                            val sdocTask = db.collection(&quot;students&quot;).document(userId).get()&#10;                            sdocTask.addOnSuccessListener { sdoc -&gt;&#10;                                val courseIds = (sdoc.get(&quot;courses&quot;) as? List&lt;*&gt;)?.mapNotNull { it?.toString() } ?: emptyList()&#10;                                // populate userCourses with names&#10;                                userCourses.clear()&#10;                                for (cid in courseIds) {&#10;                                    db.collection(&quot;courses&quot;).document(cid).get().addOnSuccessListener { cdoc -&gt;&#10;                                        if (cdoc.exists()) userCourses.add(Pair(cid, cdoc.getString(&quot;name&quot;) ?: cid))&#10;                                    }&#10;                                }&#10;                                if (courseIds.isNotEmpty()) {&#10;                                    courseIds.chunked(10).forEach { chunk -&gt;&#10;                                        val evQuery = db.collection(&quot;events&quot;).whereIn(&quot;courseId&quot;, chunk).whereGreaterThanOrEqualTo(&quot;date&quot;, startTs).whereLessThanOrEqualTo(&quot;date&quot;, endTs)&#10;                                        val r = evQuery.addSnapshotListener { snap2, e2 -&gt;&#10;                                            if (e2 != null) return@addSnapshotListener&#10;                                            if (snap2 != null) {&#10;                                                for (doc in snap2.documents) {&#10;                                                    val id = doc.id&#10;                                                    val title = doc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                                                    val description = doc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                                                    val ts = doc.get(&quot;date&quot;)&#10;                                                    val d = when (ts) { is Timestamp -&gt; ts.toDate(); is Date -&gt; ts; else -&gt; null }&#10;                                                    val type = try { EventType.valueOf(doc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                                                    if (d != null &amp;&amp; events.none { it.id == id }) events.add(CalendarEvent(id, title, description, d, type, EventSource.GLOBAL, null))&#10;                                                }&#10;                                            }&#10;                                        }&#10;                                        regs.add(r)&#10;                                    }&#10;                                }&#10;                            }&#10;                        } catch (_: Exception) { }&#10;                    }&#10;                    Role.PADRE -&gt; {&#10;                        // parent: use selected child&#10;                        val childId = children.getOrNull(selectedChildIndex)?.id&#10;                        if (!childId.isNullOrBlank()) {&#10;                            // personal events of child&#10;                            val childListener = db.collection(&quot;users&quot;).document(childId).collection(&quot;events&quot;)&#10;                                .whereGreaterThanOrEqualTo(&quot;date&quot;, startTs)&#10;                                .whereLessThanOrEqualTo(&quot;date&quot;, endTs)&#10;                                .addSnapshotListener { snap, e -&gt;&#10;                                    if (e != null) { Log.e(&quot;CalendarScreen&quot;, &quot;Child listener error: ${e.message}&quot;); return@addSnapshotListener }&#10;                                    if (snap != null) {&#10;                                        for (doc in snap.documents) {&#10;                                            val id = doc.id&#10;                                            val title = doc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                                            val description = doc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                                            val ts = doc.get(&quot;date&quot;)&#10;                                            val d = when (ts) { is Timestamp -&gt; ts.toDate(); is Date -&gt; ts; else -&gt; null }&#10;                                            val type = try { EventType.valueOf(doc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                                            if (d != null &amp;&amp; events.none { it.id == id }) events.add(CalendarEvent(id, title, description, d, type, EventSource.USER, childId))&#10;                                        }&#10;                                    }&#10;                                }&#10;                            regs.add(childListener)&#10;&#10;                            // also load course events for that child (like student)&#10;                            try {&#10;                                val sdocTask = db.collection(&quot;students&quot;).document(childId).get()&#10;                                sdocTask.addOnSuccessListener { sdoc -&gt;&#10;                                    val courseIds = (sdoc.get(&quot;courses&quot;) as? List&lt;*&gt;)?.mapNotNull { it?.toString() } ?: emptyList()&#10;                                    if (courseIds.isNotEmpty()) {&#10;                                        courseIds.chunked(10).forEach { chunk -&gt;&#10;                                            val evQuery = db.collection(&quot;events&quot;).whereIn(&quot;courseId&quot;, chunk).whereGreaterThanOrEqualTo(&quot;date&quot;, startTs).whereLessThanOrEqualTo(&quot;date&quot;, endTs)&#10;                                            val r = evQuery.addSnapshotListener { snap2, e2 -&gt;&#10;                                                if (e2 != null) { Log.e(&quot;CalendarScreen&quot;, &quot;Child course events listener err: ${e2.message}&quot;); return@addSnapshotListener }&#10;                                                if (snap2 != null) {&#10;                                                    for (doc in snap2.documents) {&#10;                                                        val id = doc.id&#10;                                                        val title = doc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                                                        val description = doc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                                                        val ts = doc.get(&quot;date&quot;)&#10;                                                        val d = when (ts) { is Timestamp -&gt; ts.toDate(); is Date -&gt; ts; else -&gt; null }&#10;                                                        val type = try { EventType.valueOf(doc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                                                        if (d != null &amp;&amp; events.none { it.id == id }) events.add(CalendarEvent(id, title, description, d, type, EventSource.GLOBAL, doc.getString(&quot;courseId&quot;)))&#10;                                                    }&#10;                                                }&#10;                                            }&#10;                                            regs.add(r)&#10;                                        }&#10;                                    }&#10;                                }&#10;                            } catch (_: Exception) {}&#10;                        }&#10;                    }&#10;                    else -&gt; {&#10;                        // default: no extra listeners&#10;                    }&#10;                }&#10;            } catch (ex: Exception) {&#10;                Log.e(&quot;CalendarScreen&quot;, &quot;Error starting listeners: ${ex.message}&quot;, ex)&#10;            }&#10;        }&#10;&#10;        onDispose {&#10;            regs.forEach { try { it.remove() } catch (_: Exception) {} }&#10;        }&#10;    }&#10;&#10;    // Snackbar / scaffold&#10;    val snackbarHostState = remember { SnackbarHostState() }&#10;    val scope = rememberCoroutineScope()&#10;&#10;    Scaffold(&#10;        snackbarHost = { SnackbarHost(hostState = snackbarHostState) }&#10;    ) { innerPadding -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(innerPadding)&#10;                .padding(16.dp)&#10;        ) {&#10;            // Header con mes actual&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                IconButton(onClick = {&#10;                    displayedMonth = (displayedMonth.clone() as Calendar).apply { add(Calendar.MONTH, -1) }&#10;                }) {&#10;                    Icon(Icons.Filled.ChevronLeft, contentDescription = &quot;Mes anterior&quot;)&#10;                }&#10;&#10;                Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                    Text(&#10;                        text = SimpleDateFormat(&quot;MMMM yyyy&quot;, Locale.getDefault()).format(displayedMonth.time),&#10;                        style = MaterialTheme.typography.titleLarge,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;                    TextButton(onClick = { // volver a hoy&#10;                        displayedMonth = Calendar.getInstance()&#10;                        selectedDay = Calendar.getInstance()&#10;                    }) { Text(&quot;Hoy&quot;) }&#10;&#10;                    // selector de hijo para PADRE&#10;                    if (role == Role.PADRE) {&#10;                        Spacer(Modifier.height(8.dp))&#10;                        Row(verticalAlignment = Alignment.CenterVertically) {&#10;                            Text(&quot;Hijo: &quot;)&#10;                            if (children.isEmpty()) {&#10;                                Text(&quot;(sin hijos)&quot;)&#10;                            } else {&#10;                                var expanded by remember { mutableStateOf(false) }&#10;                                val label = children.getOrNull(selectedChildIndex)?.nombre ?: &quot;Seleccionar&quot;&#10;                                Box {&#10;                                    TextButton(onClick = { expanded = true }) { Text(label) }&#10;                                    DropdownMenu(expanded = expanded, onDismissRequest = { expanded = false }) {&#10;                                        children.forEachIndexed { idx, child -&gt;&#10;                                            DropdownMenuItem(text = { Text(child.nombre) }, onClick = { selectedChildIndex = idx; expanded = false })&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                IconButton(onClick = {&#10;                    displayedMonth = (displayedMonth.clone() as Calendar).apply { add(Calendar.MONTH, 1) }&#10;                }) {&#10;                    Icon(Icons.Filled.ChevronRight, contentDescription = &quot;Mes siguiente&quot;)&#10;                }&#10;            }&#10;&#10;            Spacer(Modifier.height(16.dp))&#10;&#10;            // Días de la semana -- respetar locale (primer día simplificado)&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceEvenly&#10;            ) {&#10;                // Obtener nombres de días desde locale&#10;                val df = SimpleDateFormat(&quot;EE&quot;, Locale.getDefault())&#10;                val headerCal = Calendar.getInstance()&#10;                // usar firstDayOfWeek del locale&#10;                val firstDow = headerCal.firstDayOfWeek&#10;                for (i in 0 until 7) {&#10;                    headerCal.set(Calendar.DAY_OF_WEEK, (firstDow + i - 1) % 7 + 1)&#10;                    Text(&#10;                        text = df.format(headerCal.time),&#10;                        modifier = Modifier.weight(1f),&#10;                        textAlign = TextAlign.Center,&#10;                        style = MaterialTheme.typography.labelMedium,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = MaterialTheme.colorScheme.primary&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(Modifier.height(8.dp))&#10;&#10;            // Grid del calendario con fecha seleccionada y soporte swipe/anim&#10;            Box(modifier = Modifier&#10;                .fillMaxWidth()&#10;                .height(320.dp)&#10;                .pointerInput(Unit) {&#10;                    detectHorizontalDragGestures { change, dragAmount -&gt;&#10;                        val threshold = 150&#10;                        if (dragAmount &gt; threshold) {&#10;                            // swipe derecha -&gt; mes anterior&#10;                            displayedMonth = (displayedMonth.clone() as Calendar).apply { add(Calendar.MONTH, -1) }&#10;                        } else if (dragAmount &lt; -threshold) {&#10;                            // swipe izquierda -&gt; mes siguiente&#10;                            displayedMonth = (displayedMonth.clone() as Calendar).apply { add(Calendar.MONTH, 1) }&#10;                        }&#10;                    }&#10;                }&#10;            ) {&#10;                AnimatedContent(targetState = displayedMonth.timeInMillis, transitionSpec = {&#10;                    slideInHorizontally(initialOffsetX = { fullWidth -&gt; if (targetState &gt; initialState) fullWidth else -fullWidth }, animationSpec = tween(300))&#10;                        .togetherWith(&#10;                            slideOutHorizontally(targetOffsetX = { fullWidth -&gt; if (targetState &gt; initialState) -fullWidth else fullWidth }, animationSpec = tween(300))&#10;                        )&#10;                }) { ts -&gt;&#10;                       key(ts) {&#10;                           CalendarGrid(&#10;                               displayedMonth = displayedMonth,&#10;                               selectedDay = selectedDay,&#10;                               events = events,&#10;                               onDateSelected = { cal -&gt;&#10;                                   selectedDay = cal&#10;                                   bottomSheetVisible = true&#10;                               }&#10;                           )&#10;                       }&#10;                   }&#10;             }&#10;&#10;            Spacer(Modifier.height(16.dp))&#10;&#10;            // Botón para agregar evento&#10;            Button(&#10;                onClick = { showAddEventDialog = true },&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Icon(Icons.Filled.Add, contentDescription = &quot;Agregar evento&quot;)&#10;                Spacer(Modifier.width(8.dp))&#10;                Text(&quot;Agregar Evento&quot;)&#10;            }&#10;&#10;            Spacer(Modifier.height(16.dp))&#10;&#10;            // Lista de próximos eventos (paginated) con filtro por tipo&#10;            Text(&#10;                &quot;Próximos Eventos&quot;,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;&#10;            Spacer(Modifier.height(8.dp))&#10;&#10;            // Filtro por tipo&#10;            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                Text(&quot;Filtrar: &quot;)&#10;                Spacer(Modifier.width(8.dp))&#10;                // botones simples para filtrar por tipo&#10;                EventType.entries.let { types -&gt;&#10;                    types.forEach { t -&gt;&#10;                         val selected = selectedFilterType == t&#10;                         TextButton(onClick = { selectedFilterType = if (selected) null else t }) {&#10;                             Text(t.name, color = if (selected) MaterialTheme.colorScheme.onPrimary else MaterialTheme.colorScheme.onSurface)&#10;                         }&#10;                     }&#10;                 }&#10;            }&#10;&#10;            Spacer(Modifier.height(8.dp))&#10;&#10;            // carga inicial de upcoming en background (no duplicar si ya cargado)&#10;            LaunchedEffect(auth.currentUser?.uid) {&#10;                upcomingEvents.clear()&#10;                upcomingLastSnapshot = null&#10;                // pasar los courseIds disponibles (si ya se cargaron) para traer también eventos globales&#10;                val courseIds = userCourses.map { it.first }&#10;                loadMoreUpcoming(db, auth, upcomingEvents, courseIds) { doc -&gt; upcomingLastSnapshot = doc }&#10;            }&#10;&#10;            val displayedUpcoming = if (selectedFilterType == null) upcomingEvents.toList() else upcomingEvents.filter { it.type == selectedFilterType }&#10;&#10;            LazyColumn(&#10;                 verticalArrangement = Arrangement.spacedBy(8.dp)&#10;             ) {&#10;                items(displayedUpcoming) { event -&gt;&#10;                    // per-event permissions: owner can edit/delete USER events; DOCENTE can edit/delete GLOBAL events&#10;                    val uid = auth.currentUser?.uid&#10;                    val allowEdit = when (event.source) {&#10;                        EventSource.USER -&gt; event.ownerId == uid&#10;                        EventSource.GLOBAL -&gt; role == Role.DOCENTE&#10;                    }&#10;                    val allowDelete = allowEdit&#10;                    EventCard(event,&#10;                        onEdit = if (allowEdit) { ev -&gt; editingEvent = ev; showEditEventDialog = true } else null,&#10;                        onDelete = if (allowDelete) { ev -&gt; eventToDelete = ev; showDeleteConfirm = true } else null&#10;                    )&#10;                }&#10;                item {&#10;                    Spacer(Modifier.height(6.dp))&#10;                    Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.Center) {&#10;                        val courseIds = userCourses.map { it.first }&#10;                        if (upcomingLastSnapshot != null) {&#10;                            Button(onClick = { loadMoreUpcoming(db, auth, upcomingEvents, courseIds) { doc -&gt; upcomingLastSnapshot = doc } }) { Text(&quot;Cargar más&quot;) }&#10;                        }&#10;                    }&#10;                 }&#10;             }&#10;         }&#10;     }&#10;&#10;    // Bottom sheet para eventos del día seleccionado (simple Modal)&#10;    if (bottomSheetVisible &amp;&amp; selectedDay != null) {&#10;        val selLocal = LocalDate.of(selectedDay!!.get(Calendar.YEAR), selectedDay!!.get(Calendar.MONTH)+1, selectedDay!!.get(Calendar.DAY_OF_MONTH))&#10;        val dayEvents = events.filter { ev -&gt;&#10;            val evLocal = Instant.ofEpochMilli(ev.date.time).atZone(ZoneId.systemDefault()).toLocalDate()&#10;            evLocal == selLocal&#10;        }.sortedBy { it.date }&#10;&#10;        ModalBottomSheet(&#10;            onDismissRequest = { bottomSheetVisible = false }&#10;        ) {&#10;            Column(modifier = Modifier.padding(16.dp)) {&#10;                Text(&quot;Eventos en ${SimpleDateFormat(&quot;dd/MM/yyyy&quot;, Locale.getDefault()).format(selectedDay!!.time)}&quot;, style = MaterialTheme.typography.titleMedium, fontWeight = FontWeight.Bold)&#10;                Spacer(Modifier.height(8.dp))&#10;                if (dayEvents.isEmpty()) {&#10;                    Text(&quot;No hay eventos para este día&quot;, color = MaterialTheme.colorScheme.onSurfaceVariant)&#10;                } else {&#10;                    dayEvents.forEach { ev -&gt;&#10;                        val uid = auth.currentUser?.uid&#10;                        val allowEdit = when (ev.source) {&#10;                            EventSource.USER -&gt; ev.ownerId == uid&#10;                            EventSource.GLOBAL -&gt; role == Role.DOCENTE&#10;                        }&#10;                        val allowDelete = allowEdit&#10;                        EventCard(ev,&#10;                            onEdit = if (allowEdit) { e -&gt; editingEvent = e; showEditEventDialog = true } else null,&#10;                            onDelete = if (allowDelete) { e -&gt; eventToDelete = e; showDeleteConfirm = true } else null&#10;                        )&#10;                        Spacer(Modifier.height(8.dp))&#10;                    }&#10;                }&#10;                Spacer(Modifier.height(8.dp))&#10;                Row(horizontalArrangement = Arrangement.End, modifier = Modifier.fillMaxWidth()) {&#10;                    TextButton(onClick = { bottomSheetVisible = false }) { Text(&quot;Cerrar&quot;) }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    if (showAddEventDialog) {&#10;        AddEventDialog(&#10;            initialDate = selectedDay?.time ?: displayedMonth.time,&#10;            onDismiss = { showAddEventDialog = false },&#10;            onSave = { title, description, date, type, targetCourseId -&gt;&#10;                val userId = auth.currentUser?.uid&#10;                if (userId == null) {&#10;                    scope.launch { snackbarHostState.showSnackbar(&quot;Debes iniciar sesión para agregar eventos&quot;) }&#10;                    return@AddEventDialog&#10;                }&#10;                val db = FirebaseFirestore.getInstance()&#10;                val eventId = UUID.randomUUID().toString()&#10;                val eventData = hashMapOf&lt;String, Any?&gt;(&#10;                    &quot;id&quot; to eventId,&#10;                    &quot;title&quot; to title,&#10;                    &quot;description&quot; to description,&#10;                    &quot;date&quot; to Timestamp(date),&#10;                    &quot;type&quot; to type.name,&#10;                    &quot;createdAt&quot; to Timestamp.now(),&#10;                    &quot;ownerId&quot; to userId&#10;                )&#10;                // If teacher selected a course target, save as global event in top-level collection&#10;                if (role == Role.DOCENTE &amp;&amp; !targetCourseId.isNullOrBlank()) {&#10;                    eventData[&quot;courseId&quot;] = targetCourseId&#10;                    db.collection(&quot;events&quot;).document(eventId)&#10;                        .set(eventData)&#10;                        .addOnSuccessListener {&#10;                            events.add(CalendarEvent(eventId, title, description, date, type, EventSource.GLOBAL, targetCourseId))&#10;                            showAddEventDialog = false&#10;                            scope.launch { snackbarHostState.showSnackbar(&quot;Evento de curso agregado&quot;) }&#10;&#10;                            // Crear notificaciones para estudiantes del curso (solo si el creador no es estudiante)&#10;                            try {&#10;                                // obtener estudiantes desde subcolección courses/{courseId}/students&#10;                                val tcid = targetCourseId&#10;                                db.collection(&quot;courses&quot;).document(tcid).collection(&quot;students&quot;).get()&#10;                                    .addOnSuccessListener { studsSnap -&gt;&#10;                                        val studentIds = if (!studsSnap.isEmpty) studsSnap.documents.mapNotNull { it.id } else emptyList()&#10;                                        if (studentIds.isEmpty()) {&#10;                                            // fallback: si no hay subcoleccion, intentar buscar en students collection por courseId&#10;                                            db.collection(&quot;students&quot;).whereEqualTo(&quot;courseId&quot;, tcid).get()&#10;                                                .addOnSuccessListener { altSnap -&gt;&#10;                                                    val altIds = altSnap.documents.mapNotNull { it.id }&#10;                                                    // resolver senderName y crear notifs&#10;                                                    resolveAndCreateNotifs(altIds, title, description, eventId, db, auth)&#10;                                                }&#10;                                        } else {&#10;                                            resolveAndCreateNotifs(studentIds, title, description, eventId, db, auth)&#10;                                        }&#10;                                    }&#10;                            } catch (e: Exception) {&#10;                                Log.w(&quot;CalendarScreen&quot;, &quot;Error creando notificaciones de curso: ${e.message}&quot;)&#10;                            }&#10;                        }&#10;                        .addOnFailureListener { e -&gt;&#10;                            Log.e(&quot;CalendarScreen&quot;, &quot;Error saving global event: ${e.message}&quot;, e)&#10;                            scope.launch { snackbarHostState.showSnackbar(&quot;Error guardando evento&quot;) }&#10;                        }&#10;                } else {&#10;                    // save personal event under users/{uid}/events&#10;                    db.collection(&quot;users&quot;).document(userId).collection(&quot;events&quot;).document(eventId)&#10;                        .set(eventData)&#10;                        .addOnSuccessListener {&#10;                            events.add(CalendarEvent(eventId, title, description, date, type, EventSource.USER, userId))&#10;                            showAddEventDialog = false&#10;                            scope.launch { snackbarHostState.showSnackbar(&quot;Evento agregado&quot;) }&#10;                        }&#10;                        .addOnFailureListener { e -&gt;&#10;                            Log.e(&quot;CalendarScreen&quot;, &quot;Error saving personal event: ${e.message}&quot;, e)&#10;                            scope.launch { snackbarHostState.showSnackbar(&quot;Error guardando evento&quot;) }&#10;                        }&#10;                }&#10;            },&#10;            role = role,&#10;            userCourses = userCourses.toList()&#10;        )&#10;    }&#10;&#10;    // handle actual deletion when confirmed&#10;    if (showDeleteConfirm &amp;&amp; eventToDelete != null) {&#10;        AlertDialog(onDismissRequest = { showDeleteConfirm = false; eventToDelete = null }, title = { Text(&quot;Confirmar eliminación&quot;) }, text = { Text(&quot;Eliminar evento '${eventToDelete!!.title}'?&quot;) }, confirmButton = {&#10;            TextButton(onClick = {&#10;                val uid = auth.currentUser?.uid ?: run { showDeleteConfirm = false; eventToDelete = null; return@TextButton }&#10;                val ev = eventToDelete&#10;                if (ev == null) return@TextButton&#10;                if (ev.source == EventSource.USER) {&#10;                    // delete under owner user's events&#10;                    val owner = ev.ownerId ?: uid&#10;                    db.collection(&quot;users&quot;).document(owner).collection(&quot;events&quot;).document(ev.id)&#10;                        .delete()&#10;                        .addOnSuccessListener {&#10;                            events.removeAll { it.id == ev.id }&#10;                            upcomingEvents.removeAll { it.id == ev.id }&#10;                            showDeleteConfirm = false&#10;                            eventToDelete = null&#10;                        }&#10;                        .addOnFailureListener { ex -&gt;&#10;                            scope.launch { snackbarHostState.showSnackbar(&quot;Error eliminando: ${ex.localizedMessage}&quot;) }&#10;                            showDeleteConfirm = false; eventToDelete = null&#10;                        }&#10;                } else {&#10;                    // global event stored in top-level 'events'&#10;                    db.collection(&quot;events&quot;).document(ev.id)&#10;                        .delete()&#10;                        .addOnSuccessListener {&#10;                            events.removeAll { it.id == ev.id }&#10;                            upcomingEvents.removeAll { it.id == ev.id }&#10;                            showDeleteConfirm = false&#10;                            eventToDelete = null&#10;                        }&#10;                        .addOnFailureListener { ex -&gt;&#10;                            scope.launch { snackbarHostState.showSnackbar(&quot;Error eliminando: ${ex.localizedMessage}&quot;) }&#10;                            showDeleteConfirm = false; eventToDelete = null&#10;                        }&#10;                }&#10;            }) { Text(&quot;Eliminar&quot;) }&#10;        }, dismissButton = { TextButton(onClick = { showDeleteConfirm = false; eventToDelete = null }) { Text(&quot;Cancelar&quot;) } })&#10;    }&#10;&#10;    // Edit dialog&#10;    if (showEditEventDialog &amp;&amp; editingEvent != null) {&#10;        EditEventDialog(event = editingEvent!!, onDismiss = { showEditEventDialog = false; editingEvent = null }, onSave = { updated -&gt;&#10;             val uid = auth.currentUser?.uid ?: return@EditEventDialog&#10;             val map = mapOf(&quot;title&quot; to updated.title, &quot;description&quot; to updated.description, &quot;date&quot; to Timestamp(updated.date), &quot;type&quot; to updated.type.name)&#10;             // update in appropriate collection based on source&#10;             if (updated.source == EventSource.USER) {&#10;                // actualizar en la colección del owner (no asumir uid actual)&#10;                val owner = updated.ownerId ?: uid&#10;                db.collection(&quot;users&quot;).document(owner).collection(&quot;events&quot;).document(updated.id)&#10;                    .update(map)&#10;                    .addOnSuccessListener {&#10;                        fun replace(list: MutableList&lt;CalendarEvent&gt;) {&#10;                            val idx = list.indexOfFirst { it.id == updated.id }&#10;                            if (idx &gt;= 0) list[idx] = updated&#10;                        }&#10;                        replace(events)&#10;                        replace(upcomingEvents)&#10;                        showEditEventDialog = false; editingEvent = null&#10;                    }&#10;                    .addOnFailureListener { ex -&gt; scope.launch { snackbarHostState.showSnackbar(&quot;Error actualizando: ${ex.localizedMessage}&quot;) } }&#10;             } else {&#10;                 // teacher editing global event&#10;                 val mapWithCourse = hashMapOf&lt;String, Any?&gt;()&#10;                 mapWithCourse.putAll(map)&#10;                 if (!updated.ownerId.isNullOrBlank()) mapWithCourse[&quot;courseId&quot;] = updated.ownerId&#10;                 db.collection(&quot;events&quot;).document(updated.id).update(mapWithCourse as Map&lt;String, Any?&gt;)&#10;                      .addOnSuccessListener {&#10;                          fun replace(list: MutableList&lt;CalendarEvent&gt;) {&#10;                              val idx = list.indexOfFirst { it.id == updated.id }&#10;                              if (idx &gt;= 0) list[idx] = updated&#10;                          }&#10;                          replace(events)&#10;                          replace(upcomingEvents)&#10;                          showEditEventDialog = false&#10;                          editingEvent = null&#10;                      }&#10;                      .addOnFailureListener { ex -&gt; scope.launch { snackbarHostState.showSnackbar(&quot;Error actualizando: ${ex.localizedMessage}&quot;) } }&#10;             }&#10;         }, role = role, userCourses = userCourses.toList())&#10;      }&#10;&#10;    // After listeners are set up, if an eventId was provided attempt to locate and select it&#10;    LaunchedEffect(eventId) {&#10;        if (eventId.isNullOrBlank()) return@LaunchedEffect&#10;        // try to find locally first&#10;        val found = events.find { it.id == eventId }&#10;        if (found != null) {&#10;            selectedDay = Calendar.getInstance().apply { time = found.date }&#10;            bottomSheetVisible = true&#10;        } else {&#10;            // try to fetch from top-level events&#10;            try {&#10;                val doc = db.collection(&quot;events&quot;).document(eventId).get().await()&#10;                if (doc.exists()) {&#10;                    val title = doc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                    val description = doc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                    val ts = doc.get(&quot;date&quot;)&#10;                    val d = when (ts) { is Timestamp -&gt; ts.toDate(); is Date -&gt; ts; else -&gt; null }&#10;                    val type = try { EventType.valueOf(doc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                    if (d != null) {&#10;                        selectedDay = Calendar.getInstance().apply { time = d }&#10;                        events.add(CalendarEvent(eventId, title, description, d, type, EventSource.GLOBAL, doc.getString(&quot;courseId&quot;)))&#10;                        bottomSheetVisible = true&#10;                    }&#10;                } else {&#10;                    // try users/{uid}/events&#10;                    val uid = auth.currentUser?.uid&#10;                    if (!uid.isNullOrBlank()) {&#10;                        val ud = db.collection(&quot;users&quot;).document(uid).collection(&quot;events&quot;).document(eventId).get().await()&#10;                        if (ud.exists()) {&#10;                            val title = ud.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                            val description = ud.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                            val ts = ud.get(&quot;date&quot;)&#10;                            val d = when (ts) { is Timestamp -&gt; ts.toDate(); is Date -&gt; ts; else -&gt; null }&#10;                            val type = try { EventType.valueOf(ud.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                            if (d != null) {&#10;                                selectedDay = Calendar.getInstance().apply { time = d }&#10;                                events.add(CalendarEvent(eventId, title, description, d, type, EventSource.USER, uid))&#10;                                bottomSheetVisible = true&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            } catch (_: Exception) { }&#10;        }&#10;    }&#10;}&#10;&#10;// Generador simple de ocurrencias para recurrencia básica&#10;fun generateOccurrences(startDate: Date, recurrence: String, rangeStart: Date, rangeEnd: Date): List&lt;Date&gt; {&#10;     val res = mutableListOf&lt;Date&gt;()&#10;     val cal = Calendar.getInstance().apply { time = startDate }&#10;     val endRangeCal = Calendar.getInstance().apply { time = rangeEnd }&#10;     val startRangeCal = Calendar.getInstance().apply { time = rangeStart }&#10;&#10;     when (recurrence.uppercase(Locale.getDefault())) {&#10;         &quot;DAILY&quot; -&gt; {&#10;             // avanzar hasta &gt;= startRange&#10;             while (cal.before(startRangeCal)) cal.add(Calendar.DAY_OF_MONTH, 1)&#10;             while (!cal.after(endRangeCal)) {&#10;                 res.add(cal.time)&#10;                 cal.add(Calendar.DAY_OF_MONTH, 1)&#10;             }&#10;         }&#10;         &quot;WEEKLY&quot; -&gt; {&#10;             while (cal.before(startRangeCal)) cal.add(Calendar.WEEK_OF_YEAR, 1)&#10;             while (!cal.after(endRangeCal)) {&#10;                 res.add(cal.time)&#10;                 cal.add(Calendar.WEEK_OF_YEAR, 1)&#10;             }&#10;         }&#10;         &quot;MONTHLY&quot; -&gt; {&#10;             while (cal.before(startRangeCal)) cal.add(Calendar.MONTH, 1)&#10;             while (!cal.after(endRangeCal)) {&#10;                 res.add(cal.time)&#10;                 cal.add(Calendar.MONTH, 1)&#10;             }&#10;         }&#10;         else -&gt; { /* no soportado */ }&#10;     }&#10;&#10;     return res&#10; }&#10;&#10;@Composable&#10;private fun CalendarGrid(&#10;    displayedMonth: Calendar,&#10;    selectedDay: Calendar?,&#10;    events: List&lt;CalendarEvent&gt;,&#10;    onDateSelected: (Calendar) -&gt; Unit&#10;) {&#10;    val calendar = (displayedMonth.clone() as Calendar).apply { set(Calendar.DAY_OF_MONTH, 1) }&#10;    // determinar primer día de semana según locale/WeekFields&#10;    val firstDowField = WeekFields.of(Locale.getDefault()).firstDayOfWeek&#10;    val firstDayOfWeek = (firstDowField.value - 1) // DayOfWeek.MONDAY.value==1&#10;    val daysInMonth = calendar.getActualMaximum(Calendar.DAY_OF_MONTH)&#10;&#10;    val today = Calendar.getInstance()&#10;&#10;    LazyVerticalGrid(&#10;        columns = GridCells.Fixed(7),&#10;        modifier = Modifier.height(300.dp)&#10;    ) {&#10;        // Espacios en blanco antes del primer día&#10;        items(firstDayOfWeek) {&#10;            Box(modifier = Modifier.aspectRatio(1f))&#10;        }&#10;&#10;        // Días del mes&#10;        items(daysInMonth) { day -&gt;&#10;            val dayNumber = day + 1&#10;            val thisDay = (calendar.clone() as Calendar).apply { set(Calendar.DAY_OF_MONTH, dayNumber) }&#10;&#10;            // usar LocalDate para evitar problemas de zona/hora&#10;            val thisLocal = Instant.ofEpochMilli(thisDay.time.time).atZone(ZoneId.systemDefault()).toLocalDate()&#10;&#10;            val dayEvents = events.filter { ev -&gt;&#10;                val evLocal = Instant.ofEpochMilli(ev.date.time).atZone(ZoneId.systemDefault()).toLocalDate()&#10;                evLocal == thisLocal&#10;            }&#10;            val hasEvent = dayEvents.isNotEmpty()&#10;&#10;            val isToday = Instant.ofEpochMilli(today.time.time).atZone(ZoneId.systemDefault()).toLocalDate() == thisLocal&#10;&#10;            val isSelected = selectedDay?.let { sel -&gt;&#10;                val selLocal = Instant.ofEpochMilli(sel.time.time).atZone(ZoneId.systemDefault()).toLocalDate()&#10;                selLocal == thisLocal&#10;            } ?: false&#10;&#10;            Box(&#10;                modifier = Modifier&#10;                    .aspectRatio(1f)&#10;                    .padding(2.dp)&#10;                    .clip(CircleShape)&#10;                    .background(&#10;                        color = when {&#10;                            isSelected -&gt; MaterialTheme.colorScheme.primary.copy(alpha = 0.25f)&#10;                            isToday -&gt; MaterialTheme.colorScheme.primaryContainer&#10;                            hasEvent -&gt; MaterialTheme.colorScheme.secondaryContainer.copy(alpha = 0.5f)&#10;                            else -&gt; Color.Transparent&#10;                        }&#10;                    )&#10;                    .clickable { onDateSelected(thisDay) },&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Column(&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    Text(&#10;                        text = dayNumber.toString(),&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        fontWeight = if (isToday || isSelected) FontWeight.Bold else FontWeight.Normal,&#10;                        color = if (isToday || isSelected) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.onSurface&#10;                    )&#10;                    if (hasEvent) {&#10;                        // mostrar hasta 3 puntos de colores según tipos distintos&#10;                        val types = dayEvents.map { it.type }.distinct()&#10;                        val maxDots = 3&#10;                        Row(horizontalArrangement = Arrangement.Center, verticalAlignment = Alignment.CenterVertically) {&#10;                            types.take(maxDots).forEach { t -&gt;&#10;                                val dotColor = when (t) {&#10;                                    EventType.CLASE -&gt; Color(0xFF2196F3)&#10;                                    EventType.EXAMEN -&gt; Color(0xFFF44336)&#10;                                    EventType.TAREA -&gt; Color(0xFFFFC107)&#10;                                    EventType.EVENTO -&gt; Color(0xFF4CAF50)&#10;                                }&#10;                                Box(modifier = Modifier.size(6.dp).background(dotColor, CircleShape))&#10;                                Spacer(Modifier.width(4.dp))&#10;                            }&#10;                            if (types.size &gt; maxDots) {&#10;                                Text(&quot;+${types.size - maxDots}&quot;, style = MaterialTheme.typography.bodySmall)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun EventCard(event: CalendarEvent, onEdit: ((CalendarEvent) -&gt; Unit)? = null, onDelete: ((CalendarEvent) -&gt; Unit)? = null) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            // Reemplazado: icono envuelto en un fondo/círculo para crear la &quot;margen en forma de círculo&quot;&#10;            Box(&#10;                modifier = Modifier&#10;                    .size(40.dp)&#10;                    .clip(CircleShape)&#10;                    .background(MaterialTheme.colorScheme.primary.copy(alpha = 0.12f)),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Icon(&#10;                    imageVector = when (event.type) {&#10;                        EventType.CLASE -&gt; Icons.Filled.School&#10;                        EventType.EXAMEN -&gt; Icons.Filled.Warning&#10;                        EventType.TAREA -&gt; Icons.AutoMirrored.Filled.Assignment&#10;                        EventType.EVENTO -&gt; Icons.AutoMirrored.Filled.EventNote&#10;                    },&#10;                    contentDescription = null,&#10;                    tint = when (event.type) {&#10;                        EventType.CLASE -&gt; Color(0xFF2196F3)&#10;                        EventType.EXAMEN -&gt; Color(0xFFF44336)&#10;                        EventType.TAREA -&gt; Color(0xFFFFC107)&#10;                        EventType.EVENTO -&gt; Color(0xFF4CAF50)&#10;                    },&#10;                    modifier = Modifier.size(20.dp)&#10;                )&#10;            }&#10;            Spacer(Modifier.width(12.dp))&#10;            Column(modifier = Modifier.weight(1f)) {&#10;                Text(event.title, style = MaterialTheme.typography.titleSmall, fontWeight = FontWeight.SemiBold)&#10;                Text(SimpleDateFormat(&quot;dd/MM/yyyy HH:mm&quot;, Locale.getDefault()).format(event.date), style = MaterialTheme.typography.bodySmall, color = MaterialTheme.colorScheme.onSurfaceVariant)&#10;                if (event.description.isNotBlank()) Text(event.description, style = MaterialTheme.typography.bodyMedium)&#10;            }&#10;            // acciones opcionales&#10;            if (onEdit != null) IconButton(onClick = { onEdit(event) }) { Icon(Icons.Filled.Edit, contentDescription = &quot;Editar&quot;) }&#10;            if (onDelete != null) IconButton(onClick = { onDelete(event) }) { Icon(Icons.Filled.Delete, contentDescription = &quot;Eliminar&quot;) }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun AddEventDialog(&#10;     initialDate: Date,&#10;     onDismiss: () -&gt; Unit,&#10;     onSave: (String, String, Date, EventType, String?) -&gt; Unit,&#10;     role: Role?,&#10;     userCourses: List&lt;Pair&lt;String,String&gt;&gt; = emptyList()&#10; ) {&#10;    val context = LocalContext.current&#10;    var title by remember { mutableStateOf(&quot;&quot;) }&#10;    var description by remember { mutableStateOf(&quot;&quot;) }&#10;    // fecha y hora seleccionadas separadas&#10;    var dateCal by remember { mutableStateOf(Calendar.getInstance().apply { time = initialDate }) }&#10;    var type by remember { mutableStateOf(EventType.EVENTO) }&#10;    var targetCourseId by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;    // funciones auxiliares para abrir pickers nativos&#10;    fun openDatePicker() {&#10;        val c = dateCal&#10;        android.app.DatePickerDialog(context, { _, y, m, d -&gt;&#10;            c.set(Calendar.YEAR, y)&#10;            c.set(Calendar.MONTH, m)&#10;            c.set(Calendar.DAY_OF_MONTH, d)&#10;            dateCal = c&#10;        }, c.get(Calendar.YEAR), c.get(Calendar.MONTH), c.get(Calendar.DAY_OF_MONTH)).show()&#10;    }&#10;&#10;    fun openTimePicker() {&#10;        val c = dateCal&#10;        android.app.TimePickerDialog(context, { _, hour, minute -&gt;&#10;            c.set(Calendar.HOUR_OF_DAY, hour)&#10;            c.set(Calendar.MINUTE, minute)&#10;            c.set(Calendar.SECOND, 0)&#10;            dateCal = c&#10;        }, c.get(Calendar.HOUR_OF_DAY), c.get(Calendar.MINUTE), true).show()&#10;    }&#10;&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = { Text(&quot;Agregar Evento&quot;) },&#10;        text = {&#10;            Column {&#10;                OutlinedTextField(value = title, onValueChange = { title = it }, label = { Text(&quot;Título&quot;) }, singleLine = true)&#10;                Spacer(Modifier.height(8.dp))&#10;                OutlinedTextField(value = description, onValueChange = { description = it }, label = { Text(&quot;Descripción&quot;) })&#10;                Spacer(Modifier.height(8.dp))&#10;                Row(verticalAlignment = Alignment.CenterVertically) {&#10;                    Text(&quot;Fecha: ${SimpleDateFormat(&quot;dd/MM/yyyy&quot;, Locale.getDefault()).format(dateCal.time)}&quot;)&#10;                    Spacer(Modifier.width(8.dp))&#10;                    TextButton(onClick = { openDatePicker() }) { Text(&quot;Seleccionar fecha&quot;) }&#10;                }&#10;                Spacer(Modifier.height(8.dp))&#10;                Row(verticalAlignment = Alignment.CenterVertically) {&#10;                    Text(&quot;Hora: ${String.format(Locale.getDefault(), &quot;%02d:%02d&quot;, dateCal.get(Calendar.HOUR_OF_DAY), dateCal.get(Calendar.MINUTE))}&quot;)&#10;                    Spacer(Modifier.width(8.dp))&#10;                    TextButton(onClick = { openTimePicker() }) { Text(&quot;Seleccionar hora&quot;) }&#10;                }&#10;                Spacer(Modifier.height(8.dp))&#10;                Column(modifier = Modifier.fillMaxWidth()) {&#10;                    EventType.entries.forEach { ev -&gt;&#10;                        Row(&#10;                            verticalAlignment = Alignment.CenterVertically,&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(vertical = 4.dp)&#10;                        ) {&#10;                            RadioButton(selected = type == ev, onClick = { type = ev })&#10;                            Spacer(Modifier.width(8.dp))&#10;                            Text(ev.name, modifier = Modifier.weight(1f))&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // target course selection for teachers&#10;                if (role == Role.DOCENTE) {&#10;                    Spacer(Modifier.height(8.dp))&#10;                    Text(&quot;Curso objetivo (opcional):&quot;, style = MaterialTheme.typography.labelMedium)&#10;                    // mostrar cursos disponibles para el docente&#10;                    LazyColumn(&#10;                        modifier = Modifier.heightIn(max = 200.dp),&#10;                        verticalArrangement = Arrangement.spacedBy(4.dp)&#10;                    ) {&#10;                        items(userCourses) { course -&gt;&#10;                            val isSelected = targetCourseId == course.first&#10;                            Row(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .clickable { targetCourseId = if (isSelected) null else course.first }&#10;                                    .padding(8.dp)&#10;                                    .background(&#10;                                        color = if (isSelected) MaterialTheme.colorScheme.primary.copy(alpha = 0.2f) else Color.Transparent,&#10;                                        shape = CircleShape&#10;                                    ),&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                Text(course.second, modifier = Modifier.weight(1f))&#10;                                if (isSelected) {&#10;                                    Icon(Icons.Filled.Check, contentDescription = &quot;Seleccionado&quot;, tint = MaterialTheme.colorScheme.primary)&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        },&#10;        confirmButton = {&#10;            TextButton(onClick = {&#10;                if (title.isBlank()) return@TextButton&#10;                onSave(title, description, dateCal.time, type, targetCourseId)&#10;            }) { Text(&quot;Guardar&quot;) }&#10;        },&#10;        dismissButton = {&#10;            TextButton(onClick = onDismiss) { Text(&quot;Cerrar&quot;) }&#10;        }&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun EditEventDialog(event: CalendarEvent, onDismiss: () -&gt; Unit, onSave: (CalendarEvent) -&gt; Unit, role: Role?, userCourses: List&lt;Pair&lt;String,String&gt;&gt; = emptyList()) {&#10;    val context = LocalContext.current&#10;    var title by remember { mutableStateOf(event.title) }&#10;    var description by remember { mutableStateOf(event.description) }&#10;    var dateCal by remember { mutableStateOf(Calendar.getInstance().apply { time = event.date }) }&#10;    var type by remember { mutableStateOf(event.type) }&#10;    var targetCourseId by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;    // cargar id de curso objetivo si es evento global&#10;    LaunchedEffect(event) {&#10;        targetCourseId = if (event.source == EventSource.GLOBAL) event.ownerId else null&#10;    }&#10;&#10;    fun openDatePicker() {&#10;        val c = dateCal&#10;        android.app.DatePickerDialog(context, { _, y, m, d -&gt; c.set(y, m, d); dateCal = c }, c.get(Calendar.YEAR), c.get(Calendar.MONTH), c.get(Calendar.DAY_OF_MONTH)).show()&#10;    }&#10;    fun openTimePicker() {&#10;        val c = dateCal&#10;        android.app.TimePickerDialog(context, { _, h, min -&gt; c.set(Calendar.HOUR_OF_DAY, h); c.set(Calendar.MINUTE, min); dateCal = c }, c.get(Calendar.HOUR_OF_DAY), c.get(Calendar.MINUTE), true).show()&#10;    }&#10;&#10;    AlertDialog(onDismissRequest = onDismiss, title = { Text(&quot;Editar Evento&quot;) }, text = {&#10;        Column {&#10;            OutlinedTextField(value = title, onValueChange = { title = it }, label = { Text(&quot;Título&quot;) }, singleLine = true)&#10;            Spacer(Modifier.height(8.dp))&#10;            OutlinedTextField(value = description, onValueChange = { description = it }, label = { Text(&quot;Descripción&quot;) })&#10;            Spacer(Modifier.height(8.dp))&#10;            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                Text(&quot;Fecha: ${SimpleDateFormat(&quot;dd/MM/yyyy&quot;, Locale.getDefault()).format(dateCal.time)}&quot;)&#10;                Spacer(Modifier.width(8.dp))&#10;                TextButton(onClick = { openDatePicker() }) { Text(&quot;Seleccionar fecha&quot;) }&#10;            }&#10;            Spacer(Modifier.height(8.dp))&#10;            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                Text(&quot;Hora: ${String.format(Locale.getDefault(), &quot;%02d:%02d&quot;, dateCal.get(Calendar.HOUR_OF_DAY), dateCal.get(Calendar.MINUTE))}&quot;)&#10;                Spacer(Modifier.width(8.dp))&#10;                TextButton(onClick = { openTimePicker() }) { Text(&quot;Seleccionar hora&quot;) }&#10;            }&#10;            Spacer(Modifier.height(8.dp))&#10;            Column(modifier = Modifier.fillMaxWidth()) {&#10;                EventType.entries.forEach { ev -&gt;&#10;                    Row(&#10;                        verticalAlignment = Alignment.CenterVertically,&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(vertical = 4.dp)&#10;                    ) {&#10;                        RadioButton(selected = type == ev, onClick = { type = ev })&#10;                        Spacer(Modifier.width(8.dp))&#10;                        Text(ev.name, modifier = Modifier.weight(1f))&#10;                    }&#10;                }&#10;            }&#10;&#10;            // target course selection for teachers&#10;            if (role == Role.DOCENTE) {&#10;                Spacer(Modifier.height(8.dp))&#10;                Text(&quot;Curso objetivo (opcional):&quot;, style = MaterialTheme.typography.labelMedium)&#10;                // mostrar cursos disponibles para el docente&#10;                LazyColumn(&#10;                    modifier = Modifier.heightIn(max = 200.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(4.dp)&#10;                ) {&#10;                    items(userCourses) { course -&gt;&#10;                        val isSelected = targetCourseId == course.first&#10;                        Row(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .clickable { targetCourseId = if (isSelected) null else course.first }&#10;                                .padding(8.dp)&#10;                                .background(&#10;                                    color = if (isSelected) MaterialTheme.colorScheme.primary.copy(alpha = 0.2f) else Color.Transparent,&#10;                                    shape = CircleShape&#10;                                ),&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            Text(course.second, modifier = Modifier.weight(1f))&#10;                            if (isSelected) {&#10;                                Icon(Icons.Filled.Check, contentDescription = &quot;Seleccionado&quot;, tint = MaterialTheme.colorScheme.primary)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }, confirmButton = {&#10;        TextButton(onClick = { onSave(CalendarEvent(event.id, title, description, dateCal.time, type, event.source, targetCourseId)) }) { Text(&quot;Guardar&quot;) }&#10;    }, dismissButton = { TextButton(onClick = onDismiss) { Text(&quot;Cerrar&quot;) } })&#10;}&#10;&#10;// helper to load upcoming events paginated&#10;private fun loadMoreUpcoming(db: FirebaseFirestore, auth: FirebaseAuth, dest: MutableList&lt;CalendarEvent&gt;, courseIds: List&lt;String&gt; = emptyList(), lastSnapshot: DocumentSnapshot? = null, cbLast: (DocumentSnapshot?) -&gt; Unit) {&#10;    val uid = auth.currentUser?.uid ?: return&#10;    val col = db.collection(&quot;users&quot;).document(uid).collection(&quot;events&quot;)&#10;    val PAGE_SIZE = 25&#10;    try {&#10;        var q = col.whereGreaterThanOrEqualTo(&quot;date&quot;, Timestamp.now()).orderBy(&quot;date&quot;)&#10;        if (lastSnapshot != null) q = q.startAfter(lastSnapshot)&#10;        q = q.limit(PAGE_SIZE.toLong())&#10;        q.get().addOnSuccessListener { snap -&gt;&#10;            val docs = snap.documents&#10;            for (doc in docs) {&#10;                val id = doc.id&#10;                val title = doc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                val description = doc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                val ts = doc.get(&quot;date&quot;)&#10;                val d = when (ts) {&#10;                    is Timestamp -&gt; ts.toDate()&#10;                    is Date -&gt; ts&#10;                    else -&gt; null&#10;                }&#10;                val type = try { EventType.valueOf(doc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                val owner = doc.getString(&quot;ownerId&quot;)&#10;                if (d != null) dest.add(CalendarEvent(id, title, description, d, type, EventSource.USER, owner))&#10;            }&#10;            cbLast(docs.lastOrNull())&#10;             // additionally fetch upcoming global events for user's courses (no strict pagination)&#10;             if (courseIds.isNotEmpty()) {&#10;                 courseIds.chunked(10).forEach { chunk -&gt;&#10;                     db.collection(&quot;events&quot;).whereIn(&quot;courseId&quot;, chunk).whereGreaterThanOrEqualTo(&quot;date&quot;, Timestamp.now()).orderBy(&quot;date&quot;).limit(PAGE_SIZE.toLong()).get().addOnSuccessListener { gsnap -&gt;&#10;                         for (gdoc in gsnap.documents) {&#10;                             val id = gdoc.id&#10;                             if (dest.any { it.id == id }) continue&#10;                             val title = gdoc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                             val description = gdoc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                             val ts = gdoc.get(&quot;date&quot;)&#10;                             val d = when (ts) { is Timestamp -&gt; ts.toDate(); is Date -&gt; ts; else -&gt; null }&#10;                             val type = try { EventType.valueOf(gdoc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                             val courseId = gdoc.getString(&quot;courseId&quot;)&#10;                             if (d != null) dest.add(CalendarEvent(id, title, description, d, type, EventSource.GLOBAL, courseId))&#10;                         }&#10;                     }&#10;                 }&#10;             }&#10;         }&#10;     } catch (_: Exception) {&#10;         // ignore&#10;         cbLast(null)&#10;     }&#10; }&#10;&#10;// helper: crea notificaciones en users/{id}/notifications&#10;fun createNotifsForIds(ids: List&lt;String&gt;, title: String, body: String, relatedId: String, db: FirebaseFirestore, auth: FirebaseAuth) {&#10;     if (ids.isEmpty()) return&#10;    // fallback sender used if name lookup fails&#10;    val fallbackSender = auth.currentUser?.email ?: auth.currentUser?.uid ?: &quot;Profesor&quot;&#10;    for (sid in ids) {&#10;        try {&#10;            val notif = hashMapOf(&#10;                &quot;titulo&quot; to title,&#10;                &quot;cuerpo&quot; to body.take(200),&#10;                &quot;remitente&quot; to fallbackSender,&#10;                &quot;senderName&quot; to fallbackSender,&#10;                &quot;fechaHora&quot; to Timestamp.now(),&#10;                &quot;leida&quot; to false,&#10;                &quot;relatedId&quot; to relatedId,&#10;                &quot;type&quot; to &quot;event&quot;&#10;            )&#10;            db.collection(&quot;users&quot;).document(sid).collection(&quot;notifications&quot;).add(notif)&#10;        } catch (_: Exception) { }&#10;    }&#10;}&#10;&#10;// Resolve current user's display name then call createNotifsForIds with senderName set&#10;fun resolveAndCreateNotifs(ids: List&lt;String&gt;, title: String, body: String, relatedId: String, db: FirebaseFirestore, auth: FirebaseAuth) {&#10;    val uid = auth.currentUser?.uid&#10;    if (uid == null) {&#10;        createNotifsForIds(ids, title, body, relatedId, db, auth)&#10;        return&#10;    }&#10;    try {&#10;        db.collection(&quot;users&quot;).document(uid).get().addOnSuccessListener { doc -&gt;&#10;            val name = doc.getString(&quot;name&quot;) ?: doc.getString(&quot;displayName&quot;) ?: auth.currentUser?.email ?: uid&#10;            // create notifications with senderName field&#10;            for (sid in ids) {&#10;                try {&#10;                    val notif = hashMapOf(&#10;                        &quot;titulo&quot; to title,&#10;                        &quot;cuerpo&quot; to body.take(200),&#10;                        &quot;remitente&quot; to uid,&#10;                        &quot;senderName&quot; to name,&#10;                        &quot;fechaHora&quot; to Timestamp.now(),&#10;                        &quot;leida&quot; to false,&#10;                        &quot;relatedId&quot; to relatedId,&#10;                        &quot;type&quot; to &quot;event&quot;&#10;                    )&#10;                    db.collection(&quot;users&quot;).document(sid).collection(&quot;notifications&quot;).add(notif)&#10;                } catch (_: Exception) {}&#10;            }&#10;        }.addOnFailureListener {&#10;            createNotifsForIds(ids, title, body, relatedId, db, auth)&#10;        }&#10;    } catch (_: Exception) {&#10;        createNotifsForIds(ids, title, body, relatedId, db, auth)&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/appcolegios/dashboard/DashboardScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/appcolegios/dashboard/DashboardScreen.kt" />
              <option name="originalContent" value="package com.example.appcolegios.dashboard&#10;&#10;import androidx.compose.animation.core.animateFloatAsState&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.CornerRadius&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.appcolegios.R&#10;&#10;@Composable&#10;fun DashboardScreen(vm: DashboardViewModel = viewModel()) {&#10;    val state = vm.state.collectAsState().value&#10;&#10;    Column(&#10;        modifier = Modifier.fillMaxSize().padding(16.dp),&#10;    ) {&#10;        Text(stringResource(R.string.dashboard), style = MaterialTheme.typography.headlineSmall, fontWeight = FontWeight.SemiBold)&#10;        Spacer(Modifier.height(12.dp))&#10;        if (state.loading) {&#10;            Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) { CircularProgressIndicator() }&#10;            return&#10;        }&#10;        if (state.error != null) {&#10;            Card(colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.error.copy(alpha = 0.08f))) {&#10;                // state.error ya es no-null dentro de este bloque (comprobado arriba), así que no hace falta el elvis&#10;                Text(state.error, color = MaterialTheme.colorScheme.error, modifier = Modifier.padding(12.dp))&#10;            }&#10;            Spacer(Modifier.height(12.dp))&#10;            Button(onClick = { vm.refresh() }) { Text(stringResource(R.string.retry)) }&#10;            return&#10;        }&#10;&#10;        // Gráfico de barras&#10;        ChartSection(state)&#10;        Spacer(Modifier.height(20.dp))&#10;&#10;        // Pie chart adicional&#10;        PieChartSection(state)&#10;&#10;        Spacer(Modifier.height(20.dp))&#10;&#10;        // Tarjetas de estadísticas&#10;        StatsGrid(state)&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ChartSection(state: DashboardState) {&#10;    Card(&#10;        colors = CardDefaults.elevatedCardColors(containerColor = MaterialTheme.colorScheme.surface),&#10;        elevation = CardDefaults.elevatedCardElevation(defaultElevation = 4.dp)&#10;    ) {&#10;        Column(Modifier.fillMaxWidth().padding(16.dp)) {&#10;            Text(&quot;Resumen Visual&quot;, style = MaterialTheme.typography.titleMedium, fontWeight = FontWeight.Medium)&#10;            Spacer(Modifier.height(12.dp))&#10;&#10;            val maxValue = maxOf(state.usersCount, state.studentsCount, state.teachersCount, state.groupsCount).toFloat()&#10;            val chartData = listOf(&#10;                BarData(stringResource(R.string.total_users), state.usersCount, MaterialTheme.colorScheme.primary),&#10;                BarData(stringResource(R.string.students), state.studentsCount, MaterialTheme.colorScheme.tertiary),&#10;                BarData(stringResource(R.string.teachers), state.teachersCount, MaterialTheme.colorScheme.secondary),&#10;                BarData(stringResource(R.string.groups), state.groupsCount, Color(0xFF9C27B0))&#10;            )&#10;&#10;            SimpleBarChart(data = chartData, maxValue = if (maxValue &gt; 0) maxValue else 1f)&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun SimpleBarChart(data: List&lt;BarData&gt;, maxValue: Float) {&#10;    val barHeight = 40.dp&#10;    val spacing = 12.dp&#10;&#10;    Column(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        verticalArrangement = Arrangement.spacedBy(spacing)&#10;    ) {&#10;        data.forEach { barData -&gt;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = barData.label,&#10;                    style = MaterialTheme.typography.bodySmall,&#10;                    modifier = Modifier.width(80.dp)&#10;                )&#10;                Spacer(Modifier.width(8.dp))&#10;                Box(modifier = Modifier.weight(1f)) {&#10;                    val animatedProgress = animateFloatAsState(&#10;                        targetValue = if (maxValue &gt; 0) barData.value.toFloat() / maxValue else 0f,&#10;                        label = &quot;bar_${barData.label}&quot;&#10;                    ).value&#10;&#10;                    Canvas(modifier = Modifier.fillMaxWidth().height(barHeight)) {&#10;                        val barWidth = size.width * animatedProgress&#10;                        drawRoundRect(&#10;                            color = barData.color,&#10;                            topLeft = Offset(0f, 0f),&#10;                            size = Size(barWidth, size.height),&#10;                            cornerRadius = CornerRadius(8.dp.toPx(), 8.dp.toPx())&#10;                        )&#10;                    }&#10;                    Text(&#10;                        text = barData.value.toString(),&#10;                        style = MaterialTheme.typography.labelMedium,&#10;                        color = Color.White,&#10;                        modifier = Modifier.align(Alignment.CenterStart).padding(start = 8.dp)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;private data class BarData(val label: String, val value: Int, val color: Color)&#10;&#10;@Composable&#10;private fun StatsGrid(state: DashboardState) {&#10;    val cards = listOf(&#10;        Triple(R.string.total_users, state.usersCount, MaterialTheme.colorScheme.primary),&#10;        Triple(R.string.students, state.studentsCount, MaterialTheme.colorScheme.tertiary),&#10;        Triple(R.string.teachers, state.teachersCount, MaterialTheme.colorScheme.secondary),&#10;        Triple(R.string.groups, state.groupsCount, MaterialTheme.colorScheme.primaryContainer),&#10;    )&#10;    Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {&#10;        cards.forEach { (labelId, value, color) -&gt;&#10;            val scale = animateFloatAsState(targetValue = 1f, label = &quot;stat_scale&quot;).value&#10;            ElevatedCard(&#10;                colors = CardDefaults.elevatedCardColors(containerColor = MaterialTheme.colorScheme.surface),&#10;                elevation = CardDefaults.elevatedCardElevation(defaultElevation = 4.dp)&#10;            ) {&#10;                Row(&#10;                    Modifier.fillMaxWidth().padding(16.dp).graphicsLayer(scaleX = scale, scaleY = scale),&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Column(Modifier.weight(1f)) {&#10;                        Text(text = stringResource(labelId), style = MaterialTheme.typography.titleMedium, color = MaterialTheme.colorScheme.onSurface)&#10;                        Text(text = value.toString(), style = MaterialTheme.typography.displaySmall, color = color)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun PieChartSection(state: DashboardState) {&#10;    Card(&#10;        colors = CardDefaults.elevatedCardColors(containerColor = MaterialTheme.colorScheme.surface),&#10;        elevation = CardDefaults.elevatedCardElevation(defaultElevation = 4.dp)&#10;    ) {&#10;        Column(Modifier.fillMaxWidth().padding(16.dp)) {&#10;            Text(&quot;Distribución usuarios&quot;, style = MaterialTheme.typography.titleMedium)&#10;            Spacer(Modifier.height(12.dp))&#10;&#10;            val students = state.studentsCount.coerceAtLeast(0).toFloat()&#10;            val teachers = state.teachersCount.coerceAtLeast(0).toFloat()&#10;            val admins = (state.usersCount - state.studentsCount - state.teachersCount).coerceAtLeast(0).toFloat()&#10;            val total = (students + teachers + admins).coerceAtLeast(1f)&#10;&#10;            val sections = listOf(&#10;                Pair(&quot;Estudiantes&quot;, students),&#10;                Pair(&quot;Docentes&quot;, teachers),&#10;                Pair(&quot;Otros&quot;, admins)&#10;            )&#10;&#10;            SimplePieChart(values = sections.map { it.second }, colors = listOf(MaterialTheme.colorScheme.tertiary, MaterialTheme.colorScheme.secondary, MaterialTheme.colorScheme.primaryContainer), labels = sections.map { it.first }, total = total)&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun SimplePieChart(values: List&lt;Float&gt;, colors: List&lt;Color&gt;, labels: List&lt;String&gt;, total: Float) {&#10;    // Animar fracciones para que el gráfico tenga una transición suave&#10;    val sweeps = values.map { (it / total) * 360f }&#10;    val animatedSweeps = sweeps.map { animateFloatAsState(targetValue = it).value }&#10;&#10;    Column(horizontalAlignment = Alignment.CenterHorizontally, modifier = Modifier.fillMaxWidth()) {&#10;        Box(contentAlignment = Alignment.Center) {&#10;            val size = 160.dp&#10;            Canvas(modifier = Modifier.size(size)) {&#10;                var startAngle = -90f&#10;                for (i in animatedSweeps.indices) {&#10;                    val sweep = animatedSweeps[i]&#10;                    drawArc(color = colors.getOrElse(i) { Color.Gray }, startAngle = startAngle, sweepAngle = sweep, useCenter = true)&#10;                    startAngle += sweep&#10;                }&#10;            }&#10;            Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                Text(text = &quot;Total: ${total.toInt()}&quot;, style = MaterialTheme.typography.bodyMedium)&#10;            }&#10;        }&#10;&#10;        Spacer(Modifier.height(12.dp))&#10;&#10;        // Leyenda con color y porcentaje&#10;        Column(modifier = Modifier.fillMaxWidth().padding(horizontal = 8.dp)) {&#10;            val percentList = values.map { v -&gt; if (total &gt; 0f) (v / total * 100f) else 0f }&#10;            for (i in labels.indices) {&#10;                Row(verticalAlignment = Alignment.CenterVertically, modifier = Modifier.fillMaxWidth().padding(vertical = 4.dp)) {&#10;                    // color box&#10;                    Box(modifier = Modifier.size(12.dp).background(colors.getOrElse(i) { Color.Gray }))&#10;                    Spacer(Modifier.width(8.dp))&#10;                    Text(text = labels.getOrElse(i) { &quot;&quot; }, modifier = Modifier.weight(1f), style = MaterialTheme.typography.bodySmall)&#10;                    Text(text = &quot;${String.format(&quot;%.1f&quot;, percentList.getOrElse(i) { 0f })}%&quot;, style = MaterialTheme.typography.bodySmall)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.appcolegios.dashboard&#10;&#10;import androidx.compose.animation.core.animateFloatAsState&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.CornerRadius&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.appcolegios.R&#10;import java.util.Locale&#10;&#10;@Composable&#10;fun DashboardScreen(vm: DashboardViewModel = viewModel()) {&#10;    val state = vm.state.collectAsState().value&#10;&#10;    Column(&#10;        modifier = Modifier.fillMaxSize().padding(16.dp),&#10;    ) {&#10;        Text(stringResource(R.string.dashboard), style = MaterialTheme.typography.headlineSmall, fontWeight = FontWeight.SemiBold)&#10;        Spacer(Modifier.height(12.dp))&#10;        if (state.loading) {&#10;            Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) { CircularProgressIndicator() }&#10;            return&#10;        }&#10;        if (state.error != null) {&#10;            Card(colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.error.copy(alpha = 0.08f))) {&#10;                // state.error ya es no-null dentro de este bloque (comprobado arriba), así que no hace falta el elvis&#10;                Text(state.error, color = MaterialTheme.colorScheme.error, modifier = Modifier.padding(12.dp))&#10;            }&#10;            Spacer(Modifier.height(12.dp))&#10;            Button(onClick = { vm.refresh() }) { Text(stringResource(R.string.retry)) }&#10;            return&#10;        }&#10;&#10;        // Gráfico de barras&#10;        ChartSection(state)&#10;        Spacer(Modifier.height(20.dp))&#10;&#10;        // Pie chart adicional&#10;        PieChartSection(state)&#10;&#10;        Spacer(Modifier.height(20.dp))&#10;&#10;        // Tarjetas de estadísticas&#10;        StatsGrid(state)&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ChartSection(state: DashboardState) {&#10;    Card(&#10;        colors = CardDefaults.elevatedCardColors(containerColor = MaterialTheme.colorScheme.surface),&#10;        elevation = CardDefaults.elevatedCardElevation(defaultElevation = 4.dp)&#10;    ) {&#10;        Column(Modifier.fillMaxWidth().padding(16.dp)) {&#10;            Text(stringResource(R.string.visual_summary), style = MaterialTheme.typography.titleMedium, fontWeight = FontWeight.Medium)&#10;            Spacer(Modifier.height(12.dp))&#10;&#10;            val maxValue = maxOf(state.usersCount, state.studentsCount, state.teachersCount, state.groupsCount).toFloat()&#10;            val chartData = listOf(&#10;                BarData(stringResource(R.string.total_users), state.usersCount, MaterialTheme.colorScheme.primary),&#10;                BarData(stringResource(R.string.students), state.studentsCount, MaterialTheme.colorScheme.tertiary),&#10;                BarData(stringResource(R.string.teachers), state.teachersCount, MaterialTheme.colorScheme.secondary),&#10;                BarData(stringResource(R.string.groups), state.groupsCount, Color(0xFF9C27B0))&#10;            )&#10;&#10;            SimpleBarChart(data = chartData, maxValue = if (maxValue &gt; 0) maxValue else 1f)&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun SimpleBarChart(data: List&lt;BarData&gt;, maxValue: Float) {&#10;    val barHeight = 40.dp&#10;    val spacing = 12.dp&#10;&#10;    Column(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        verticalArrangement = Arrangement.spacedBy(spacing)&#10;    ) {&#10;        data.forEach { barData -&gt;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = barData.label,&#10;                    style = MaterialTheme.typography.bodySmall,&#10;                    modifier = Modifier.width(80.dp)&#10;                )&#10;                Spacer(Modifier.width(8.dp))&#10;                Box(modifier = Modifier.weight(1f)) {&#10;                    val animatedProgress = animateFloatAsState(&#10;                        targetValue = if (maxValue &gt; 0) barData.value.toFloat() / maxValue else 0f,&#10;                        label = &quot;bar_${barData.label}&quot;&#10;                    ).value&#10;&#10;                    Canvas(modifier = Modifier.fillMaxWidth().height(barHeight)) {&#10;                        val barWidth = size.width * animatedProgress&#10;                        drawRoundRect(&#10;                            color = barData.color,&#10;                            topLeft = Offset(0f, 0f),&#10;                            size = Size(barWidth, size.height),&#10;                            cornerRadius = CornerRadius(8.dp.toPx(), 8.dp.toPx())&#10;                        )&#10;                    }&#10;                    Text(&#10;                        text = barData.value.toString(),&#10;                        style = MaterialTheme.typography.labelMedium,&#10;                        color = Color.White,&#10;                        modifier = Modifier.align(Alignment.CenterStart).padding(start = 8.dp)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;private data class BarData(val label: String, val value: Int, val color: Color)&#10;&#10;@Composable&#10;private fun StatsGrid(state: DashboardState) {&#10;    val cards = listOf(&#10;        Triple(R.string.total_users, state.usersCount, MaterialTheme.colorScheme.primary),&#10;        Triple(R.string.students, state.studentsCount, MaterialTheme.colorScheme.tertiary),&#10;        Triple(R.string.teachers, state.teachersCount, MaterialTheme.colorScheme.secondary),&#10;        Triple(R.string.groups, state.groupsCount, MaterialTheme.colorScheme.primaryContainer),&#10;    )&#10;    Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {&#10;        cards.forEach { (labelId, value, color) -&gt;&#10;            val scale = animateFloatAsState(targetValue = 1f, label = &quot;stat_scale&quot;).value&#10;            ElevatedCard(&#10;                colors = CardDefaults.elevatedCardColors(containerColor = MaterialTheme.colorScheme.surface),&#10;                elevation = CardDefaults.elevatedCardElevation(defaultElevation = 4.dp)&#10;            ) {&#10;                Row(&#10;                    Modifier.fillMaxWidth().padding(16.dp).graphicsLayer(scaleX = scale, scaleY = scale),&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Column(Modifier.weight(1f)) {&#10;                        Text(text = stringResource(labelId), style = MaterialTheme.typography.titleMedium, color = MaterialTheme.colorScheme.onSurface)&#10;                        Text(text = value.toString(), style = MaterialTheme.typography.displaySmall, color = color)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun PieChartSection(state: DashboardState) {&#10;    Card(&#10;        colors = CardDefaults.elevatedCardColors(containerColor = MaterialTheme.colorScheme.surface),&#10;        elevation = CardDefaults.elevatedCardElevation(defaultElevation = 4.dp)&#10;    ) {&#10;        Column(Modifier.fillMaxWidth().padding(16.dp)) {&#10;            Text(stringResource(R.string.distribution_users), style = MaterialTheme.typography.titleMedium)&#10;            Spacer(Modifier.height(12.dp))&#10;&#10;            val students = state.studentsCount.coerceAtLeast(0).toFloat()&#10;            val teachers = state.teachersCount.coerceAtLeast(0).toFloat()&#10;            val admins = (state.usersCount - state.studentsCount - state.teachersCount).coerceAtLeast(0).toFloat()&#10;            val total = (students + teachers + admins).coerceAtLeast(1f)&#10;&#10;            val sections = listOf(&#10;                Pair(stringResource(R.string.students), students),&#10;                Pair(stringResource(R.string.teachers), teachers),&#10;                Pair(stringResource(R.string.others), admins)&#10;            )&#10;&#10;            SimplePieChart(values = sections.map { it.second }, colors = listOf(MaterialTheme.colorScheme.tertiary, MaterialTheme.colorScheme.secondary, MaterialTheme.colorScheme.primaryContainer), labels = sections.map { it.first }, total = total)&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun SimplePieChart(values: List&lt;Float&gt;, colors: List&lt;Color&gt;, labels: List&lt;String&gt;, total: Float) {&#10;    // Animar fracciones para que el gráfico tenga una transición suave&#10;    val sweeps = values.map { (it / total) * 360f }&#10;    val animatedSweeps = sweeps.map { animateFloatAsState(targetValue = it).value }&#10;&#10;    Column(horizontalAlignment = Alignment.CenterHorizontally, modifier = Modifier.fillMaxWidth()) {&#10;        Box(contentAlignment = Alignment.Center) {&#10;            val size = 160.dp&#10;            Canvas(modifier = Modifier.size(size)) {&#10;                var startAngle = -90f&#10;                for (i in animatedSweeps.indices) {&#10;                    val sweep = animatedSweeps[i]&#10;                    drawArc(color = colors.getOrElse(i) { Color.Gray }, startAngle = startAngle, sweepAngle = sweep, useCenter = true)&#10;                    startAngle += sweep&#10;                }&#10;            }&#10;            Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                Text(text = stringResource(R.string.total_count, total.toInt()), style = MaterialTheme.typography.bodyMedium)&#10;            }&#10;        }&#10;&#10;        Spacer(Modifier.height(12.dp))&#10;&#10;        // Leyenda con color y porcentaje&#10;        Column(modifier = Modifier.fillMaxWidth().padding(horizontal = 8.dp)) {&#10;            val percentList = values.map { v -&gt; if (total &gt; 0f) (v / total * 100f) else 0f }&#10;            for (i in labels.indices) {&#10;                Row(verticalAlignment = Alignment.CenterVertically, modifier = Modifier.fillMaxWidth().padding(vertical = 4.dp)) {&#10;                    // color box&#10;                    Box(modifier = Modifier.size(12.dp).background(colors.getOrElse(i) { Color.Gray }))&#10;                    Spacer(Modifier.width(8.dp))&#10;                    Text(text = labels.getOrElse(i) { &quot;&quot; }, modifier = Modifier.weight(1f), style = MaterialTheme.typography.bodySmall)&#10;                    Text(text = &quot;${String.format(Locale.US, &quot;%.1f&quot;, percentList.getOrElse(i) { 0f })}%&quot;, style = MaterialTheme.typography.bodySmall)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/appcolegios/ui/AnimatedMaterialButton.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/appcolegios/ui/AnimatedMaterialButton.kt" />
              <option name="updatedContent" value="package com.example.appcolegios.ui&#10;&#10;import android.content.Context&#10;import android.util.AttributeSet&#10;import android.view.MotionEvent&#10;import com.google.android.material.button.MaterialButton&#10;&#10;class AnimatedMaterialButton @JvmOverloads constructor(&#10;    context: Context,&#10;    attrs: AttributeSet? = null,&#10;    defStyleAttr: Int = com.google.android.material.R.attr.materialButtonStyle&#10;) : MaterialButton(context, attrs, defStyleAttr) {&#10;&#10;    override fun onTouchEvent(event: MotionEvent): Boolean {&#10;        when (event.action) {&#10;            MotionEvent.ACTION_DOWN -&gt; {&#10;                this.animate().scaleX(0.97f).scaleY(0.97f).setDuration(50).start()&#10;            }&#10;            MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -&gt; {&#10;                this.animate().scaleX(1f).scaleY(1f).setDuration(50).start()&#10;            }&#10;        }&#10;        return super.onTouchEvent(event)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/anim/fade_in.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/anim/fade_in.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:duration=&quot;300&quot;&#10;    android:fromAlpha=&quot;0.0&quot;&#10;    android:toAlpha=&quot;1.0&quot; /&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/values/strings.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/values/strings.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;resources&gt;&#10;&#10;    &lt;string name=&quot;app_name&quot;&gt;AppColegios&lt;/string&gt;&#10;    &lt;string name=&quot;email&quot;&gt;Correo Electrónico&lt;/string&gt;&#10;    &lt;string name=&quot;password&quot;&gt;Contraseña&lt;/string&gt;&#10;    &lt;string name=&quot;login&quot;&gt;Iniciar Sesión&lt;/string&gt;&#10;    &lt;string name=&quot;register&quot;&gt;¿No tienes una cuenta? Regístrate&lt;/string&gt;&#10;    &lt;string name=&quot;reset_password&quot;&gt;¿Olvidaste tu contraseña?&lt;/string&gt;&#10;    &lt;string name=&quot;error_invalid_credentials&quot;&gt;Credenciales inválidas&lt;/string&gt;&#10;    &lt;string name=&quot;account_created&quot;&gt;Cuenta creada. Inicia sesión para continuar.&lt;/string&gt;&#10;    &lt;string name=&quot;name&quot;&gt;Nombre Completo&lt;/string&gt;&#10;    &lt;string name=&quot;document&quot;&gt;Documento&lt;/string&gt;&#10;    &lt;string name=&quot;phone&quot;&gt;Teléfono&lt;/string&gt;&#10;    &lt;string name=&quot;select_role&quot;&gt;Selecciona tu rol&lt;/string&gt;&#10;    &lt;string name=&quot;role_student&quot;&gt;Estudiante&lt;/string&gt;&#10;    &lt;string name=&quot;role_parent&quot;&gt;Padre&lt;/string&gt;&#10;    &lt;string name=&quot;role_teacher&quot;&gt;Docente&lt;/string&gt;&#10;    &lt;string name=&quot;create_account&quot;&gt;Crear Cuenta&lt;/string&gt;&#10;    &lt;string name=&quot;confirm_password&quot;&gt;Confirmar Contraseña&lt;/string&gt;&#10;    &lt;string name=&quot;passwords_do_not_match&quot;&gt;Las contraseñas no coinciden&lt;/string&gt;&#10;    &lt;string name=&quot;field_cannot_be_empty&quot;&gt;El campo no puede estar vacío&lt;/string&gt;&#10;    &lt;string name=&quot;invalid_email&quot;&gt;Correo electrónico inválido&lt;/string&gt;&#10;    &lt;string name=&quot;password_too_short&quot;&gt;La contraseña debe tener al menos 6 caracteres&lt;/string&gt;&#10;    &lt;string name=&quot;send_recovery_email&quot;&gt;Enviar correo de recuperación&lt;/string&gt;&#10;    &lt;string name=&quot;recovery_email_sent&quot;&gt;Se ha enviado un correo de recuperación a tu dirección.&lt;/string&gt;&#10;    &lt;string name=&quot;error_sending_email&quot;&gt;Error al enviar el correo. Inténtalo de nuevo.&lt;/string&gt;&#10;    &lt;string name=&quot;back_to_login&quot;&gt;Volver a inicio de sesión&lt;/string&gt;&#10;    &lt;string name=&quot;network_error&quot;&gt;Error de red&lt;/string&gt;&#10;    &lt;string name=&quot;network_error_description&quot;&gt;No se pudo conectar. Por favor, revisa tu conexión a internet.&lt;/string&gt;&#10;    &lt;string name=&quot;retry&quot;&gt;Reintentar&lt;/string&gt;&#10;    &lt;string name=&quot;logout&quot;&gt;Cerrar Sesión&lt;/string&gt;&#10;    &lt;string name=&quot;logout_confirmation_title&quot;&gt;Confirmar Cierre de Sesión&lt;/string&gt;&#10;    &lt;string name=&quot;logout_confirmation_message&quot;&gt;¿Estás seguro de que quieres cerrar sesión?&lt;/string&gt;&#10;    &lt;string name=&quot;confirm&quot;&gt;Confirmar&lt;/string&gt;&#10;    &lt;string name=&quot;cancel&quot;&gt;Cancelar&lt;/string&gt;&#10;    &lt;string name=&quot;home&quot;&gt;Inicio&lt;/string&gt;&#10;    &lt;string name=&quot;notes&quot;&gt;Notas&lt;/string&gt;&#10;    &lt;string name=&quot;attendance&quot;&gt;Asistencia&lt;/string&gt;&#10;    &lt;string name=&quot;tasks&quot;&gt;Tareas&lt;/string&gt;&#10;    &lt;string name=&quot;calendar&quot;&gt;Calendario&lt;/string&gt;&#10;    &lt;string name=&quot;notifications&quot;&gt;Notificaciones&lt;/string&gt;&#10;    &lt;string name=&quot;messages&quot;&gt;Mensajes&lt;/string&gt;&#10;    &lt;string name=&quot;payments&quot;&gt;Pagos&lt;/string&gt;&#10;    &lt;string name=&quot;profile&quot;&gt;Perfil&lt;/string&gt;&#10;    &lt;string name=&quot;my_academic_information&quot;&gt;Mi información académica&lt;/string&gt;&#10;    &lt;string name=&quot;payments_to_consider&quot;&gt;Pagos a considerar&lt;/string&gt;&#10;    &lt;string name=&quot;back&quot;&gt;Volver&lt;/string&gt;&#10;    &lt;string name=&quot;cerrar_sesion&quot;&gt;Cerrar sesión&lt;/string&gt;&#10;    &lt;string name=&quot;empty_home&quot;&gt;Sin accesos para mostrar.&lt;/string&gt;&#10;    &lt;string name=&quot;error_generic&quot;&gt;Ha ocurrido un error.&lt;/string&gt;&#10;    &lt;string name=&quot;greeting&quot;&gt;Hola, %1$s&lt;/string&gt;&#10;    &lt;string name=&quot;select_student&quot;&gt;Selecciona estudiante&lt;/string&gt;&#10;    &lt;string name=&quot;select_group&quot;&gt;Selecciona grupo&lt;/string&gt;&#10;    &lt;string name=&quot;unread_notifications&quot;&gt;Notificaciones no leídas: %1$d&lt;/string&gt;&#10;    &lt;string name=&quot;unread_messages&quot;&gt;Mensajes no leídos: %1$d&lt;/string&gt;&#10;    &lt;string name=&quot;no_student_data&quot;&gt;Sin datos del estudiante&lt;/string&gt;&#10;    &lt;string name=&quot;error_cargando_datos&quot;&gt;Error cargando datos&lt;/string&gt;&#10;    &lt;string name=&quot;foto_perfil_cd&quot;&gt;Foto de perfil&lt;/string&gt;&#10;    &lt;string name=&quot;curso_label&quot;&gt;Curso&lt;/string&gt;&#10;    &lt;string name=&quot;correo_institucional_label&quot;&gt;Correo inst.&lt;/string&gt;&#10;    &lt;string name=&quot;numero_lista_label&quot;&gt;Nº lista&lt;/string&gt;&#10;    &lt;string name=&quot;eps_label&quot;&gt;EPS&lt;/string&gt;&#10;    &lt;string name=&quot;estado_matricula_label&quot;&gt;Estado matrícula&lt;/string&gt;&#10;    &lt;string name=&quot;my_profile_read_only&quot;&gt;Perfil de solo lectura&lt;/string&gt;&#10;    &lt;string name=&quot;register_attendance&quot;&gt;Registrar asistencia&lt;/string&gt;&#10;    &lt;string name=&quot;how_did_you_get_here_today&quot;&gt;¿Cómo llegaste hoy?&lt;/string&gt;&#10;    &lt;string name=&quot;transporte&quot;&gt;Transporte&lt;/string&gt;&#10;    &lt;string name=&quot;rutas_no_aplican&quot;&gt;Rutas no aplican&lt;/string&gt;&#10;    &lt;string name=&quot;write_message_placeholder&quot;&gt;Escribe un mensaje…&lt;/string&gt;&#10;    &lt;string name=&quot;enviar_mensaje_cd&quot;&gt;Enviar mensaje&lt;/string&gt;&#10;    &lt;string name=&quot;chat&quot;&gt;Chat&lt;/string&gt;&#10;    &lt;!-- Nuevos strings para pantallas académicas y asistencia --&gt;&#10;    &lt;string name=&quot;error_label&quot;&gt;Error&lt;/string&gt;&#10;    &lt;string name=&quot;no_tasks_for_today&quot;&gt;No hay tareas para hoy&lt;/string&gt;&#10;    &lt;string name=&quot;promedio_global&quot;&gt;Promedio global&lt;/string&gt;&#10;    &lt;string name=&quot;mes_anterior&quot;&gt;Mes anterior&lt;/string&gt;&#10;    &lt;string name=&quot;mes_siguiente&quot;&gt;Mes siguiente&lt;/string&gt;&#10;    &lt;string name=&quot;asistencia_presente_cd&quot;&gt;Presente&lt;/string&gt;&#10;    &lt;string name=&quot;asistencia_ausente_cd&quot;&gt;Ausente&lt;/string&gt;&#10;    &lt;string name=&quot;asistencia_tarde_cd&quot;&gt;Tarde&lt;/string&gt;&#10;    &lt;string name=&quot;no_new_notifications&quot;&gt;No hay notificaciones nuevas&lt;/string&gt;&#10;    &lt;string name=&quot;no_clases_dia&quot;&gt;No hay clases este día&lt;/string&gt;&#10;    &lt;string name=&quot;aula_label&quot;&gt;Aula&lt;/string&gt;&#10;    &lt;string name=&quot;asistencia_mes_resumen&quot;&gt;Asistencia mes: %1$d%%&lt;/string&gt;&#10;    &lt;string name=&quot;attendance_percentage&quot;&gt;Asistencia: %1$d%%&lt;/string&gt;&#10;    &lt;string name=&quot;welcome_friendly&quot;&gt;¡Qué bueno tenerte aquí!&lt;/string&gt;&#10;    &lt;string name=&quot;login_subtitle_quick&quot;&gt;Inicia sesión rápido y seguro.&lt;/string&gt;&#10;&#10;    &lt;!-- Nuevos strings para pestañas en CalendarScreen --&gt;&#10;    &lt;string name=&quot;schedule&quot;&gt;Horario&lt;/string&gt;&#10;    &lt;string name=&quot;events&quot;&gt;Eventos&lt;/string&gt;&#10;&#10;    &lt;!-- Arrays requeridos --&gt;&#10;    &lt;string-array name=&quot;weekdays_short_full&quot;&gt;&#10;        &lt;item&gt;Lun&lt;/item&gt;&#10;        &lt;item&gt;Mar&lt;/item&gt;&#10;        &lt;item&gt;Mié&lt;/item&gt;&#10;        &lt;item&gt;Jue&lt;/item&gt;&#10;        &lt;item&gt;Vie&lt;/item&gt;&#10;        &lt;item&gt;Sáb&lt;/item&gt;&#10;        &lt;item&gt;Dom&lt;/item&gt;&#10;    &lt;/string-array&gt;&#10;    &lt;string-array name=&quot;weekdays_short&quot;&gt;&#10;        &lt;item&gt;Lun&lt;/item&gt;&#10;        &lt;item&gt;Mar&lt;/item&gt;&#10;        &lt;item&gt;Mié&lt;/item&gt;&#10;        &lt;item&gt;Jue&lt;/item&gt;&#10;        &lt;item&gt;Vie&lt;/item&gt;&#10;        &lt;item&gt;Sáb&lt;/item&gt;&#10;        &lt;item&gt;Dom&lt;/item&gt;&#10;    &lt;/string-array&gt;&#10;&#10;    &lt;!-- Descripción de avatar --&gt;&#10;    &lt;string name=&quot;avatar_de&quot;&gt;Avatar de %1$s&lt;/string&gt;&#10;    &lt;string name=&quot;today&quot;&gt;Hoy&lt;/string&gt;&#10;    &lt;string name=&quot;yesterday&quot;&gt;Ayer&lt;/string&gt;&#10;    &lt;string name=&quot;grupo_label&quot;&gt;Grupo&lt;/string&gt;&#10;    &lt;string name=&quot;registrar_asistencia_transporte_desc&quot;&gt;Registrar asistencia de llegada/salida sin rutas escolares&lt;/string&gt;&#10;    &lt;string name=&quot;empty_notifications&quot;&gt;No hay notificaciones&lt;/string&gt;&#10;    &lt;string name=&quot;new_message&quot;&gt;Nuevo mensaje&lt;/string&gt;&#10;    &lt;string name=&quot;search_by_name_placeholder&quot;&gt;Buscar por nombre…&lt;/string&gt;&#10;&#10;    &lt;!-- Nuevos strings para Dashboard --&gt;&#10;    &lt;string name=&quot;dashboard&quot;&gt;Dashboard&lt;/string&gt;&#10;    &lt;string name=&quot;students&quot;&gt;Estudiantes&lt;/string&gt;&#10;    &lt;string name=&quot;teachers&quot;&gt;Docentes&lt;/string&gt;&#10;    &lt;string name=&quot;panel_admin&quot;&gt;Panel Admin&lt;/string&gt;&#10;    &lt;string name=&quot;admin&quot;&gt;Admin&lt;/string&gt;&#10;    &lt;string name=&quot;groups&quot;&gt;Grupos&lt;/string&gt;&#10;    &lt;string name=&quot;total_users&quot;&gt;Usuarios totales&lt;/string&gt;&#10;&#10;    &lt;!-- Nuevos strings usados en TransportActivity --&gt;&#10;    &lt;string name=&quot;last_attendance_today&quot;&gt;Última asistencia: Hoy a las %1$s (%2$s)&lt;/string&gt;&#10;    &lt;string name=&quot;already_registered_today&quot;&gt;Ya registrado hoy&lt;/string&gt;&#10;    &lt;string name=&quot;already_registered_today_snackbar&quot;&gt;Ya registraste tu asistencia hoy&lt;/string&gt;&#10;    &lt;string name=&quot;select_transport_mode_prompt&quot;&gt;Por favor selecciona un medio de transporte&lt;/string&gt;&#10;    &lt;string name=&quot;attendance_registered_success&quot;&gt;Asistencia registrada exitosamente&lt;/string&gt;&#10;    &lt;string name=&quot;register_error_prefix&quot;&gt;Error al registrar: %1$s&lt;/string&gt;&#10;    &lt;string name=&quot;check_attendance_error_prefix&quot;&gt;Error al verificar asistencia: %1$s&lt;/string&gt;&#10;&#10;    &lt;!-- Nuevos strings para la pantalla de Ubicación del colegio y la clave de Google Maps --&gt;&#10;    &lt;!-- API key para Google Maps (obtenida de google-services.json). Verifica en Google Cloud que la API esté habilitada y aplica restricciones apropiadas --&gt;&#10;    &lt;string name=&quot;google_maps_key&quot;&gt;AIzaSyAKTZmXzTKuEfbyWExNfcTdU34i_Qa6o3U&lt;/string&gt;&#10;    &lt;string name=&quot;ubicacion_colegio&quot;&gt;Ubicación del colegio&lt;/string&gt;&#10;    &lt;string name=&quot;centrar_en_mi&quot;&gt;Centrar en mí&lt;/string&gt;&#10;    &lt;string name=&quot;ir_al_colegio&quot;&gt;Ir al colegio&lt;/string&gt;&#10;    &lt;string name=&quot;activa_ubicacion_para_ruta&quot;&gt;Activa tu ubicación para ver la ruta&lt;/string&gt;&#10;    &lt;string name=&quot;ubicacion_no_disponible&quot;&gt;No pudimos encontrar tu ubicación, pero puedes seguir viendo el colegio en el mapa&lt;/string&gt;&#10;    &lt;!-- EventsActivity strings --&gt;&#10;    &lt;string name=&quot;events_login_required&quot;&gt;Inicia sesión para ver tus eventos&lt;/string&gt;&#10;    &lt;string name=&quot;events_login_snackbar&quot;&gt;Debes iniciar sesión para ver eventos&lt;/string&gt;&#10;    &lt;string name=&quot;events_no_events&quot;&gt;No hay eventos en este período&lt;/string&gt;&#10;    &lt;string name=&quot;events_error_permission&quot;&gt;No tienes permisos para ver estos eventos. Inicia sesión con la cuenta correcta o contacta al administrador.&lt;/string&gt;&#10;    &lt;string name=&quot;action_login&quot;&gt;Iniciar sesión&lt;/string&gt;&#10;    &lt;string name=&quot;events_item_format&quot;&gt;%1$s • %2$s&lt;/string&gt;&#10;&#10;    &lt;!-- Nuevos strings para activity_profile.xml --&gt;&#10;    &lt;string name=&quot;curso_y_grupo&quot;&gt;Curso y Grupo:&lt;/string&gt;&#10;    &lt;string name=&quot;sample_course_group&quot;&gt;10° - Grupo A&lt;/string&gt;&#10;    &lt;string name=&quot;numero_lista&quot;&gt;Nº de lista:&lt;/string&gt;&#10;    &lt;string name=&quot;sample_list_number&quot;&gt;15&lt;/string&gt;&#10;    &lt;string name=&quot;fecha_nacimiento_label&quot;&gt;Fecha de nacimiento:&lt;/string&gt;&#10;    &lt;string name=&quot;sample_birthdate&quot;&gt;01/01/2008&lt;/string&gt;&#10;    &lt;string name=&quot;grupo_sanguineo_label&quot;&gt;Grupo sanguíneo:&lt;/string&gt;&#10;    &lt;string name=&quot;sample_blood_type&quot;&gt;O+&lt;/string&gt;&#10;    &lt;string name=&quot;correo_institucional_full&quot;&gt;Correo institucional:&lt;/string&gt;&#10;    &lt;string name=&quot;sample_email&quot;&gt;estudiante@colegio.edu.co&lt;/string&gt;&#10;    &lt;string name=&quot;acudiente_label&quot;&gt;Acudiente(s):&lt;/string&gt;&#10;    &lt;string name=&quot;sample_guardian&quot;&gt;Nombre del Acudiente&lt;/string&gt;&#10;    &lt;string name=&quot;telefono_label&quot;&gt;Teléfono:&lt;/string&gt;&#10;    &lt;string name=&quot;sample_phone&quot;&gt;300 123 4567&lt;/string&gt;&#10;    &lt;string name=&quot;direccion_label&quot;&gt;Dirección:&lt;/string&gt;&#10;    &lt;string name=&quot;sample_address&quot;&gt;Calle 123 #45–67&lt;/string&gt;&#10;    &lt;string name=&quot;eps_full&quot;&gt;EPS:&lt;/string&gt;&#10;    &lt;string name=&quot;sample_eps&quot;&gt;EPS Salud&lt;/string&gt;&#10;    &lt;string name=&quot;estado_matricula_full&quot;&gt;Estado de matrícula:&lt;/string&gt;&#10;    &lt;string name=&quot;sample_enrollment_status&quot;&gt;Activo&lt;/string&gt;&#10;    &lt;string name=&quot;promedio_label&quot;&gt;Promedio:&lt;/string&gt;&#10;    &lt;string name=&quot;sample_average&quot;&gt;4.5&lt;/string&gt;&#10;&#10;    &lt;!-- Nuevos strings para recuperación de contraseña --&gt;&#10;    &lt;string name=&quot;reset_password_title&quot;&gt;Recuperar contraseña&lt;/string&gt;&#10;    &lt;string name=&quot;reset_password_hint&quot;&gt;Correo electrónico&lt;/string&gt;&#10;    &lt;string name=&quot;reset_password_button&quot;&gt;Enviar correo&lt;/string&gt;&#10;    &lt;string name=&quot;splash_subtitle&quot;&gt;Conectando tu colegio&lt;/string&gt;&#10;    &lt;string name=&quot;role_label&quot;&gt;Rol: %1$s&lt;/string&gt;&#10;    &lt;string name=&quot;role_na&quot;&gt;Rol: N/A&lt;/string&gt;&#10;    &lt;string name=&quot;course_group_format&quot;&gt;%1$s - Grupo %2$s&lt;/string&gt;&#10;&lt;/resources&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#13;&#10;&lt;resources&gt;&#13;&#10;&#13;&#10;    &lt;string name=&quot;app_name&quot;&gt;AppColegios&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;email&quot;&gt;Correo Electrónico&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;password&quot;&gt;Contraseña&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;login&quot;&gt;Iniciar Sesión&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;register&quot;&gt;¿No tienes una cuenta? Regístrate&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;reset_password&quot;&gt;¿Olvidaste tu contraseña?&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;error_invalid_credentials&quot;&gt;Credenciales inválidas&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;account_created&quot;&gt;Cuenta creada. Inicia sesión para continuar.&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;name&quot;&gt;Nombre Completo&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;document&quot;&gt;Documento&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;phone&quot;&gt;Teléfono&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;select_role&quot;&gt;Selecciona tu rol&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;role_student&quot;&gt;Estudiante&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;role_parent&quot;&gt;Padre&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;role_teacher&quot;&gt;Docente&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;create_account&quot;&gt;Crear Cuenta&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;confirm_password&quot;&gt;Confirmar Contraseña&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;passwords_do_not_match&quot;&gt;Las contraseñas no coinciden&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;field_cannot_be_empty&quot;&gt;El campo no puede estar vacío&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;invalid_email&quot;&gt;Correo electrónico inválido&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;password_too_short&quot;&gt;La contraseña debe tener al menos 6 caracteres&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;send_recovery_email&quot;&gt;Enviar correo de recuperación&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;recovery_email_sent&quot;&gt;Se ha enviado un correo de recuperación a tu dirección.&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;error_sending_email&quot;&gt;Error al enviar el correo. Inténtalo de nuevo.&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;back_to_login&quot;&gt;Volver a inicio de sesión&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;network_error&quot;&gt;Error de red&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;network_error_description&quot;&gt;No se pudo conectar. Por favor, revisa tu conexión a internet.&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;retry&quot;&gt;Reintentar&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;logout&quot;&gt;Cerrar Sesión&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;logout_confirmation_title&quot;&gt;Confirmar Cierre de Sesión&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;logout_confirmation_message&quot;&gt;¿Estás seguro de que quieres cerrar sesión?&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;confirm&quot;&gt;Confirmar&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;cancel&quot;&gt;Cancelar&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;home&quot;&gt;Inicio&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;notes&quot;&gt;Notas&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;attendance&quot;&gt;Asistencia&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;tasks&quot;&gt;Tareas&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;calendar&quot;&gt;Calendario&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;notifications&quot;&gt;Notificaciones&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;messages&quot;&gt;Mensajes&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;payments&quot;&gt;Pagos&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;profile&quot;&gt;Perfil&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;my_academic_information&quot;&gt;Mi información académica&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;payments_to_consider&quot;&gt;Pagos a considerar&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;back&quot;&gt;Volver&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;cerrar_sesion&quot;&gt;Cerrar sesión&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;empty_home&quot;&gt;Sin accesos para mostrar.&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;error_generic&quot;&gt;Ha ocurrido un error.&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;greeting&quot;&gt;Hola, %1$s&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;select_student&quot;&gt;Selecciona estudiante&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;select_group&quot;&gt;Selecciona grupo&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;unread_notifications&quot;&gt;Notificaciones no leídas: %1$d&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;unread_messages&quot;&gt;Mensajes no leídos: %1$d&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;no_student_data&quot;&gt;Sin datos del estudiante&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;error_cargando_datos&quot;&gt;Error cargando datos&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;foto_perfil_cd&quot;&gt;Foto de perfil&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;curso_label&quot;&gt;Curso&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;correo_institucional_label&quot;&gt;Correo inst.&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;numero_lista_label&quot;&gt;Nº lista&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;eps_label&quot;&gt;EPS&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;estado_matricula_label&quot;&gt;Estado matrícula&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;my_profile_read_only&quot;&gt;Perfil de solo lectura&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;register_attendance&quot;&gt;Registrar asistencia&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;how_did_you_get_here_today&quot;&gt;¿Cómo llegaste hoy?&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;transporte&quot;&gt;Transporte&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;rutas_no_aplican&quot;&gt;Rutas no aplican&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;write_message_placeholder&quot;&gt;Escribe un mensaje…&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;enviar_mensaje_cd&quot;&gt;Enviar mensaje&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;chat&quot;&gt;Chat&lt;/string&gt;&#13;&#10;    &lt;!-- Nuevos strings para pantallas académicas y asistencia --&gt;&#13;&#10;    &lt;string name=&quot;error_label&quot;&gt;Error&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;no_tasks_for_today&quot;&gt;No hay tareas para hoy&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;promedio_global&quot;&gt;Promedio global&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;mes_anterior&quot;&gt;Mes anterior&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;mes_siguiente&quot;&gt;Mes siguiente&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;asistencia_presente_cd&quot;&gt;Presente&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;asistencia_ausente_cd&quot;&gt;Ausente&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;asistencia_tarde_cd&quot;&gt;Tarde&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;no_new_notifications&quot;&gt;No hay notificaciones nuevas&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;no_clases_dia&quot;&gt;No hay clases este día&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;aula_label&quot;&gt;Aula&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;asistencia_mes_resumen&quot;&gt;Asistencia mes: %1$d%%&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;attendance_percentage&quot;&gt;Asistencia: %1$d%%&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;welcome_friendly&quot;&gt;¡Qué bueno tenerte aquí!&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;login_subtitle_quick&quot;&gt;Inicia sesión rápido y seguro.&lt;/string&gt;&#13;&#10;&#13;&#10;    &lt;!-- Nuevos strings para pestañas en CalendarScreen --&gt;&#13;&#10;    &lt;string name=&quot;schedule&quot;&gt;Horario&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;events&quot;&gt;Eventos&lt;/string&gt;&#13;&#10;&#13;&#10;    &lt;!-- Arrays requeridos --&gt;&#13;&#10;    &lt;string-array name=&quot;weekdays_short_full&quot;&gt;&#13;&#10;        &lt;item&gt;Lun&lt;/item&gt;&#13;&#10;        &lt;item&gt;Mar&lt;/item&gt;&#13;&#10;        &lt;item&gt;Mié&lt;/item&gt;&#13;&#10;        &lt;item&gt;Jue&lt;/item&gt;&#13;&#10;        &lt;item&gt;Vie&lt;/item&gt;&#13;&#10;        &lt;item&gt;Sáb&lt;/item&gt;&#13;&#10;        &lt;item&gt;Dom&lt;/item&gt;&#13;&#10;    &lt;/string-array&gt;&#13;&#10;    &lt;string-array name=&quot;weekdays_short&quot;&gt;&#13;&#10;        &lt;item&gt;Lun&lt;/item&gt;&#13;&#10;        &lt;item&gt;Mar&lt;/item&gt;&#13;&#10;        &lt;item&gt;Mié&lt;/item&gt;&#13;&#10;        &lt;item&gt;Jue&lt;/item&gt;&#13;&#10;        &lt;item&gt;Vie&lt;/item&gt;&#13;&#10;        &lt;item&gt;Sáb&lt;/item&gt;&#13;&#10;        &lt;item&gt;Dom&lt;/item&gt;&#13;&#10;    &lt;/string-array&gt;&#13;&#10;&#13;&#10;    &lt;!-- Descripción de avatar --&gt;&#13;&#10;    &lt;string name=&quot;avatar_de&quot;&gt;Avatar de %1$s&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;today&quot;&gt;Hoy&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;yesterday&quot;&gt;Ayer&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;grupo_label&quot;&gt;Grupo&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;registrar_asistencia_transporte_desc&quot;&gt;Registrar asistencia de llegada/salida sin rutas escolares&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;empty_notifications&quot;&gt;No hay notificaciones&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;new_message&quot;&gt;Nuevo mensaje&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;search_by_name_placeholder&quot;&gt;Buscar por nombre…&lt;/string&gt;&#13;&#10;&#13;&#10;    &lt;!-- Nuevos strings para Dashboard --&gt;&#13;&#10;    &lt;string name=&quot;dashboard&quot;&gt;Dashboard&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;students&quot;&gt;Estudiantes&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;teachers&quot;&gt;Docentes&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;panel_admin&quot;&gt;Panel Admin&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;admin&quot;&gt;Admin&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;groups&quot;&gt;Grupos&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;total_users&quot;&gt;Usuarios totales&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;visual_summary&quot;&gt;Resumen Visual&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;distribution_users&quot;&gt;Distribución usuarios&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;others&quot;&gt;Otros&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;total_count&quot;&gt;Total: %1$d&lt;/string&gt;&#13;&#10;&#13;&#10;    &lt;!-- Nuevos strings usados en TransportActivity --&gt;&#13;&#10;    &lt;string name=&quot;last_attendance_today&quot;&gt;Última asistencia: Hoy a las %1$s (%2$s)&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;already_registered_today&quot;&gt;Ya registrado hoy&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;already_registered_today_snackbar&quot;&gt;Ya registraste tu asistencia hoy&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;select_transport_mode_prompt&quot;&gt;Por favor selecciona un medio de transporte&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;attendance_registered_success&quot;&gt;Asistencia registrada exitosamente&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;register_error_prefix&quot;&gt;Error al registrar: %1$s&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;check_attendance_error_prefix&quot;&gt;Error al verificar asistencia: %1$s&lt;/string&gt;&#13;&#10;&#13;&#10;    &lt;!-- Nuevos strings para la pantalla de Ubicación del colegio y la clave de Google Maps --&gt;&#13;&#10;    &lt;!-- API key para Google Maps (obtenida de google-services.json). Verifica en Google Cloud que la API esté habilitada y aplica restricciones apropiadas --&gt;&#13;&#10;    &lt;string name=&quot;google_maps_key&quot;&gt;AIzaSyAKTZmXzTKuEfbyWExNfcTdU34i_Qa6o3U&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;ubicacion_colegio&quot;&gt;Ubicación del colegio&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;centrar_en_mi&quot;&gt;Centrar en mí&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;ir_al_colegio&quot;&gt;Ir al colegio&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;activa_ubicacion_para_ruta&quot;&gt;Activa tu ubicación para ver la ruta&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;ubicacion_no_disponible&quot;&gt;No pudimos encontrar tu ubicación, pero puedes seguir viendo el colegio en el mapa&lt;/string&gt;&#13;&#10;    &lt;!-- EventsActivity strings --&gt;&#13;&#10;    &lt;string name=&quot;events_login_required&quot;&gt;Inicia sesión para ver tus eventos&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;events_login_snackbar&quot;&gt;Debes iniciar sesión para ver eventos&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;events_no_events&quot;&gt;No hay eventos en este período&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;events_error_permission&quot;&gt;No tienes permisos para ver estos eventos. Inicia sesión con la cuenta correcta o contacta al administrador.&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;action_login&quot;&gt;Iniciar sesión&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;events_item_format&quot;&gt;%1$s • %2$s&lt;/string&gt;&#13;&#10;&#13;&#10;    &lt;!-- Nuevos strings para activity_profile.xml --&gt;&#13;&#10;    &lt;string name=&quot;curso_y_grupo&quot;&gt;Curso y Grupo:&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;sample_course_group&quot;&gt;10° - Grupo A&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;numero_lista&quot;&gt;Nº de lista:&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;sample_list_number&quot;&gt;15&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;fecha_nacimiento_label&quot;&gt;Fecha de nacimiento:&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;sample_birthdate&quot;&gt;01/01/2008&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;grupo_sanguineo_label&quot;&gt;Grupo sanguíneo:&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;sample_blood_type&quot;&gt;O+&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;correo_institucional_full&quot;&gt;Correo institucional:&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;sample_email&quot;&gt;estudiante@colegio.edu.co&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;acudiente_label&quot;&gt;Acudiente(s):&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;sample_guardian&quot;&gt;Nombre del Acudiente&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;telefono_label&quot;&gt;Teléfono:&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;sample_phone&quot;&gt;300 123 4567&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;direccion_label&quot;&gt;Dirección:&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;sample_address&quot;&gt;Calle 123 #45–67&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;eps_full&quot;&gt;EPS:&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;sample_eps&quot;&gt;EPS Salud&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;estado_matricula_full&quot;&gt;Estado de matrícula:&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;sample_enrollment_status&quot;&gt;Activo&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;promedio_label&quot;&gt;Promedio:&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;sample_average&quot;&gt;4.5&lt;/string&gt;&#13;&#10;&#13;&#10;    &lt;!-- Nuevos strings para recuperación de contraseña --&gt;&#13;&#10;    &lt;string name=&quot;reset_password_title&quot;&gt;Recuperar contraseña&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;reset_password_hint&quot;&gt;Correo electrónico&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;reset_password_button&quot;&gt;Enviar correo&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;splash_subtitle&quot;&gt;Conectando tu colegio&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;role_label&quot;&gt;Rol: %1$s&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;role_na&quot;&gt;Rol: N/A&lt;/string&gt;&#13;&#10;    &lt;string name=&quot;course_group_format&quot;&gt;%1$s - Grupo %2$s&lt;/string&gt;&#13;&#10;&lt;/resources&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>