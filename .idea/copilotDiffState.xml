<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/SOLUCION_DEFINITIVA.bat">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/SOLUCION_DEFINITIVA.bat" />
              <option name="updatedContent" value="@echo off&#10;echo ==========================================&#10;echo SOLUCION DEFINITIVA - ERROR GRADLE TASKS&#10;echo ==========================================&#10;cd /d &quot;%~dp0&quot;&#10;&#10;echo.&#10;echo Este script resolvera: &quot;Unable to find Gradle tasks to build&quot;&#10;echo.&#10;pause&#10;&#10;echo.&#10;echo [1/8] Cerrando Android Studio si esta abierto...&#10;echo Por favor, CIERRA Android Studio ahora si esta abierto.&#10;echo.&#10;pause&#10;&#10;echo.&#10;echo [2/8] Deteniendo procesos de Gradle...&#10;call gradlew.bat --stop&#10;timeout /t 3 /nobreak &gt; nul&#10;&#10;echo.&#10;echo [3/8] Eliminando cache del proyecto...&#10;if exist .gradle rmdir /s /q .gradle&#10;if exist .idea rmdir /s /q .idea&#10;if exist .kotlin rmdir /s /q .kotlin&#10;if exist build rmdir /s /q build&#10;if exist app\build rmdir /s /q app\build&#10;&#10;echo.&#10;echo [4/8] Eliminando archivos de configuracion del IDE...&#10;if exist *.iml del /q *.iml&#10;if exist app\*.iml del /q app\*.iml&#10;&#10;echo.&#10;echo [5/8] Limpiando con Gradle...&#10;call gradlew.bat clean&#10;&#10;echo.&#10;echo [6/8] Verificando estructura del proyecto...&#10;call gradlew.bat projects&#10;&#10;echo.&#10;echo [7/8] Listando tareas disponibles...&#10;call gradlew.bat tasks&#10;&#10;echo.&#10;echo [8/8] Compilando el proyecto...&#10;call gradlew.bat assembleDebug&#10;&#10;echo.&#10;echo ==========================================&#10;echo COMPLETADO!&#10;echo ==========================================&#10;echo.&#10;echo Ahora ABRE Android Studio y:&#10;echo 1. Abre este proyecto&#10;echo 2. File ^&gt; Sync Project with Gradle Files&#10;echo 3. Build ^&gt; Rebuild Project&#10;echo.&#10;echo El error deberia estar resuelto.&#10;echo ==========================================&#10;pause&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/appcolegios/academico/CalendarScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/appcolegios/academico/CalendarScreen.kt" />
              <option name="originalContent" value="package com.example.appcolegios.academico&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.gestures.detectHorizontalDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.grid.GridCells&#10;import androidx.compose.foundation.lazy.grid.LazyVerticalGrid&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import kotlinx.coroutines.launch&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.appcolegios.perfil.ProfileViewModel&#10;import com.example.appcolegios.data.UserPreferencesRepository&#10;import com.example.appcolegios.data.UserData&#10;import com.example.appcolegios.data.model.Role&#10;import androidx.compose.ui.platform.LocalContext&#10;import android.util.Log&#10;import com.google.firebase.Timestamp&#10;import com.google.firebase.firestore.ListenerRegistration&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.animation.AnimatedContent&#10;import androidx.compose.animation.ExperimentalAnimationApi&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.animation.slideInHorizontally&#10;import androidx.compose.animation.slideOutHorizontally&#10;import androidx.compose.animation.togetherWith&#10;import androidx.compose.material.icons.automirrored.filled.Assignment&#10;import androidx.compose.material.icons.automirrored.filled.EventNote&#10;import androidx.compose.runtime.key&#10;import java.time.Instant&#10;import java.time.LocalDate&#10;import java.time.ZoneId&#10;import java.time.temporal.WeekFields&#10;import com.google.firebase.firestore.DocumentSnapshot&#10;import java.util.Locale&#10;&#10;enum class EventSource { USER, GLOBAL }&#10;&#10;data class CalendarEvent(&#10;    val id: String,&#10;    val title: String,&#10;    val description: String,&#10;    val date: Date,&#10;    val type: EventType,&#10;    val source: EventSource = EventSource.USER,&#10;    val ownerId: String? = null // for USER -&gt; userId; for GLOBAL -&gt; courseId or owner&#10;)&#10;&#10;enum class EventType {&#10;    CLASE, EXAMEN, TAREA, EVENTO&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class, ExperimentalAnimationApi::class)&#10;@Composable&#10;fun CalendarScreen() {&#10;    // Separamos mes mostrado y fecha seleccionada&#10;    var displayedMonth by remember { mutableStateOf(Calendar.getInstance()) }&#10;    var selectedDay by remember { mutableStateOf&lt;Calendar?&gt;(Calendar.getInstance()) }&#10;    var showAddEventDialog by remember { mutableStateOf(false) }&#10;    val context = LocalContext.current&#10;&#10;    // Eventos para el mes mostrado (se cargan por rango mediante snapshot listener)&#10;    val events = remember { mutableStateListOf&lt;CalendarEvent&gt;() }&#10;    val auth = FirebaseAuth.getInstance()&#10;    val db = FirebaseFirestore.getInstance()&#10;    // user role and preferences&#10;    val userPrefs = remember { UserPreferencesRepository(context) }&#10;    val userData by userPrefs.userData.collectAsState(initial = UserData(null, null, null))&#10;    val role = userData.roleEnum&#10;    // courses for teacher/student/child selection&#10;    val userCourses = remember { mutableStateListOf&lt;Pair&lt;String,String&gt;&gt;() }&#10;    // Próximos eventos paginados y filtro por tipo&#10;    val upcomingEvents = remember { mutableStateListOf&lt;CalendarEvent&gt;() }&#10;    var upcomingLastSnapshot by remember { mutableStateOf&lt;DocumentSnapshot?&gt;(null) }&#10;    var selectedFilterType by remember { mutableStateOf&lt;EventType?&gt;(null) }&#10;&#10;    // Estado del bottom sheet para mostrar eventos del día seleccionado&#10;    var bottomSheetVisible by remember { mutableStateOf(false) }&#10;&#10;    // Estados para edición / borrado (deben existir para las acciones de la lista y bottom sheet)&#10;    var editingEvent by remember { mutableStateOf&lt;CalendarEvent?&gt;(null) }&#10;    var showEditEventDialog by remember { mutableStateOf(false) }&#10;    var eventToDelete by remember { mutableStateOf&lt;CalendarEvent?&gt;(null) }&#10;    var showDeleteConfirm by remember { mutableStateOf(false) }&#10;&#10;    // Profile VM: para padres (lista de hijos)&#10;    val profileVm: ProfileViewModel = viewModel()&#10;    val children by profileVm.children.collectAsState()&#10;    var selectedChildIndex by remember { mutableStateOf(0) }&#10;&#10;    // Listener registration manejado con DisposableEffect: soporta múltiples listeners según rol&#10;    DisposableEffect(displayedMonth.timeInMillis, auth.currentUser?.uid, role, selectedChildIndex) {&#10;        val userId = auth.currentUser?.uid&#10;        val regs = mutableListOf&lt;ListenerRegistration&gt;()&#10;        events.clear()&#10;&#10;        if (userId != null) {&#10;            // calcular primer y ultimo día del mes mostrado&#10;            val start = (displayedMonth.clone() as Calendar).apply {&#10;                set(Calendar.DAY_OF_MONTH, 1)&#10;                set(Calendar.HOUR_OF_DAY, 0)&#10;                set(Calendar.MINUTE, 0)&#10;                set(Calendar.SECOND, 0)&#10;                set(Calendar.MILLISECOND, 0)&#10;            }&#10;            val end = (displayedMonth.clone() as Calendar).apply {&#10;                set(Calendar.DAY_OF_MONTH, getActualMaximum(Calendar.DAY_OF_MONTH))&#10;                set(Calendar.HOUR_OF_DAY, 23)&#10;                set(Calendar.MINUTE, 59)&#10;                set(Calendar.SECOND, 59)&#10;                set(Calendar.MILLISECOND, 999)&#10;            }&#10;            val startTs = Timestamp(start.time)&#10;            val endTs = Timestamp(end.time)&#10;&#10;            try {&#10;                // 1) listener to personal events of the viewed user (teacher sees own personal too)&#10;                val personalListener = db.collection(&quot;users&quot;).document(userId).collection(&quot;events&quot;)&#10;                    .whereGreaterThanOrEqualTo(&quot;date&quot;, startTs)&#10;                    .whereLessThanOrEqualTo(&quot;date&quot;, endTs)&#10;                    .addSnapshotListener { snap, e -&gt;&#10;                        if (e != null) { Log.e(&quot;CalendarScreen&quot;, &quot;Personal listener error: ${e.message}&quot;); return@addSnapshotListener }&#10;                        if (snap != null) {&#10;                            for (doc in snap.documents) {&#10;                                val id = doc.id&#10;                                val title = doc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                                val description = doc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                                val ts = doc.get(&quot;date&quot;)&#10;                                val d = when (ts) { is Timestamp -&gt; ts.toDate(); is Date -&gt; ts; else -&gt; null }&#10;                                val type = try { EventType.valueOf(doc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                                if (d != null &amp;&amp; events.none { it.id == id }) events.add(CalendarEvent(id, title, description, d, type, EventSource.USER, userId))&#10;                                val rec = doc.getString(&quot;recurrence&quot;)&#10;                                if (!rec.isNullOrBlank() &amp;&amp; d != null) {&#10;                                    try { val occ = generateOccurrences(d, rec, start.time, end.time); occ.forEachIndexed { idx, occDate -&gt; if (events.none { it.id == &quot;${id}_occ_$idx&quot; }) events.add(CalendarEvent(&quot;${id}_occ_$idx&quot;, title, description, occDate, type, EventSource.USER, userId)) } } catch (_: Exception) {}&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                regs.add(personalListener)&#10;&#10;                // 2) role-specific: teacher -&gt; events for their courses; student -&gt; events for courses enrolled; parent -&gt; events for selected child&#10;                when (role) {&#10;                    Role.DOCENTE -&gt; {&#10;                        // get course ids taught by teacher&#10;                        val courseIds = mutableListOf&lt;String&gt;()&#10;                        try {&#10;                            val q = db.collection(&quot;courses&quot;).whereEqualTo(&quot;teacherId&quot;, userId).get()&#10;                            q.addOnSuccessListener { snap -&gt;&#10;                                userCourses.clear()&#10;                                for (doc in snap.documents) {&#10;                                    val cid = doc.id&#10;                                    courseIds.add(cid)&#10;                                    val cname = doc.getString(&quot;name&quot;) ?: doc.getString(&quot;title&quot;) ?: cid&#10;                                    userCourses.add(Pair(cid, cname))&#10;                                }&#10;                                // query top-level events where courseId in courseIds, chunked by 10&#10;                                if (courseIds.isNotEmpty()) {&#10;                                    courseIds.chunked(10).forEach { chunk -&gt;&#10;                                        val evQuery = db.collection(&quot;events&quot;).whereIn(&quot;courseId&quot;, chunk).whereGreaterThanOrEqualTo(&quot;date&quot;, startTs).whereLessThanOrEqualTo(&quot;date&quot;, endTs)&#10;                                        val r = evQuery.addSnapshotListener { snap2, e2 -&gt;&#10;                                            if (e2 != null) { Log.e(&quot;CalendarScreen&quot;,&quot;Course events listener err: ${e2.message}&quot;); return@addSnapshotListener }&#10;                                            if (snap2 != null) {&#10;                                                for (doc in snap2.documents) {&#10;                                                    val id = doc.id&#10;                                                    val title = doc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                                                    val description = doc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                                                    val ts = doc.get(&quot;date&quot;)&#10;                                                    val d = when (ts) { is Timestamp -&gt; ts.toDate(); is Date -&gt; ts; else -&gt; null }&#10;                                                    val type = try { EventType.valueOf(doc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                                                    if (d != null &amp;&amp; events.none { it.id == id }) events.add(CalendarEvent(id, title, description, d, type, EventSource.GLOBAL, null))&#10;                                                }&#10;                                            }&#10;                                        }&#10;                                        regs.add(r)&#10;                                    }&#10;                                }&#10;                            }&#10;                        } catch (_: Exception) { }&#10;                    }&#10;                    Role.ESTUDIANTE -&gt; {&#10;                        // student: read student doc for courses&#10;                        try {&#10;                            val sdocTask = db.collection(&quot;students&quot;).document(userId).get()&#10;                            sdocTask.addOnSuccessListener { sdoc -&gt;&#10;                                val courseIds = (sdoc.get(&quot;courses&quot;) as? List&lt;*&gt;)?.mapNotNull { it?.toString() } ?: emptyList()&#10;                                // populate userCourses with names&#10;                                userCourses.clear()&#10;                                for (cid in courseIds) {&#10;                                    db.collection(&quot;courses&quot;).document(cid).get().addOnSuccessListener { cdoc -&gt;&#10;                                        if (cdoc.exists()) userCourses.add(Pair(cid, cdoc.getString(&quot;name&quot;) ?: cid))&#10;                                    }&#10;                                }&#10;                                if (courseIds.isNotEmpty()) {&#10;                                    courseIds.chunked(10).forEach { chunk -&gt;&#10;                                        val evQuery = db.collection(&quot;events&quot;).whereIn(&quot;courseId&quot;, chunk).whereGreaterThanOrEqualTo(&quot;date&quot;, startTs).whereLessThanOrEqualTo(&quot;date&quot;, endTs)&#10;                                        val r = evQuery.addSnapshotListener { snap2, e2 -&gt;&#10;                                            if (e2 != null) return@addSnapshotListener&#10;                                            if (snap2 != null) {&#10;                                                for (doc in snap2.documents) {&#10;                                                    val id = doc.id&#10;                                                    val title = doc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                                                    val description = doc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                                                    val ts = doc.get(&quot;date&quot;)&#10;                                                    val d = when (ts) { is Timestamp -&gt; ts.toDate(); is Date -&gt; ts; else -&gt; null }&#10;                                                    val type = try { EventType.valueOf(doc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                                                    if (d != null &amp;&amp; events.none { it.id == id }) events.add(CalendarEvent(id, title, description, d, type, EventSource.GLOBAL, null))&#10;                                                }&#10;                                            }&#10;                                        }&#10;                                        regs.add(r)&#10;                                    }&#10;                                }&#10;                            }&#10;                        } catch (_: Exception) { }&#10;                    }&#10;                    Role.PADRE -&gt; {&#10;                        // parent: use selected child&#10;                        val childId = children.getOrNull(selectedChildIndex)?.id&#10;                        if (!childId.isNullOrBlank()) {&#10;                            // personal events of child&#10;                            val childListener = db.collection(&quot;users&quot;).document(childId).collection(&quot;events&quot;)&#10;                                .whereGreaterThanOrEqualTo(&quot;date&quot;, startTs)&#10;                                .whereLessThanOrEqualTo(&quot;date&quot;, endTs)&#10;                                .addSnapshotListener { snap, e -&gt;&#10;                                    if (e != null) { Log.e(&quot;CalendarScreen&quot;, &quot;Child listener error: ${e.message}&quot;); return@addSnapshotListener }&#10;                                    if (snap != null) {&#10;                                        for (doc in snap.documents) {&#10;                                            val id = doc.id&#10;                                            val title = doc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                                            val description = doc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                                            val ts = doc.get(&quot;date&quot;)&#10;                                            val d = when (ts) { is Timestamp -&gt; ts.toDate(); is Date -&gt; ts; else -&gt; null }&#10;                                            val type = try { EventType.valueOf(doc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                                            if (d != null &amp;&amp; events.none { it.id == id }) events.add(CalendarEvent(id, title, description, d, type, EventSource.USER, childId))&#10;                                        }&#10;                                    }&#10;                                }&#10;                            regs.add(childListener)&#10;&#10;                            // also load course events for that child (like student)&#10;                            try {&#10;                                val sdocTask = db.collection(&quot;students&quot;).document(childId).get()&#10;                                sdocTask.addOnSuccessListener { sdoc -&gt;&#10;                                    val courseIds = (sdoc.get(&quot;courses&quot;) as? List&lt;*&gt;)?.mapNotNull { it?.toString() } ?: emptyList()&#10;                                    if (courseIds.isNotEmpty()) {&#10;                                        courseIds.chunked(10).forEach { chunk -&gt;&#10;                                            val evQuery = db.collection(&quot;events&quot;).whereIn(&quot;courseId&quot;, chunk).whereGreaterThanOrEqualTo(&quot;date&quot;, startTs).whereLessThanOrEqualTo(&quot;date&quot;, endTs)&#10;                                            val r = evQuery.addSnapshotListener { snap2, e2 -&gt;&#10;                                                if (e2 != null) { Log.e(&quot;CalendarScreen&quot;, &quot;Child course events listener err: ${e2.message}&quot;); return@addSnapshotListener }&#10;                                                if (snap2 != null) {&#10;                                                    for (doc in snap2.documents) {&#10;                                                        val id = doc.id&#10;                                                        val title = doc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                                                        val description = doc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                                                        val ts = doc.get(&quot;date&quot;)&#10;                                                        val d = when (ts) { is Timestamp -&gt; ts.toDate(); is Date -&gt; ts; else -&gt; null }&#10;                                                        val type = try { EventType.valueOf(doc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                                                        if (d != null &amp;&amp; events.none { it.id == id }) events.add(CalendarEvent(id, title, description, d, type, EventSource.GLOBAL, doc.getString(&quot;courseId&quot;)))&#10;                                                    }&#10;                                                }&#10;                                            }&#10;                                            regs.add(r)&#10;                                        }&#10;                                    }&#10;                                }&#10;                            } catch (_: Exception) {}&#10;                        }&#10;                    }&#10;                    else -&gt; {&#10;                        // default: no extra listeners&#10;                    }&#10;                }&#10;            } catch (ex: Exception) {&#10;                Log.e(&quot;CalendarScreen&quot;, &quot;Error starting listeners: ${ex.message}&quot;, ex)&#10;            }&#10;        }&#10;&#10;        onDispose {&#10;            regs.forEach { try { it.remove() } catch (_: Exception) {} }&#10;        }&#10;    }&#10;&#10;    // Snackbar / scaffold&#10;    val snackbarHostState = remember { SnackbarHostState() }&#10;    val scope = rememberCoroutineScope()&#10;&#10;    Scaffold(&#10;        snackbarHost = { SnackbarHost(hostState = snackbarHostState) }&#10;    ) { innerPadding -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(innerPadding)&#10;                .padding(16.dp)&#10;        ) {&#10;            // Header con mes actual&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                IconButton(onClick = {&#10;                    displayedMonth = (displayedMonth.clone() as Calendar).apply { add(Calendar.MONTH, -1) }&#10;                }) {&#10;                    Icon(Icons.Filled.ChevronLeft, contentDescription = &quot;Mes anterior&quot;)&#10;                }&#10;&#10;                Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                    Text(&#10;                        text = SimpleDateFormat(&quot;MMMM yyyy&quot;, Locale.getDefault()).format(displayedMonth.time),&#10;                        style = MaterialTheme.typography.titleLarge,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;                    TextButton(onClick = { // volver a hoy&#10;                        displayedMonth = Calendar.getInstance()&#10;                        selectedDay = Calendar.getInstance()&#10;                    }) { Text(&quot;Hoy&quot;) }&#10;&#10;                    // selector de hijo para PADRE&#10;                    if (role == Role.PADRE) {&#10;                        Spacer(Modifier.height(8.dp))&#10;                        Row(verticalAlignment = Alignment.CenterVertically) {&#10;                            Text(&quot;Hijo: &quot;)&#10;                            if (children.isEmpty()) {&#10;                                Text(&quot;(sin hijos)&quot;)&#10;                            } else {&#10;                                var expanded by remember { mutableStateOf(false) }&#10;                                val label = children.getOrNull(selectedChildIndex)?.nombre ?: &quot;Seleccionar&quot;&#10;                                Box {&#10;                                    TextButton(onClick = { expanded = true }) { Text(label) }&#10;                                    DropdownMenu(expanded = expanded, onDismissRequest = { expanded = false }) {&#10;                                        children.forEachIndexed { idx, child -&gt;&#10;                                            DropdownMenuItem(text = { Text(child.nombre) }, onClick = { selectedChildIndex = idx; expanded = false })&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                IconButton(onClick = {&#10;                    displayedMonth = (displayedMonth.clone() as Calendar).apply { add(Calendar.MONTH, 1) }&#10;                }) {&#10;                    Icon(Icons.Filled.ChevronRight, contentDescription = &quot;Mes siguiente&quot;)&#10;                }&#10;            }&#10;&#10;            Spacer(Modifier.height(16.dp))&#10;&#10;            // Días de la semana -- respetar locale (primer día simplificado)&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceEvenly&#10;            ) {&#10;                // Obtener nombres de días desde locale&#10;                val df = SimpleDateFormat(&quot;EE&quot;, Locale.getDefault())&#10;                val headerCal = Calendar.getInstance()&#10;                // usar firstDayOfWeek del locale&#10;                val firstDow = headerCal.firstDayOfWeek&#10;                for (i in 0 until 7) {&#10;                    headerCal.set(Calendar.DAY_OF_WEEK, (firstDow + i - 1) % 7 + 1)&#10;                    Text(&#10;                        text = df.format(headerCal.time),&#10;                        modifier = Modifier.weight(1f),&#10;                        textAlign = TextAlign.Center,&#10;                        style = MaterialTheme.typography.labelMedium,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = MaterialTheme.colorScheme.primary&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(Modifier.height(8.dp))&#10;&#10;            // Grid del calendario con fecha seleccionada y soporte swipe/anim&#10;            Box(modifier = Modifier&#10;                .fillMaxWidth()&#10;                .height(320.dp)&#10;                .pointerInput(Unit) {&#10;                    detectHorizontalDragGestures { change, dragAmount -&gt;&#10;                        val threshold = 150&#10;                        if (dragAmount &gt; threshold) {&#10;                            // swipe derecha -&gt; mes anterior&#10;                            displayedMonth = (displayedMonth.clone() as Calendar).apply { add(Calendar.MONTH, -1) }&#10;                        } else if (dragAmount &lt; -threshold) {&#10;                            // swipe izquierda -&gt; mes siguiente&#10;                            displayedMonth = (displayedMonth.clone() as Calendar).apply { add(Calendar.MONTH, 1) }&#10;                        }&#10;                    }&#10;                }&#10;            ) {&#10;                AnimatedContent(targetState = displayedMonth.timeInMillis, transitionSpec = {&#10;                    slideInHorizontally(initialOffsetX = { fullWidth -&gt; if (targetState &gt; initialState) fullWidth else -fullWidth }, animationSpec = tween(300))&#10;                        .togetherWith(&#10;                            slideOutHorizontally(targetOffsetX = { fullWidth -&gt; if (targetState &gt; initialState) -fullWidth else fullWidth }, animationSpec = tween(300))&#10;                        )&#10;                }) { ts -&gt;&#10;                       key(ts) {&#10;                           CalendarGrid(&#10;                               displayedMonth = displayedMonth,&#10;                               selectedDay = selectedDay,&#10;                               events = events,&#10;                               onDateSelected = { cal -&gt;&#10;                                   selectedDay = cal&#10;                                   bottomSheetVisible = true&#10;                               }&#10;                           )&#10;                       }&#10;                   }&#10;             }&#10;&#10;            Spacer(Modifier.height(16.dp))&#10;&#10;            // Botón para agregar evento&#10;            Button(&#10;                onClick = { showAddEventDialog = true },&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Icon(Icons.Filled.Add, contentDescription = &quot;Agregar evento&quot;)&#10;                Spacer(Modifier.width(8.dp))&#10;                Text(&quot;Agregar Evento&quot;)&#10;            }&#10;&#10;            Spacer(Modifier.height(16.dp))&#10;&#10;            // Lista de próximos eventos (paginated) con filtro por tipo&#10;            Text(&#10;                &quot;Próximos Eventos&quot;,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;&#10;            Spacer(Modifier.height(8.dp))&#10;&#10;            // Filtro por tipo&#10;            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                Text(&quot;Filtrar: &quot;)&#10;                Spacer(Modifier.width(8.dp))&#10;                // botones simples para filtrar por tipo&#10;                EventType.entries.let { types -&gt;&#10;                    types.forEach { t -&gt;&#10;                         val selected = selectedFilterType == t&#10;                         TextButton(onClick = { selectedFilterType = if (selected) null else t }) {&#10;                             Text(t.name, color = if (selected) MaterialTheme.colorScheme.onPrimary else MaterialTheme.colorScheme.onSurface)&#10;                         }&#10;                     }&#10;                 }&#10;            }&#10;&#10;            Spacer(Modifier.height(8.dp))&#10;&#10;            // carga inicial de upcoming en background (no duplicar si ya cargado)&#10;            LaunchedEffect(auth.currentUser?.uid) {&#10;                upcomingEvents.clear()&#10;                upcomingLastSnapshot = null&#10;                // pasar los courseIds disponibles (si ya se cargaron) para traer también eventos globales&#10;                val courseIds = userCourses.map { it.first }&#10;                loadMoreUpcoming(db, auth, upcomingEvents, courseIds) { doc -&gt; upcomingLastSnapshot = doc }&#10;            }&#10;&#10;            val displayedUpcoming = if (selectedFilterType == null) upcomingEvents.toList() else upcomingEvents.filter { it.type == selectedFilterType }&#10;&#10;            LazyColumn(&#10;                 verticalArrangement = Arrangement.spacedBy(8.dp)&#10;             ) {&#10;                items(displayedUpcoming) { event -&gt;&#10;                    // per-event permissions: owner can edit/delete USER events; DOCENTE can edit/delete GLOBAL events&#10;                    val uid = auth.currentUser?.uid&#10;                    val allowEdit = when (event.source) {&#10;                        EventSource.USER -&gt; event.ownerId == uid&#10;                        EventSource.GLOBAL -&gt; role == Role.DOCENTE&#10;                    }&#10;                    val allowDelete = allowEdit&#10;                    EventCard(event,&#10;                        onEdit = if (allowEdit) { ev -&gt; editingEvent = ev; showEditEventDialog = true } else null,&#10;                        onDelete = if (allowDelete) { ev -&gt; eventToDelete = ev; showDeleteConfirm = true } else null&#10;                    )&#10;                }&#10;                item {&#10;                    Spacer(Modifier.height(6.dp))&#10;                    Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.Center) {&#10;                        val courseIds = userCourses.map { it.first }&#10;                        if (upcomingLastSnapshot != null) {&#10;                            Button(onClick = { loadMoreUpcoming(db, auth, upcomingEvents, courseIds) { doc -&gt; upcomingLastSnapshot = doc } }) { Text(&quot;Cargar más&quot;) }&#10;                        }&#10;                    }&#10;                 }&#10;             }&#10;         }&#10;     }&#10;&#10;    // Bottom sheet para eventos del día seleccionado (simple Modal)&#10;    if (bottomSheetVisible &amp;&amp; selectedDay != null) {&#10;        val selLocal = LocalDate.of(selectedDay!!.get(Calendar.YEAR), selectedDay!!.get(Calendar.MONTH)+1, selectedDay!!.get(Calendar.DAY_OF_MONTH))&#10;        val dayEvents = events.filter { ev -&gt;&#10;            val evLocal = Instant.ofEpochMilli(ev.date.time).atZone(ZoneId.systemDefault()).toLocalDate()&#10;            evLocal == selLocal&#10;        }.sortedBy { it.date }&#10;&#10;        ModalBottomSheet(&#10;            onDismissRequest = { bottomSheetVisible = false }&#10;        ) {&#10;            Column(modifier = Modifier.padding(16.dp)) {&#10;                Text(&quot;Eventos en ${SimpleDateFormat(&quot;dd/MM/yyyy&quot;, Locale.getDefault()).format(selectedDay!!.time)}&quot;, style = MaterialTheme.typography.titleMedium, fontWeight = FontWeight.Bold)&#10;                Spacer(Modifier.height(8.dp))&#10;                if (dayEvents.isEmpty()) {&#10;                    Text(&quot;No hay eventos para este día&quot;, color = MaterialTheme.colorScheme.onSurfaceVariant)&#10;                } else {&#10;                    dayEvents.forEach { ev -&gt;&#10;                        val uid = auth.currentUser?.uid&#10;                        val allowEdit = when (ev.source) {&#10;                            EventSource.USER -&gt; ev.ownerId == uid&#10;                            EventSource.GLOBAL -&gt; role == Role.DOCENTE&#10;                        }&#10;                        val allowDelete = allowEdit&#10;                        EventCard(ev,&#10;                            onEdit = if (allowEdit) { e -&gt; editingEvent = e; showEditEventDialog = true } else null,&#10;                            onDelete = if (allowDelete) { e -&gt; eventToDelete = e; showDeleteConfirm = true } else null&#10;                        )&#10;                        Spacer(Modifier.height(8.dp))&#10;                    }&#10;                }&#10;                Spacer(Modifier.height(8.dp))&#10;                Row(horizontalArrangement = Arrangement.End, modifier = Modifier.fillMaxWidth()) {&#10;                    TextButton(onClick = { bottomSheetVisible = false }) { Text(&quot;Cerrar&quot;) }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    if (showAddEventDialog) {&#10;        AddEventDialog(&#10;            initialDate = selectedDay?.time ?: displayedMonth.time,&#10;            onDismiss = { showAddEventDialog = false },&#10;            onSave = { title, description, date, type, targetCourseId -&gt;&#10;                val userId = auth.currentUser?.uid&#10;                if (userId == null) {&#10;                    scope.launch { snackbarHostState.showSnackbar(&quot;Debes iniciar sesión para agregar eventos&quot;) }&#10;                    return@AddEventDialog&#10;                }&#10;                val db = FirebaseFirestore.getInstance()&#10;                val eventId = UUID.randomUUID().toString()&#10;                val eventData = hashMapOf&lt;String, Any?&gt;(&#10;                    &quot;id&quot; to eventId,&#10;                    &quot;title&quot; to title,&#10;                    &quot;description&quot; to description,&#10;                    &quot;date&quot; to Timestamp(date),&#10;                    &quot;type&quot; to type.name,&#10;                    &quot;createdAt&quot; to Timestamp.now(),&#10;                    &quot;ownerId&quot; to userId&#10;                )&#10;                // If teacher selected a course target, save as global event in top-level collection&#10;                if (role == Role.DOCENTE &amp;&amp; !targetCourseId.isNullOrBlank()) {&#10;                    eventData[&quot;courseId&quot;] = targetCourseId&#10;                    db.collection(&quot;events&quot;).document(eventId)&#10;                        .set(eventData)&#10;                        .addOnSuccessListener {&#10;                            events.add(CalendarEvent(eventId, title, description, date, type, EventSource.GLOBAL, targetCourseId))&#10;                            showAddEventDialog = false&#10;                            scope.launch { snackbarHostState.showSnackbar(&quot;Evento de curso agregado&quot;) }&#10;&#10;                            // Crear notificaciones para estudiantes del curso (solo si el creador no es estudiante)&#10;                            try {&#10;                                // obtener estudiantes desde subcolección courses/{courseId}/students&#10;                                val tcid = targetCourseId&#10;                                if (!tcid.isNullOrBlank()) {&#10;                                    db.collection(&quot;courses&quot;).document(tcid).collection(&quot;students&quot;).get()&#10;                                        .addOnSuccessListener { studsSnap -&gt;&#10;                                            val studentIds = if (!studsSnap.isEmpty) studsSnap.documents.mapNotNull { it.id } else emptyList()&#10;                                            if (studentIds.isEmpty()) {&#10;                                                // fallback: si no hay subcoleccion, intentar buscar en students collection por courseId&#10;                                                db.collection(&quot;students&quot;).whereEqualTo(&quot;courseId&quot;, tcid).get()&#10;                                                    .addOnSuccessListener { altSnap -&gt;&#10;                                                        val altIds = altSnap.documents.mapNotNull { it.id }&#10;                                                        // resolver senderName y crear notifs&#10;                                                        resolveAndCreateNotifs(altIds, title, description, eventId, db, auth)&#10;                                                    }&#10;                                            } else {&#10;                                                resolveAndCreateNotifs(studentIds, title, description, eventId, db, auth)&#10;                                            }&#10;                                        }&#10;                                }&#10;                            } catch (e: Exception) {&#10;                                Log.w(&quot;CalendarScreen&quot;, &quot;Error creando notificaciones de curso: ${e.message}&quot;)&#10;                            }&#10;                        }&#10;                        .addOnFailureListener { e -&gt;&#10;                            Log.e(&quot;CalendarScreen&quot;, &quot;Error saving global event: ${e.message}&quot;, e)&#10;                            scope.launch { snackbarHostState.showSnackbar(&quot;Error guardando evento&quot;) }&#10;                        }&#10;                } else {&#10;                    // save personal event under users/{uid}/events&#10;                    db.collection(&quot;users&quot;).document(userId).collection(&quot;events&quot;).document(eventId)&#10;                        .set(eventData)&#10;                        .addOnSuccessListener {&#10;                            events.add(CalendarEvent(eventId, title, description, date, type, EventSource.USER, userId))&#10;                            showAddEventDialog = false&#10;                            scope.launch { snackbarHostState.showSnackbar(&quot;Evento agregado&quot;) }&#10;                        }&#10;                        .addOnFailureListener { e -&gt;&#10;                            Log.e(&quot;CalendarScreen&quot;, &quot;Error saving personal event: ${e.message}&quot;, e)&#10;                            scope.launch { snackbarHostState.showSnackbar(&quot;Error guardando evento&quot;) }&#10;                        }&#10;                }&#10;            },&#10;            role = role,&#10;            userCourses = userCourses.toList()&#10;        )&#10;    }&#10;&#10;    // handle actual deletion when confirmed&#10;    if (showDeleteConfirm &amp;&amp; eventToDelete != null) {&#10;        AlertDialog(onDismissRequest = { showDeleteConfirm = false; eventToDelete = null }, title = { Text(&quot;Confirmar eliminación&quot;) }, text = { Text(&quot;Eliminar evento '${eventToDelete!!.title}'?&quot;) }, confirmButton = {&#10;            TextButton(onClick = {&#10;                val uid = auth.currentUser?.uid ?: run { showDeleteConfirm = false; eventToDelete = null; return@TextButton }&#10;                val ev = eventToDelete&#10;                if (ev == null) return@TextButton&#10;                if (ev.source == EventSource.USER) {&#10;                    // delete under owner user's events&#10;                    val owner = ev.ownerId ?: uid&#10;                    db.collection(&quot;users&quot;).document(owner).collection(&quot;events&quot;).document(ev.id)&#10;                        .delete()&#10;                        .addOnSuccessListener {&#10;                            events.removeAll { it.id == ev.id }&#10;                            upcomingEvents.removeAll { it.id == ev.id }&#10;                            showDeleteConfirm = false&#10;                            eventToDelete = null&#10;                        }&#10;                        .addOnFailureListener { ex -&gt;&#10;                            scope.launch { snackbarHostState.showSnackbar(&quot;Error eliminando: ${ex.localizedMessage}&quot;) }&#10;                            showDeleteConfirm = false; eventToDelete = null&#10;                        }&#10;                } else {&#10;                    // global event stored in top-level 'events'&#10;                    db.collection(&quot;events&quot;).document(ev.id)&#10;                        .delete()&#10;                        .addOnSuccessListener {&#10;                            events.removeAll { it.id == ev.id }&#10;                            upcomingEvents.removeAll { it.id == ev.id }&#10;                            showDeleteConfirm = false&#10;                            eventToDelete = null&#10;                        }&#10;                        .addOnFailureListener { ex -&gt;&#10;                            scope.launch { snackbarHostState.showSnackbar(&quot;Error eliminando: ${ex.localizedMessage}&quot;) }&#10;                            showDeleteConfirm = false; eventToDelete = null&#10;                        }&#10;                }&#10;            }) { Text(&quot;Eliminar&quot;) }&#10;        }, dismissButton = { TextButton(onClick = { showDeleteConfirm = false; eventToDelete = null }) { Text(&quot;Cancelar&quot;) } })&#10;    }&#10;&#10;    // Edit dialog&#10;    if (showEditEventDialog &amp;&amp; editingEvent != null) {&#10;        EditEventDialog(event = editingEvent!!, onDismiss = { showEditEventDialog = false; editingEvent = null }, onSave = { updated -&gt;&#10;             val uid = auth.currentUser?.uid ?: return@EditEventDialog&#10;             val map = mapOf(&quot;title&quot; to updated.title, &quot;description&quot; to updated.description, &quot;date&quot; to Timestamp(updated.date), &quot;type&quot; to updated.type.name)&#10;             // update in appropriate collection based on source&#10;             if (updated.source == EventSource.USER) {&#10;                // actualizar en la colección del owner (no asumir uid actual)&#10;                val owner = updated.ownerId ?: uid&#10;                db.collection(&quot;users&quot;).document(owner).collection(&quot;events&quot;).document(updated.id)&#10;                    .update(map)&#10;                    .addOnSuccessListener {&#10;                        fun replace(list: MutableList&lt;CalendarEvent&gt;) {&#10;                            val idx = list.indexOfFirst { it.id == updated.id }&#10;                            if (idx &gt;= 0) list[idx] = updated&#10;                        }&#10;                        replace(events)&#10;                        replace(upcomingEvents)&#10;                        showEditEventDialog = false; editingEvent = null&#10;                    }&#10;                    .addOnFailureListener { ex -&gt; scope.launch { snackbarHostState.showSnackbar(&quot;Error actualizando: ${ex.localizedMessage}&quot;) } }&#10;             } else {&#10;                 // teacher editing global event&#10;                 val mapWithCourse = hashMapOf&lt;String, Any?&gt;()&#10;                 mapWithCourse.putAll(map)&#10;                 if (!updated.ownerId.isNullOrBlank()) mapWithCourse[&quot;courseId&quot;] = updated.ownerId&#10;                 db.collection(&quot;events&quot;).document(updated.id).update(mapWithCourse as Map&lt;String, Any?&gt;)&#10;                      .addOnSuccessListener {&#10;                          fun replace(list: MutableList&lt;CalendarEvent&gt;) {&#10;                              val idx = list.indexOfFirst { it.id == updated.id }&#10;                              if (idx &gt;= 0) list[idx] = updated&#10;                          }&#10;                          replace(events)&#10;                          replace(upcomingEvents)&#10;                          showEditEventDialog = false; editingEvent = null&#10;                      }&#10;                      .addOnFailureListener { ex -&gt; scope.launch { snackbarHostState.showSnackbar(&quot;Error actualizando: ${ex.localizedMessage}&quot;) } }&#10;             }&#10;         }, role = role, userCourses = userCourses.toList())&#10;      }&#10;}&#10;&#10;// Generador simple de ocurrencias para recurrencia básica&#10;fun generateOccurrences(startDate: Date, recurrence: String, rangeStart: Date, rangeEnd: Date): List&lt;Date&gt; {&#10;     val res = mutableListOf&lt;Date&gt;()&#10;     val cal = Calendar.getInstance().apply { time = startDate }&#10;     val endRangeCal = Calendar.getInstance().apply { time = rangeEnd }&#10;     val startRangeCal = Calendar.getInstance().apply { time = rangeStart }&#10;&#10;     when (recurrence.uppercase(Locale.getDefault())) {&#10;         &quot;DAILY&quot; -&gt; {&#10;             // avanzar hasta &gt;= startRange&#10;             while (cal.before(startRangeCal)) cal.add(Calendar.DAY_OF_MONTH, 1)&#10;             while (!cal.after(endRangeCal)) {&#10;                 res.add(cal.time)&#10;                 cal.add(Calendar.DAY_OF_MONTH, 1)&#10;             }&#10;         }&#10;         &quot;WEEKLY&quot; -&gt; {&#10;             while (cal.before(startRangeCal)) cal.add(Calendar.WEEK_OF_YEAR, 1)&#10;             while (!cal.after(endRangeCal)) {&#10;                 res.add(cal.time)&#10;                 cal.add(Calendar.WEEK_OF_YEAR, 1)&#10;             }&#10;         }&#10;         &quot;MONTHLY&quot; -&gt; {&#10;             while (cal.before(startRangeCal)) cal.add(Calendar.MONTH, 1)&#10;             while (!cal.after(endRangeCal)) {&#10;                 res.add(cal.time)&#10;                 cal.add(Calendar.MONTH, 1)&#10;             }&#10;         }&#10;         else -&gt; { /* no soportado */ }&#10;     }&#10;&#10;     return res&#10; }&#10;&#10;@Composable&#10;private fun CalendarGrid(&#10;    displayedMonth: Calendar,&#10;    selectedDay: Calendar?,&#10;    events: List&lt;CalendarEvent&gt;,&#10;    onDateSelected: (Calendar) -&gt; Unit&#10;) {&#10;    val calendar = (displayedMonth.clone() as Calendar).apply { set(Calendar.DAY_OF_MONTH, 1) }&#10;    // determinar primer día de semana según locale/WeekFields&#10;    val firstDowField = WeekFields.of(Locale.getDefault()).firstDayOfWeek&#10;    val firstDayOfWeek = (firstDowField.value - 1) // DayOfWeek.MONDAY.value==1&#10;    val daysInMonth = calendar.getActualMaximum(Calendar.DAY_OF_MONTH)&#10;&#10;    val today = Calendar.getInstance()&#10;&#10;    LazyVerticalGrid(&#10;        columns = GridCells.Fixed(7),&#10;        modifier = Modifier.height(300.dp)&#10;    ) {&#10;        // Espacios en blanco antes del primer día&#10;        items(firstDayOfWeek) {&#10;            Box(modifier = Modifier.aspectRatio(1f))&#10;        }&#10;&#10;        // Días del mes&#10;        items(daysInMonth) { day -&gt;&#10;            val dayNumber = day + 1&#10;            val thisDay = (calendar.clone() as Calendar).apply { set(Calendar.DAY_OF_MONTH, dayNumber) }&#10;&#10;            // usar LocalDate para evitar problemas de zona/hora&#10;            val thisLocal = Instant.ofEpochMilli(thisDay.time.time).atZone(ZoneId.systemDefault()).toLocalDate()&#10;&#10;            val dayEvents = events.filter { ev -&gt;&#10;                val evLocal = Instant.ofEpochMilli(ev.date.time).atZone(ZoneId.systemDefault()).toLocalDate()&#10;                evLocal == thisLocal&#10;            }&#10;            val hasEvent = dayEvents.isNotEmpty()&#10;&#10;            val isToday = Instant.ofEpochMilli(today.time.time).atZone(ZoneId.systemDefault()).toLocalDate() == thisLocal&#10;&#10;            val isSelected = selectedDay?.let { sel -&gt;&#10;                val selLocal = Instant.ofEpochMilli(sel.time.time).atZone(ZoneId.systemDefault()).toLocalDate()&#10;                selLocal == thisLocal&#10;            } ?: false&#10;&#10;            Box(&#10;                modifier = Modifier&#10;                    .aspectRatio(1f)&#10;                    .padding(2.dp)&#10;                    .clip(CircleShape)&#10;                    .background(&#10;                        color = when {&#10;                            isSelected -&gt; MaterialTheme.colorScheme.primary.copy(alpha = 0.25f)&#10;                            isToday -&gt; MaterialTheme.colorScheme.primaryContainer&#10;                            hasEvent -&gt; MaterialTheme.colorScheme.secondaryContainer.copy(alpha = 0.5f)&#10;                            else -&gt; Color.Transparent&#10;                        }&#10;                    )&#10;                    .clickable { onDateSelected(thisDay) },&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Column(&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    Text(&#10;                        text = dayNumber.toString(),&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        fontWeight = if (isToday || isSelected) FontWeight.Bold else FontWeight.Normal,&#10;                        color = if (isToday || isSelected) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.onSurface&#10;                    )&#10;                    if (hasEvent) {&#10;                        // mostrar hasta 3 puntos de colores según tipos distintos&#10;                        val types = dayEvents.map { it.type }.distinct()&#10;                        val maxDots = 3&#10;                        Row(horizontalArrangement = Arrangement.Center, verticalAlignment = Alignment.CenterVertically) {&#10;                            types.take(maxDots).forEach { t -&gt;&#10;                                val dotColor = when (t) {&#10;                                    EventType.CLASE -&gt; Color(0xFF2196F3)&#10;                                    EventType.EXAMEN -&gt; Color(0xFFF44336)&#10;                                    EventType.TAREA -&gt; Color(0xFFFFC107)&#10;                                    EventType.EVENTO -&gt; Color(0xFF4CAF50)&#10;                                }&#10;                                Box(modifier = Modifier.size(6.dp).background(dotColor, CircleShape))&#10;                                Spacer(Modifier.width(4.dp))&#10;                            }&#10;                            if (types.size &gt; maxDots) {&#10;                                Text(&quot;+${types.size - maxDots}&quot;, style = MaterialTheme.typography.bodySmall)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun EventCard(event: CalendarEvent, onEdit: ((CalendarEvent) -&gt; Unit)? = null, onDelete: ((CalendarEvent) -&gt; Unit)? = null) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Icon(&#10;                imageVector = when (event.type) {&#10;                    EventType.CLASE -&gt; Icons.Filled.School&#10;                    EventType.EXAMEN -&gt; Icons.Filled.Warning&#10;                    EventType.TAREA -&gt; Icons.AutoMirrored.Filled.Assignment&#10;                    EventType.EVENTO -&gt; Icons.AutoMirrored.Filled.EventNote&#10;                },&#10;                contentDescription = null,&#10;                tint = when (event.type) {&#10;                    EventType.CLASE -&gt; Color(0xFF2196F3)&#10;                    EventType.EXAMEN -&gt; Color(0xFFF44336)&#10;                    EventType.TAREA -&gt; Color(0xFFFFC107)&#10;                    EventType.EVENTO -&gt; Color(0xFF4CAF50)&#10;                }&#10;            )&#10;            Spacer(Modifier.width(12.dp))&#10;            Column(modifier = Modifier.weight(1f)) {&#10;                Text(event.title, style = MaterialTheme.typography.titleSmall, fontWeight = FontWeight.SemiBold)&#10;                Text(SimpleDateFormat(&quot;dd/MM/yyyy HH:mm&quot;, Locale.getDefault()).format(event.date), style = MaterialTheme.typography.bodySmall, color = MaterialTheme.colorScheme.onSurfaceVariant)&#10;                if (event.description.isNotBlank()) Text(event.description, style = MaterialTheme.typography.bodyMedium)&#10;            }&#10;            // acciones opcionales&#10;            if (onEdit != null) IconButton(onClick = { onEdit(event) }) { Icon(Icons.Filled.Edit, contentDescription = &quot;Editar&quot;) }&#10;            if (onDelete != null) IconButton(onClick = { onDelete(event) }) { Icon(Icons.Filled.Delete, contentDescription = &quot;Eliminar&quot;) }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun AddEventDialog(&#10;     initialDate: Date,&#10;     onDismiss: () -&gt; Unit,&#10;     onSave: (String, String, Date, EventType, String?) -&gt; Unit,&#10;     role: Role?,&#10;     userCourses: List&lt;Pair&lt;String,String&gt;&gt; = emptyList()&#10; ) {&#10;    val context = LocalContext.current&#10;    var title by remember { mutableStateOf(&quot;&quot;) }&#10;    var description by remember { mutableStateOf(&quot;&quot;) }&#10;    // fecha y hora seleccionadas separadas&#10;    var dateCal by remember { mutableStateOf(Calendar.getInstance().apply { time = initialDate }) }&#10;    var type by remember { mutableStateOf(EventType.EVENTO) }&#10;    var targetCourseId by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;    // funciones auxiliares para abrir pickers nativos&#10;    fun openDatePicker() {&#10;        val c = dateCal&#10;        android.app.DatePickerDialog(context, { _, y, m, d -&gt;&#10;            c.set(Calendar.YEAR, y)&#10;            c.set(Calendar.MONTH, m)&#10;            c.set(Calendar.DAY_OF_MONTH, d)&#10;            dateCal = c&#10;        }, c.get(Calendar.YEAR), c.get(Calendar.MONTH), c.get(Calendar.DAY_OF_MONTH)).show()&#10;    }&#10;&#10;    fun openTimePicker() {&#10;        val c = dateCal&#10;        android.app.TimePickerDialog(context, { _, hour, minute -&gt;&#10;            c.set(Calendar.HOUR_OF_DAY, hour)&#10;            c.set(Calendar.MINUTE, minute)&#10;            c.set(Calendar.SECOND, 0)&#10;            dateCal = c&#10;        }, c.get(Calendar.HOUR_OF_DAY), c.get(Calendar.MINUTE), true).show()&#10;    }&#10;&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = { Text(&quot;Agregar Evento&quot;) },&#10;        text = {&#10;            Column {&#10;                OutlinedTextField(value = title, onValueChange = { title = it }, label = { Text(&quot;Título&quot;) }, singleLine = true)&#10;                Spacer(Modifier.height(8.dp))&#10;                OutlinedTextField(value = description, onValueChange = { description = it }, label = { Text(&quot;Descripción&quot;) })&#10;                Spacer(Modifier.height(8.dp))&#10;                Row(verticalAlignment = Alignment.CenterVertically) {&#10;                    Text(&quot;Fecha: ${SimpleDateFormat(&quot;dd/MM/yyyy&quot;, Locale.getDefault()).format(dateCal.time)}&quot;)&#10;                    Spacer(Modifier.width(8.dp))&#10;                    TextButton(onClick = { openDatePicker() }) { Text(&quot;Seleccionar fecha&quot;) }&#10;                }&#10;                Spacer(Modifier.height(8.dp))&#10;                Row(verticalAlignment = Alignment.CenterVertically) {&#10;                    Text(&quot;Hora: ${String.format(Locale.getDefault(), &quot;%02d:%02d&quot;, dateCal.get(Calendar.HOUR_OF_DAY), dateCal.get(Calendar.MINUTE))}&quot;)&#10;                    Spacer(Modifier.width(8.dp))&#10;                    TextButton(onClick = { openTimePicker() }) { Text(&quot;Seleccionar hora&quot;) }&#10;                }&#10;                Spacer(Modifier.height(8.dp))&#10;                Column(modifier = Modifier.fillMaxWidth()) {&#10;                    EventType.entries.forEach { ev -&gt;&#10;                        Row(&#10;                            verticalAlignment = Alignment.CenterVertically,&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(vertical = 4.dp)&#10;                        ) {&#10;                            RadioButton(selected = type == ev, onClick = { type = ev })&#10;                            Spacer(Modifier.width(8.dp))&#10;                            Text(ev.name, modifier = Modifier.weight(1f))&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // target course selection for teachers&#10;                if (role == Role.DOCENTE) {&#10;                    Spacer(Modifier.height(8.dp))&#10;                    Text(&quot;Curso objetivo (opcional):&quot;, style = MaterialTheme.typography.labelMedium)&#10;                    // mostrar cursos disponibles para el docente&#10;                    LazyColumn(&#10;                        modifier = Modifier.heightIn(max = 200.dp),&#10;                        verticalArrangement = Arrangement.spacedBy(4.dp)&#10;                    ) {&#10;                        items(userCourses) { course -&gt;&#10;                            val isSelected = targetCourseId == course.first&#10;                            Row(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .clickable { targetCourseId = if (isSelected) null else course.first }&#10;                                    .padding(8.dp)&#10;                                    .background(&#10;                                        color = if (isSelected) MaterialTheme.colorScheme.primary.copy(alpha = 0.2f) else Color.Transparent,&#10;                                        shape = CircleShape&#10;                                    ),&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                Text(course.second, modifier = Modifier.weight(1f))&#10;                                if (isSelected) {&#10;                                    Icon(Icons.Filled.Check, contentDescription = &quot;Seleccionado&quot;, tint = MaterialTheme.colorScheme.primary)&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        },&#10;        confirmButton = {&#10;            TextButton(onClick = {&#10;                if (title.isBlank()) return@TextButton&#10;                onSave(title, description, dateCal.time, type, targetCourseId)&#10;            }) { Text(&quot;Guardar&quot;) }&#10;        },&#10;        dismissButton = {&#10;            TextButton(onClick = onDismiss) { Text(&quot;Cerrar&quot;) }&#10;        }&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun EditEventDialog(event: CalendarEvent, onDismiss: () -&gt; Unit, onSave: (CalendarEvent) -&gt; Unit, role: Role?, userCourses: List&lt;Pair&lt;String,String&gt;&gt; = emptyList()) {&#10;    val context = LocalContext.current&#10;    var title by remember { mutableStateOf(event.title) }&#10;    var description by remember { mutableStateOf(event.description) }&#10;    var dateCal by remember { mutableStateOf(Calendar.getInstance().apply { time = event.date }) }&#10;    var type by remember { mutableStateOf(event.type) }&#10;    var targetCourseId by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;    // cargar id de curso objetivo si es evento global&#10;    LaunchedEffect(event) {&#10;        targetCourseId = if (event.source == EventSource.GLOBAL) event.ownerId else null&#10;    }&#10;&#10;    fun openDatePicker() {&#10;        val c = dateCal&#10;        android.app.DatePickerDialog(context, { _, y, m, d -&gt; c.set(y, m, d); dateCal = c }, c.get(Calendar.YEAR), c.get(Calendar.MONTH), c.get(Calendar.DAY_OF_MONTH)).show()&#10;    }&#10;    fun openTimePicker() {&#10;        val c = dateCal&#10;        android.app.TimePickerDialog(context, { _, h, min -&gt; c.set(Calendar.HOUR_OF_DAY, h); c.set(Calendar.MINUTE, min); dateCal = c }, c.get(Calendar.HOUR_OF_DAY), c.get(Calendar.MINUTE), true).show()&#10;    }&#10;&#10;    AlertDialog(onDismissRequest = onDismiss, title = { Text(&quot;Editar Evento&quot;) }, text = {&#10;        Column {&#10;            OutlinedTextField(value = title, onValueChange = { title = it }, label = { Text(&quot;Título&quot;) }, singleLine = true)&#10;            Spacer(Modifier.height(8.dp))&#10;            OutlinedTextField(value = description, onValueChange = { description = it }, label = { Text(&quot;Descripción&quot;) })&#10;            Spacer(Modifier.height(8.dp))&#10;            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                Text(&quot;Fecha: ${SimpleDateFormat(&quot;dd/MM/yyyy&quot;, Locale.getDefault()).format(dateCal.time)}&quot;)&#10;                Spacer(Modifier.width(8.dp))&#10;                TextButton(onClick = { openDatePicker() }) { Text(&quot;Seleccionar fecha&quot;) }&#10;            }&#10;            Spacer(Modifier.height(8.dp))&#10;            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                Text(&quot;Hora: ${String.format(Locale.getDefault(), &quot;%02d:%02d&quot;, dateCal.get(Calendar.HOUR_OF_DAY), dateCal.get(Calendar.MINUTE))}&quot;)&#10;                Spacer(Modifier.width(8.dp))&#10;                TextButton(onClick = { openTimePicker() }) { Text(&quot;Seleccionar hora&quot;) }&#10;            }&#10;            Spacer(Modifier.height(8.dp))&#10;            Column(modifier = Modifier.fillMaxWidth()) {&#10;                EventType.entries.forEach { ev -&gt;&#10;                    Row(&#10;                        verticalAlignment = Alignment.CenterVertically,&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(vertical = 4.dp)&#10;                    ) {&#10;                        RadioButton(selected = type == ev, onClick = { type = ev })&#10;                        Spacer(Modifier.width(8.dp))&#10;                        Text(ev.name, modifier = Modifier.weight(1f))&#10;                    }&#10;                }&#10;            }&#10;&#10;            // target course selection for teachers&#10;            if (role == Role.DOCENTE) {&#10;                Spacer(Modifier.height(8.dp))&#10;                Text(&quot;Curso objetivo (opcional):&quot;, style = MaterialTheme.typography.labelMedium)&#10;                // mostrar cursos disponibles para el docente&#10;                LazyColumn(&#10;                    modifier = Modifier.heightIn(max = 200.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(4.dp)&#10;                ) {&#10;                    items(userCourses) { course -&gt;&#10;                        val isSelected = targetCourseId == course.first&#10;                        Row(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .clickable { targetCourseId = if (isSelected) null else course.first }&#10;                                .padding(8.dp)&#10;                                .background(&#10;                                    color = if (isSelected) MaterialTheme.colorScheme.primary.copy(alpha = 0.2f) else Color.Transparent,&#10;                                    shape = CircleShape&#10;                                ),&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            Text(course.second, modifier = Modifier.weight(1f))&#10;                            if (isSelected) {&#10;                                Icon(Icons.Filled.Check, contentDescription = &quot;Seleccionado&quot;, tint = MaterialTheme.colorScheme.primary)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }, confirmButton = {&#10;        TextButton(onClick = { onSave(CalendarEvent(event.id, title, description, dateCal.time, type, event.source, targetCourseId)) }) { Text(&quot;Guardar&quot;) }&#10;    }, dismissButton = { TextButton(onClick = onDismiss) { Text(&quot;Cerrar&quot;) } })&#10;}&#10;&#10;// helper to load upcoming events paginated&#10;private fun loadMoreUpcoming(db: FirebaseFirestore, auth: FirebaseAuth, dest: MutableList&lt;CalendarEvent&gt;, courseIds: List&lt;String&gt; = emptyList(), lastSnapshot: DocumentSnapshot? = null, cbLast: (DocumentSnapshot?) -&gt; Unit) {&#10;    val uid = auth.currentUser?.uid ?: return&#10;    val col = db.collection(&quot;users&quot;).document(uid).collection(&quot;events&quot;)&#10;    val PAGE_SIZE = 25&#10;    try {&#10;        var q = col.whereGreaterThanOrEqualTo(&quot;date&quot;, Timestamp.now()).orderBy(&quot;date&quot;)&#10;        if (lastSnapshot != null) q = q.startAfter(lastSnapshot)&#10;        q = q.limit(PAGE_SIZE.toLong())&#10;        q.get().addOnSuccessListener { snap -&gt;&#10;            val docs = snap.documents&#10;            for (doc in docs) {&#10;                val id = doc.id&#10;                val title = doc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                val description = doc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                val ts = doc.get(&quot;date&quot;)&#10;                val d = when (ts) {&#10;                    is Timestamp -&gt; ts.toDate()&#10;                    is Date -&gt; ts&#10;                    else -&gt; null&#10;                }&#10;                val type = try { EventType.valueOf(doc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                val owner = doc.getString(&quot;ownerId&quot;)&#10;                if (d != null) dest.add(CalendarEvent(id, title, description, d, type, EventSource.USER, owner))&#10;            }&#10;            cbLast(docs.lastOrNull())&#10;             // additionally fetch upcoming global events for user's courses (no strict pagination)&#10;             if (courseIds.isNotEmpty()) {&#10;                 courseIds.chunked(10).forEach { chunk -&gt;&#10;                     db.collection(&quot;events&quot;).whereIn(&quot;courseId&quot;, chunk).whereGreaterThanOrEqualTo(&quot;date&quot;, Timestamp.now()).orderBy(&quot;date&quot;).limit(PAGE_SIZE.toLong()).get().addOnSuccessListener { gsnap -&gt;&#10;                         for (gdoc in gsnap.documents) {&#10;                             val id = gdoc.id&#10;                             if (dest.any { it.id == id }) continue&#10;                             val title = gdoc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                             val description = gdoc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                             val ts = gdoc.get(&quot;date&quot;)&#10;                             val d = when (ts) { is Timestamp -&gt; ts.toDate(); is Date -&gt; ts; else -&gt; null }&#10;                             val type = try { EventType.valueOf(gdoc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                             val courseId = gdoc.getString(&quot;courseId&quot;)&#10;                             if (d != null) dest.add(CalendarEvent(id, title, description, d, type, EventSource.GLOBAL, courseId))&#10;                         }&#10;                     }&#10;                 }&#10;             }&#10;         }&#10;     } catch (_: Exception) {&#10;         // ignore&#10;         cbLast(null)&#10;     }&#10; }&#10;&#10;// helper: crea notificaciones en users/{id}/notifications&#10;fun createNotifsForIds(ids: List&lt;String&gt;, title: String, body: String, relatedId: String, db: FirebaseFirestore, auth: FirebaseAuth) {&#10;     if (ids.isEmpty()) return&#10;    // fallback sender used if name lookup fails&#10;    val fallbackSender = auth.currentUser?.email ?: auth.currentUser?.uid ?: &quot;Profesor&quot;&#10;    for (sid in ids) {&#10;        try {&#10;            val notif = hashMapOf(&#10;                &quot;titulo&quot; to title,&#10;                &quot;cuerpo&quot; to body.take(200),&#10;                &quot;remitente&quot; to fallbackSender,&#10;                &quot;senderName&quot; to fallbackSender,&#10;                &quot;fechaHora&quot; to Timestamp.now(),&#10;                &quot;leida&quot; to false,&#10;                &quot;relatedId&quot; to relatedId,&#10;                &quot;type&quot; to &quot;event&quot;&#10;            )&#10;            db.collection(&quot;users&quot;).document(sid).collection(&quot;notifications&quot;).add(notif)&#10;        } catch (_: Exception) { }&#10;    }&#10;}&#10;&#10;// Resolve current user's display name then call createNotifsForIds with senderName set&#10;fun resolveAndCreateNotifs(ids: List&lt;String&gt;, title: String, body: String, relatedId: String, db: FirebaseFirestore, auth: FirebaseAuth) {&#10;    val uid = auth.currentUser?.uid&#10;    if (uid == null) {&#10;        createNotifsForIds(ids, title, body, relatedId, db, auth)&#10;        return&#10;    }&#10;    try {&#10;        db.collection(&quot;users&quot;).document(uid).get().addOnSuccessListener { doc -&gt;&#10;            val name = doc.getString(&quot;name&quot;) ?: doc.getString(&quot;displayName&quot;) ?: auth.currentUser?.email ?: uid&#10;            // create notifications with senderName field&#10;            for (sid in ids) {&#10;                try {&#10;                    val notif = hashMapOf(&#10;                        &quot;titulo&quot; to title,&#10;                        &quot;cuerpo&quot; to body.take(200),&#10;                        &quot;remitente&quot; to uid,&#10;                        &quot;senderName&quot; to name,&#10;                        &quot;fechaHora&quot; to Timestamp.now(),&#10;                        &quot;leida&quot; to false,&#10;                        &quot;relatedId&quot; to relatedId,&#10;                        &quot;type&quot; to &quot;event&quot;&#10;                    )&#10;                    db.collection(&quot;users&quot;).document(sid).collection(&quot;notifications&quot;).add(notif)&#10;                } catch (_: Exception) {}&#10;            }&#10;        }.addOnFailureListener {&#10;            createNotifsForIds(ids, title, body, relatedId, db, auth)&#10;        }&#10;    } catch (_: Exception) {&#10;        createNotifsForIds(ids, title, body, relatedId, db, auth)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.appcolegios.academico&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.gestures.detectHorizontalDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.grid.GridCells&#10;import androidx.compose.foundation.lazy.grid.LazyVerticalGrid&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import kotlinx.coroutines.launch&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.appcolegios.perfil.ProfileViewModel&#10;import com.example.appcolegios.data.UserPreferencesRepository&#10;import com.example.appcolegios.data.UserData&#10;import com.example.appcolegios.data.model.Role&#10;import androidx.compose.ui.platform.LocalContext&#10;import android.util.Log&#10;import com.google.firebase.Timestamp&#10;import com.google.firebase.firestore.ListenerRegistration&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.animation.AnimatedContent&#10;import androidx.compose.animation.ExperimentalAnimationApi&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.animation.slideInHorizontally&#10;import androidx.compose.animation.slideOutHorizontally&#10;import androidx.compose.animation.togetherWith&#10;import androidx.compose.material.icons.automirrored.filled.Assignment&#10;import androidx.compose.material.icons.automirrored.filled.EventNote&#10;import androidx.compose.runtime.key&#10;import java.time.Instant&#10;import java.time.LocalDate&#10;import java.time.ZoneId&#10;import java.time.temporal.WeekFields&#10;import com.google.firebase.firestore.DocumentSnapshot&#10;import java.util.Locale&#10;import kotlinx.coroutines.tasks.await&#10;&#10;enum class EventSource { USER, GLOBAL }&#10;&#10;data class CalendarEvent(&#10;    val id: String,&#10;    val title: String,&#10;    val description: String,&#10;    val date: Date,&#10;    val type: EventType,&#10;    val source: EventSource = EventSource.USER,&#10;    val ownerId: String? = null // for USER -&gt; userId; for GLOBAL -&gt; courseId or owner&#10;)&#10;&#10;enum class EventType {&#10;    CLASE, EXAMEN, TAREA, EVENTO&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class, ExperimentalAnimationApi::class)&#10;@Composable&#10;fun CalendarScreen(eventId: String? = null) {&#10;    // Separamos mes mostrado y fecha seleccionada&#10;    var displayedMonth by remember { mutableStateOf(Calendar.getInstance()) }&#10;    var selectedDay by remember { mutableStateOf&lt;Calendar?&gt;(Calendar.getInstance()) }&#10;    var showAddEventDialog by remember { mutableStateOf(false) }&#10;    val context = LocalContext.current&#10;&#10;    // Eventos para el mes mostrado (se cargan por rango mediante snapshot listener)&#10;    val events = remember { mutableStateListOf&lt;CalendarEvent&gt;() }&#10;    val auth = FirebaseAuth.getInstance()&#10;    val db = FirebaseFirestore.getInstance()&#10;    // user role and preferences&#10;    val userPrefs = remember { UserPreferencesRepository(context) }&#10;    val userData by userPrefs.userData.collectAsState(initial = UserData(null, null, null))&#10;    val role = userData.roleEnum&#10;    // courses for teacher/student/child selection&#10;    val userCourses = remember { mutableStateListOf&lt;Pair&lt;String,String&gt;&gt;() }&#10;    // Próximos eventos paginados y filtro por tipo&#10;    val upcomingEvents = remember { mutableStateListOf&lt;CalendarEvent&gt;() }&#10;    var upcomingLastSnapshot by remember { mutableStateOf&lt;DocumentSnapshot?&gt;(null) }&#10;    var selectedFilterType by remember { mutableStateOf&lt;EventType?&gt;(null) }&#10;&#10;    // Estado del bottom sheet para mostrar eventos del día seleccionado&#10;    var bottomSheetVisible by remember { mutableStateOf(false) }&#10;&#10;    // Estados para edición / borrado (deben existir para las acciones de la lista y bottom sheet)&#10;    var editingEvent by remember { mutableStateOf&lt;CalendarEvent?&gt;(null) }&#10;    var showEditEventDialog by remember { mutableStateOf(false) }&#10;    var eventToDelete by remember { mutableStateOf&lt;CalendarEvent?&gt;(null) }&#10;    var showDeleteConfirm by remember { mutableStateOf(false) }&#10;&#10;    // Profile VM: para padres (lista de hijos)&#10;    val profileVm: ProfileViewModel = viewModel()&#10;    val children by profileVm.children.collectAsState()&#10;    var selectedChildIndex by remember { mutableStateOf(0) }&#10;&#10;    // Listener registration manejado con DisposableEffect: soporta múltiples listeners según rol&#10;    DisposableEffect(displayedMonth.timeInMillis, auth.currentUser?.uid, role, selectedChildIndex) {&#10;        val userId = auth.currentUser?.uid&#10;        val regs = mutableListOf&lt;ListenerRegistration&gt;()&#10;        events.clear()&#10;&#10;        if (userId != null) {&#10;            // calcular primer y ultimo día del mes mostrado&#10;            val start = (displayedMonth.clone() as Calendar).apply {&#10;                set(Calendar.DAY_OF_MONTH, 1)&#10;                set(Calendar.HOUR_OF_DAY, 0)&#10;                set(Calendar.MINUTE, 0)&#10;                set(Calendar.SECOND, 0)&#10;                set(Calendar.MILLISECOND, 0)&#10;            }&#10;            val end = (displayedMonth.clone() as Calendar).apply {&#10;                set(Calendar.DAY_OF_MONTH, getActualMaximum(Calendar.DAY_OF_MONTH))&#10;                set(Calendar.HOUR_OF_DAY, 23)&#10;                set(Calendar.MINUTE, 59)&#10;                set(Calendar.SECOND, 59)&#10;                set(Calendar.MILLISECOND, 999)&#10;            }&#10;            val startTs = Timestamp(start.time)&#10;            val endTs = Timestamp(end.time)&#10;&#10;            try {&#10;                // 1) listener to personal events of the viewed user (teacher sees own personal too)&#10;                val personalListener = db.collection(&quot;users&quot;).document(userId).collection(&quot;events&quot;)&#10;                    .whereGreaterThanOrEqualTo(&quot;date&quot;, startTs)&#10;                    .whereLessThanOrEqualTo(&quot;date&quot;, endTs)&#10;                    .addSnapshotListener { snap, e -&gt;&#10;                        if (e != null) { Log.e(&quot;CalendarScreen&quot;, &quot;Personal listener error: ${e.message}&quot;); return@addSnapshotListener }&#10;                        if (snap != null) {&#10;                            for (doc in snap.documents) {&#10;                                val id = doc.id&#10;                                val title = doc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                                val description = doc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                                val ts = doc.get(&quot;date&quot;)&#10;                                val d = when (ts) { is Timestamp -&gt; ts.toDate(); is Date -&gt; ts; else -&gt; null }&#10;                                val type = try { EventType.valueOf(doc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                                if (d != null &amp;&amp; events.none { it.id == id }) events.add(CalendarEvent(id, title, description, d, type, EventSource.USER, userId))&#10;                                val rec = doc.getString(&quot;recurrence&quot;)&#10;                                if (!rec.isNullOrBlank() &amp;&amp; d != null) {&#10;                                    try { val occ = generateOccurrences(d, rec, start.time, end.time); occ.forEachIndexed { idx, occDate -&gt; if (events.none { it.id == &quot;${id}_occ_$idx&quot; }) events.add(CalendarEvent(&quot;${id}_occ_$idx&quot;, title, description, occDate, type, EventSource.USER, userId)) } } catch (_: Exception) {}&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                regs.add(personalListener)&#10;&#10;                // 2) role-specific: teacher -&gt; events for their courses; student -&gt; events for courses enrolled; parent -&gt; events for selected child&#10;                when (role) {&#10;                    Role.DOCENTE -&gt; {&#10;                        // get course ids taught by teacher&#10;                        val courseIds = mutableListOf&lt;String&gt;()&#10;                        try {&#10;                            val q = db.collection(&quot;courses&quot;).whereEqualTo(&quot;teacherId&quot;, userId).get()&#10;                            q.addOnSuccessListener { snap -&gt;&#10;                                userCourses.clear()&#10;                                for (doc in snap.documents) {&#10;                                    val cid = doc.id&#10;                                    courseIds.add(cid)&#10;                                    val cname = doc.getString(&quot;name&quot;) ?: doc.getString(&quot;title&quot;) ?: cid&#10;                                    userCourses.add(Pair(cid, cname))&#10;                                }&#10;                                // query top-level events where courseId in courseIds, chunked by 10&#10;                                if (courseIds.isNotEmpty()) {&#10;                                    courseIds.chunked(10).forEach { chunk -&gt;&#10;                                        val evQuery = db.collection(&quot;events&quot;).whereIn(&quot;courseId&quot;, chunk).whereGreaterThanOrEqualTo(&quot;date&quot;, startTs).whereLessThanOrEqualTo(&quot;date&quot;, endTs)&#10;                                        val r = evQuery.addSnapshotListener { snap2, e2 -&gt;&#10;                                            if (e2 != null) { Log.e(&quot;CalendarScreen&quot;,&quot;Course events listener err: ${e2.message}&quot;); return@addSnapshotListener }&#10;                                            if (snap2 != null) {&#10;                                                for (doc in snap2.documents) {&#10;                                                    val id = doc.id&#10;                                                    val title = doc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                                                    val description = doc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                                                    val ts = doc.get(&quot;date&quot;)&#10;                                                    val d = when (ts) { is Timestamp -&gt; ts.toDate(); is Date -&gt; ts; else -&gt; null }&#10;                                                    val type = try { EventType.valueOf(doc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                                                    if (d != null &amp;&amp; events.none { it.id == id }) events.add(CalendarEvent(id, title, description, d, type, EventSource.GLOBAL, null))&#10;                                                }&#10;                                            }&#10;                                        }&#10;                                        regs.add(r)&#10;                                    }&#10;                                }&#10;                            }&#10;                        } catch (_: Exception) { }&#10;                    }&#10;                    Role.ESTUDIANTE -&gt; {&#10;                        // student: read student doc for courses&#10;                        try {&#10;                            val sdocTask = db.collection(&quot;students&quot;).document(userId).get()&#10;                            sdocTask.addOnSuccessListener { sdoc -&gt;&#10;                                val courseIds = (sdoc.get(&quot;courses&quot;) as? List&lt;*&gt;)?.mapNotNull { it?.toString() } ?: emptyList()&#10;                                // populate userCourses with names&#10;                                userCourses.clear()&#10;                                for (cid in courseIds) {&#10;                                    db.collection(&quot;courses&quot;).document(cid).get().addOnSuccessListener { cdoc -&gt;&#10;                                        if (cdoc.exists()) userCourses.add(Pair(cid, cdoc.getString(&quot;name&quot;) ?: cid))&#10;                                    }&#10;                                }&#10;                                if (courseIds.isNotEmpty()) {&#10;                                    courseIds.chunked(10).forEach { chunk -&gt;&#10;                                        val evQuery = db.collection(&quot;events&quot;).whereIn(&quot;courseId&quot;, chunk).whereGreaterThanOrEqualTo(&quot;date&quot;, startTs).whereLessThanOrEqualTo(&quot;date&quot;, endTs)&#10;                                        val r = evQuery.addSnapshotListener { snap2, e2 -&gt;&#10;                                            if (e2 != null) return@addSnapshotListener&#10;                                            if (snap2 != null) {&#10;                                                for (doc in snap2.documents) {&#10;                                                    val id = doc.id&#10;                                                    val title = doc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                                                    val description = doc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                                                    val ts = doc.get(&quot;date&quot;)&#10;                                                    val d = when (ts) { is Timestamp -&gt; ts.toDate(); is Date -&gt; ts; else -&gt; null }&#10;                                                    val type = try { EventType.valueOf(doc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                                                    if (d != null &amp;&amp; events.none { it.id == id }) events.add(CalendarEvent(id, title, description, d, type, EventSource.GLOBAL, null))&#10;                                                }&#10;                                            }&#10;                                        }&#10;                                        regs.add(r)&#10;                                    }&#10;                                }&#10;                            }&#10;                        } catch (_: Exception) { }&#10;                    }&#10;                    Role.PADRE -&gt; {&#10;                        // parent: use selected child&#10;                        val childId = children.getOrNull(selectedChildIndex)?.id&#10;                        if (!childId.isNullOrBlank()) {&#10;                            // personal events of child&#10;                            val childListener = db.collection(&quot;users&quot;).document(childId).collection(&quot;events&quot;)&#10;                                .whereGreaterThanOrEqualTo(&quot;date&quot;, startTs)&#10;                                .whereLessThanOrEqualTo(&quot;date&quot;, endTs)&#10;                                .addSnapshotListener { snap, e -&gt;&#10;                                    if (e != null) { Log.e(&quot;CalendarScreen&quot;, &quot;Child listener error: ${e.message}&quot;); return@addSnapshotListener }&#10;                                    if (snap != null) {&#10;                                        for (doc in snap.documents) {&#10;                                            val id = doc.id&#10;                                            val title = doc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                                            val description = doc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                                            val ts = doc.get(&quot;date&quot;)&#10;                                            val d = when (ts) { is Timestamp -&gt; ts.toDate(); is Date -&gt; ts; else -&gt; null }&#10;                                            val type = try { EventType.valueOf(doc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                                            if (d != null &amp;&amp; events.none { it.id == id }) events.add(CalendarEvent(id, title, description, d, type, EventSource.USER, childId))&#10;                                        }&#10;                                    }&#10;                                }&#10;                            regs.add(childListener)&#10;&#10;                            // also load course events for that child (like student)&#10;                            try {&#10;                                val sdocTask = db.collection(&quot;students&quot;).document(childId).get()&#10;                                sdocTask.addOnSuccessListener { sdoc -&gt;&#10;                                    val courseIds = (sdoc.get(&quot;courses&quot;) as? List&lt;*&gt;)?.mapNotNull { it?.toString() } ?: emptyList()&#10;                                    if (courseIds.isNotEmpty()) {&#10;                                        courseIds.chunked(10).forEach { chunk -&gt;&#10;                                            val evQuery = db.collection(&quot;events&quot;).whereIn(&quot;courseId&quot;, chunk).whereGreaterThanOrEqualTo(&quot;date&quot;, startTs).whereLessThanOrEqualTo(&quot;date&quot;, endTs)&#10;                                            val r = evQuery.addSnapshotListener { snap2, e2 -&gt;&#10;                                                if (e2 != null) { Log.e(&quot;CalendarScreen&quot;, &quot;Child course events listener err: ${e2.message}&quot;); return@addSnapshotListener }&#10;                                                if (snap2 != null) {&#10;                                                    for (doc in snap2.documents) {&#10;                                                        val id = doc.id&#10;                                                        val title = doc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                                                        val description = doc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                                                        val ts = doc.get(&quot;date&quot;)&#10;                                                        val d = when (ts) { is Timestamp -&gt; ts.toDate(); is Date -&gt; ts; else -&gt; null }&#10;                                                        val type = try { EventType.valueOf(doc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                                                        if (d != null &amp;&amp; events.none { it.id == id }) events.add(CalendarEvent(id, title, description, d, type, EventSource.GLOBAL, doc.getString(&quot;courseId&quot;)))&#10;                                                    }&#10;                                                }&#10;                                            }&#10;                                            regs.add(r)&#10;                                        }&#10;                                    }&#10;                                }&#10;                            } catch (_: Exception) {}&#10;                        }&#10;                    }&#10;                    else -&gt; {&#10;                        // default: no extra listeners&#10;                    }&#10;                }&#10;            } catch (ex: Exception) {&#10;                Log.e(&quot;CalendarScreen&quot;, &quot;Error starting listeners: ${ex.message}&quot;, ex)&#10;            }&#10;        }&#10;&#10;        onDispose {&#10;            regs.forEach { try { it.remove() } catch (_: Exception) {} }&#10;        }&#10;    }&#10;&#10;    // Snackbar / scaffold&#10;    val snackbarHostState = remember { SnackbarHostState() }&#10;    val scope = rememberCoroutineScope()&#10;&#10;    Scaffold(&#10;        snackbarHost = { SnackbarHost(hostState = snackbarHostState) }&#10;    ) { innerPadding -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(innerPadding)&#10;                .padding(16.dp)&#10;        ) {&#10;            // Header con mes actual&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                IconButton(onClick = {&#10;                    displayedMonth = (displayedMonth.clone() as Calendar).apply { add(Calendar.MONTH, -1) }&#10;                }) {&#10;                    Icon(Icons.Filled.ChevronLeft, contentDescription = &quot;Mes anterior&quot;)&#10;                }&#10;&#10;                Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                    Text(&#10;                        text = SimpleDateFormat(&quot;MMMM yyyy&quot;, Locale.getDefault()).format(displayedMonth.time),&#10;                        style = MaterialTheme.typography.titleLarge,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;                    TextButton(onClick = { // volver a hoy&#10;                        displayedMonth = Calendar.getInstance()&#10;                        selectedDay = Calendar.getInstance()&#10;                    }) { Text(&quot;Hoy&quot;) }&#10;&#10;                    // selector de hijo para PADRE&#10;                    if (role == Role.PADRE) {&#10;                        Spacer(Modifier.height(8.dp))&#10;                        Row(verticalAlignment = Alignment.CenterVertically) {&#10;                            Text(&quot;Hijo: &quot;)&#10;                            if (children.isEmpty()) {&#10;                                Text(&quot;(sin hijos)&quot;)&#10;                            } else {&#10;                                var expanded by remember { mutableStateOf(false) }&#10;                                val label = children.getOrNull(selectedChildIndex)?.nombre ?: &quot;Seleccionar&quot;&#10;                                Box {&#10;                                    TextButton(onClick = { expanded = true }) { Text(label) }&#10;                                    DropdownMenu(expanded = expanded, onDismissRequest = { expanded = false }) {&#10;                                        children.forEachIndexed { idx, child -&gt;&#10;                                            DropdownMenuItem(text = { Text(child.nombre) }, onClick = { selectedChildIndex = idx; expanded = false })&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                IconButton(onClick = {&#10;                    displayedMonth = (displayedMonth.clone() as Calendar).apply { add(Calendar.MONTH, 1) }&#10;                }) {&#10;                    Icon(Icons.Filled.ChevronRight, contentDescription = &quot;Mes siguiente&quot;)&#10;                }&#10;            }&#10;&#10;            Spacer(Modifier.height(16.dp))&#10;&#10;            // Días de la semana -- respetar locale (primer día simplificado)&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceEvenly&#10;            ) {&#10;                // Obtener nombres de días desde locale&#10;                val df = SimpleDateFormat(&quot;EE&quot;, Locale.getDefault())&#10;                val headerCal = Calendar.getInstance()&#10;                // usar firstDayOfWeek del locale&#10;                val firstDow = headerCal.firstDayOfWeek&#10;                for (i in 0 until 7) {&#10;                    headerCal.set(Calendar.DAY_OF_WEEK, (firstDow + i - 1) % 7 + 1)&#10;                    Text(&#10;                        text = df.format(headerCal.time),&#10;                        modifier = Modifier.weight(1f),&#10;                        textAlign = TextAlign.Center,&#10;                        style = MaterialTheme.typography.labelMedium,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = MaterialTheme.colorScheme.primary&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(Modifier.height(8.dp))&#10;&#10;            // Grid del calendario con fecha seleccionada y soporte swipe/anim&#10;            Box(modifier = Modifier&#10;                .fillMaxWidth()&#10;                .height(320.dp)&#10;                .pointerInput(Unit) {&#10;                    detectHorizontalDragGestures { change, dragAmount -&gt;&#10;                        val threshold = 150&#10;                        if (dragAmount &gt; threshold) {&#10;                            // swipe derecha -&gt; mes anterior&#10;                            displayedMonth = (displayedMonth.clone() as Calendar).apply { add(Calendar.MONTH, -1) }&#10;                        } else if (dragAmount &lt; -threshold) {&#10;                            // swipe izquierda -&gt; mes siguiente&#10;                            displayedMonth = (displayedMonth.clone() as Calendar).apply { add(Calendar.MONTH, 1) }&#10;                        }&#10;                    }&#10;                }&#10;            ) {&#10;                AnimatedContent(targetState = displayedMonth.timeInMillis, transitionSpec = {&#10;                    slideInHorizontally(initialOffsetX = { fullWidth -&gt; if (targetState &gt; initialState) fullWidth else -fullWidth }, animationSpec = tween(300))&#10;                        .togetherWith(&#10;                            slideOutHorizontally(targetOffsetX = { fullWidth -&gt; if (targetState &gt; initialState) -fullWidth else fullWidth }, animationSpec = tween(300))&#10;                        )&#10;                }) { ts -&gt;&#10;                       key(ts) {&#10;                           CalendarGrid(&#10;                               displayedMonth = displayedMonth,&#10;                               selectedDay = selectedDay,&#10;                               events = events,&#10;                               onDateSelected = { cal -&gt;&#10;                                   selectedDay = cal&#10;                                   bottomSheetVisible = true&#10;                               }&#10;                           )&#10;                       }&#10;                   }&#10;             }&#10;&#10;            Spacer(Modifier.height(16.dp))&#10;&#10;            // Botón para agregar evento&#10;            Button(&#10;                onClick = { showAddEventDialog = true },&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Icon(Icons.Filled.Add, contentDescription = &quot;Agregar evento&quot;)&#10;                Spacer(Modifier.width(8.dp))&#10;                Text(&quot;Agregar Evento&quot;)&#10;            }&#10;&#10;            Spacer(Modifier.height(16.dp))&#10;&#10;            // Lista de próximos eventos (paginated) con filtro por tipo&#10;            Text(&#10;                &quot;Próximos Eventos&quot;,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;&#10;            Spacer(Modifier.height(8.dp))&#10;&#10;            // Filtro por tipo&#10;            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                Text(&quot;Filtrar: &quot;)&#10;                Spacer(Modifier.width(8.dp))&#10;                // botones simples para filtrar por tipo&#10;                EventType.entries.let { types -&gt;&#10;                    types.forEach { t -&gt;&#10;                         val selected = selectedFilterType == t&#10;                         TextButton(onClick = { selectedFilterType = if (selected) null else t }) {&#10;                             Text(t.name, color = if (selected) MaterialTheme.colorScheme.onPrimary else MaterialTheme.colorScheme.onSurface)&#10;                         }&#10;                     }&#10;                 }&#10;            }&#10;&#10;            Spacer(Modifier.height(8.dp))&#10;&#10;            // carga inicial de upcoming en background (no duplicar si ya cargado)&#10;            LaunchedEffect(auth.currentUser?.uid) {&#10;                upcomingEvents.clear()&#10;                upcomingLastSnapshot = null&#10;                // pasar los courseIds disponibles (si ya se cargaron) para traer también eventos globales&#10;                val courseIds = userCourses.map { it.first }&#10;                loadMoreUpcoming(db, auth, upcomingEvents, courseIds) { doc -&gt; upcomingLastSnapshot = doc }&#10;            }&#10;&#10;            val displayedUpcoming = if (selectedFilterType == null) upcomingEvents.toList() else upcomingEvents.filter { it.type == selectedFilterType }&#10;&#10;            LazyColumn(&#10;                 verticalArrangement = Arrangement.spacedBy(8.dp)&#10;             ) {&#10;                items(displayedUpcoming) { event -&gt;&#10;                    // per-event permissions: owner can edit/delete USER events; DOCENTE can edit/delete GLOBAL events&#10;                    val uid = auth.currentUser?.uid&#10;                    val allowEdit = when (event.source) {&#10;                        EventSource.USER -&gt; event.ownerId == uid&#10;                        EventSource.GLOBAL -&gt; role == Role.DOCENTE&#10;                    }&#10;                    val allowDelete = allowEdit&#10;                    EventCard(event,&#10;                        onEdit = if (allowEdit) { ev -&gt; editingEvent = ev; showEditEventDialog = true } else null,&#10;                        onDelete = if (allowDelete) { ev -&gt; eventToDelete = ev; showDeleteConfirm = true } else null&#10;                    )&#10;                }&#10;                item {&#10;                    Spacer(Modifier.height(6.dp))&#10;                    Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.Center) {&#10;                        val courseIds = userCourses.map { it.first }&#10;                        if (upcomingLastSnapshot != null) {&#10;                            Button(onClick = { loadMoreUpcoming(db, auth, upcomingEvents, courseIds) { doc -&gt; upcomingLastSnapshot = doc } }) { Text(&quot;Cargar más&quot;) }&#10;                        }&#10;                    }&#10;                 }&#10;             }&#10;         }&#10;     }&#10;&#10;    // Bottom sheet para eventos del día seleccionado (simple Modal)&#10;    if (bottomSheetVisible &amp;&amp; selectedDay != null) {&#10;        val selLocal = LocalDate.of(selectedDay!!.get(Calendar.YEAR), selectedDay!!.get(Calendar.MONTH)+1, selectedDay!!.get(Calendar.DAY_OF_MONTH))&#10;        val dayEvents = events.filter { ev -&gt;&#10;            val evLocal = Instant.ofEpochMilli(ev.date.time).atZone(ZoneId.systemDefault()).toLocalDate()&#10;            evLocal == selLocal&#10;        }.sortedBy { it.date }&#10;&#10;        ModalBottomSheet(&#10;            onDismissRequest = { bottomSheetVisible = false }&#10;        ) {&#10;            Column(modifier = Modifier.padding(16.dp)) {&#10;                Text(&quot;Eventos en ${SimpleDateFormat(&quot;dd/MM/yyyy&quot;, Locale.getDefault()).format(selectedDay!!.time)}&quot;, style = MaterialTheme.typography.titleMedium, fontWeight = FontWeight.Bold)&#10;                Spacer(Modifier.height(8.dp))&#10;                if (dayEvents.isEmpty()) {&#10;                    Text(&quot;No hay eventos para este día&quot;, color = MaterialTheme.colorScheme.onSurfaceVariant)&#10;                } else {&#10;                    dayEvents.forEach { ev -&gt;&#10;                        val uid = auth.currentUser?.uid&#10;                        val allowEdit = when (ev.source) {&#10;                            EventSource.USER -&gt; ev.ownerId == uid&#10;                            EventSource.GLOBAL -&gt; role == Role.DOCENTE&#10;                        }&#10;                        val allowDelete = allowEdit&#10;                        EventCard(ev,&#10;                            onEdit = if (allowEdit) { e -&gt; editingEvent = e; showEditEventDialog = true } else null,&#10;                            onDelete = if (allowDelete) { e -&gt; eventToDelete = e; showDeleteConfirm = true } else null&#10;                        )&#10;                        Spacer(Modifier.height(8.dp))&#10;                    }&#10;                }&#10;                Spacer(Modifier.height(8.dp))&#10;                Row(horizontalArrangement = Arrangement.End, modifier = Modifier.fillMaxWidth()) {&#10;                    TextButton(onClick = { bottomSheetVisible = false }) { Text(&quot;Cerrar&quot;) }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    if (showAddEventDialog) {&#10;        AddEventDialog(&#10;            initialDate = selectedDay?.time ?: displayedMonth.time,&#10;            onDismiss = { showAddEventDialog = false },&#10;            onSave = { title, description, date, type, targetCourseId -&gt;&#10;                val userId = auth.currentUser?.uid&#10;                if (userId == null) {&#10;                    scope.launch { snackbarHostState.showSnackbar(&quot;Debes iniciar sesión para agregar eventos&quot;) }&#10;                    return@AddEventDialog&#10;                }&#10;                val db = FirebaseFirestore.getInstance()&#10;                val eventId = UUID.randomUUID().toString()&#10;                val eventData = hashMapOf&lt;String, Any?&gt;(&#10;                    &quot;id&quot; to eventId,&#10;                    &quot;title&quot; to title,&#10;                    &quot;description&quot; to description,&#10;                    &quot;date&quot; to Timestamp(date),&#10;                    &quot;type&quot; to type.name,&#10;                    &quot;createdAt&quot; to Timestamp.now(),&#10;                    &quot;ownerId&quot; to userId&#10;                )&#10;                // If teacher selected a course target, save as global event in top-level collection&#10;                if (role == Role.DOCENTE &amp;&amp; !targetCourseId.isNullOrBlank()) {&#10;                    eventData[&quot;courseId&quot;] = targetCourseId&#10;                    db.collection(&quot;events&quot;).document(eventId)&#10;                        .set(eventData)&#10;                        .addOnSuccessListener {&#10;                            events.add(CalendarEvent(eventId, title, description, date, type, EventSource.GLOBAL, targetCourseId))&#10;                            showAddEventDialog = false&#10;                            scope.launch { snackbarHostState.showSnackbar(&quot;Evento de curso agregado&quot;) }&#10;&#10;                            // Crear notificaciones para estudiantes del curso (solo si el creador no es estudiante)&#10;                            try {&#10;                                // obtener estudiantes desde subcolección courses/{courseId}/students&#10;                                targetCourseId?.takeIf { it.isNotBlank() }?.let { tcid -&gt;&#10;                                    db.collection(&quot;courses&quot;).document(tcid).collection(&quot;students&quot;).get()&#10;                                        .addOnSuccessListener { studsSnap -&gt;&#10;                                            val studentIds = if (!studsSnap.isEmpty) studsSnap.documents.mapNotNull { it.id } else emptyList()&#10;                                            if (studentIds.isEmpty()) {&#10;                                                // fallback: si no hay subcoleccion, intentar buscar en students collection por courseId&#10;                                                db.collection(&quot;students&quot;).whereEqualTo(&quot;courseId&quot;, tcid).get()&#10;                                                    .addOnSuccessListener { altSnap -&gt;&#10;                                                        val altIds = altSnap.documents.mapNotNull { it.id }&#10;                                                        // resolver senderName y crear notifs&#10;                                                        resolveAndCreateNotifs(altIds, title, description, eventId, db, auth)&#10;                                                    }&#10;                                            } else {&#10;                                                resolveAndCreateNotifs(studentIds, title, description, eventId, db, auth)&#10;                                            }&#10;                                        }&#10;                                }&#10;                            } catch (e: Exception) {&#10;                                Log.w(&quot;CalendarScreen&quot;, &quot;Error creando notificaciones de curso: ${e.message}&quot;)&#10;                            }&#10;                        }&#10;                        .addOnFailureListener { e -&gt;&#10;                            Log.e(&quot;CalendarScreen&quot;, &quot;Error saving global event: ${e.message}&quot;, e)&#10;                            scope.launch { snackbarHostState.showSnackbar(&quot;Error guardando evento&quot;) }&#10;                        }&#10;                } else {&#10;                    // save personal event under users/{uid}/events&#10;                    db.collection(&quot;users&quot;).document(userId).collection(&quot;events&quot;).document(eventId)&#10;                        .set(eventData)&#10;                        .addOnSuccessListener {&#10;                            events.add(CalendarEvent(eventId, title, description, date, type, EventSource.USER, userId))&#10;                            showAddEventDialog = false&#10;                            scope.launch { snackbarHostState.showSnackbar(&quot;Evento agregado&quot;) }&#10;                        }&#10;                        .addOnFailureListener { e -&gt;&#10;                            Log.e(&quot;CalendarScreen&quot;, &quot;Error saving personal event: ${e.message}&quot;, e)&#10;                            scope.launch { snackbarHostState.showSnackbar(&quot;Error guardando evento&quot;) }&#10;                        }&#10;                }&#10;            },&#10;            role = role,&#10;            userCourses = userCourses.toList()&#10;        )&#10;    }&#10;&#10;    // handle actual deletion when confirmed&#10;    if (showDeleteConfirm &amp;&amp; eventToDelete != null) {&#10;        AlertDialog(onDismissRequest = { showDeleteConfirm = false; eventToDelete = null }, title = { Text(&quot;Confirmar eliminación&quot;) }, text = { Text(&quot;Eliminar evento '${eventToDelete!!.title}'?&quot;) }, confirmButton = {&#10;            TextButton(onClick = {&#10;                val uid = auth.currentUser?.uid ?: run { showDeleteConfirm = false; eventToDelete = null; return@TextButton }&#10;                val ev = eventToDelete&#10;                if (ev == null) return@TextButton&#10;                if (ev.source == EventSource.USER) {&#10;                    // delete under owner user's events&#10;                    val owner = ev.ownerId ?: uid&#10;                    db.collection(&quot;users&quot;).document(owner).collection(&quot;events&quot;).document(ev.id)&#10;                        .delete()&#10;                        .addOnSuccessListener {&#10;                            events.removeAll { it.id == ev.id }&#10;                            upcomingEvents.removeAll { it.id == ev.id }&#10;                            showDeleteConfirm = false&#10;                            eventToDelete = null&#10;                        }&#10;                        .addOnFailureListener { ex -&gt;&#10;                            scope.launch { snackbarHostState.showSnackbar(&quot;Error eliminando: ${ex.localizedMessage}&quot;) }&#10;                            showDeleteConfirm = false; eventToDelete = null&#10;                        }&#10;                } else {&#10;                    // global event stored in top-level 'events'&#10;                    db.collection(&quot;events&quot;).document(ev.id)&#10;                        .delete()&#10;                        .addOnSuccessListener {&#10;                            events.removeAll { it.id == ev.id }&#10;                            upcomingEvents.removeAll { it.id == ev.id }&#10;                            showDeleteConfirm = false&#10;                            eventToDelete = null&#10;                        }&#10;                        .addOnFailureListener { ex -&gt;&#10;                            scope.launch { snackbarHostState.showSnackbar(&quot;Error eliminando: ${ex.localizedMessage}&quot;) }&#10;                            showDeleteConfirm = false; eventToDelete = null&#10;                        }&#10;                }&#10;            }) { Text(&quot;Eliminar&quot;) }&#10;        }, dismissButton = { TextButton(onClick = { showDeleteConfirm = false; eventToDelete = null }) { Text(&quot;Cancelar&quot;) } })&#10;    }&#10;&#10;    // Edit dialog&#10;    if (showEditEventDialog &amp;&amp; editingEvent != null) {&#10;        EditEventDialog(event = editingEvent!!, onDismiss = { showEditEventDialog = false; editingEvent = null }, onSave = { updated -&gt;&#10;             val uid = auth.currentUser?.uid ?: return@EditEventDialog&#10;             val map = mapOf(&quot;title&quot; to updated.title, &quot;description&quot; to updated.description, &quot;date&quot; to Timestamp(updated.date), &quot;type&quot; to updated.type.name)&#10;             // update in appropriate collection based on source&#10;             if (updated.source == EventSource.USER) {&#10;                // actualizar en la colección del owner (no asumir uid actual)&#10;                val owner = updated.ownerId ?: uid&#10;                db.collection(&quot;users&quot;).document(owner).collection(&quot;events&quot;).document(updated.id)&#10;                    .update(map)&#10;                    .addOnSuccessListener {&#10;                        fun replace(list: MutableList&lt;CalendarEvent&gt;) {&#10;                            val idx = list.indexOfFirst { it.id == updated.id }&#10;                            if (idx &gt;= 0) list[idx] = updated&#10;                        }&#10;                        replace(events)&#10;                        replace(upcomingEvents)&#10;                        showEditEventDialog = false; editingEvent = null&#10;                    }&#10;                    .addOnFailureListener { ex -&gt; scope.launch { snackbarHostState.showSnackbar(&quot;Error actualizando: ${ex.localizedMessage}&quot;) } }&#10;             } else {&#10;                 // teacher editing global event&#10;                 val mapWithCourse = hashMapOf&lt;String, Any?&gt;()&#10;                 mapWithCourse.putAll(map)&#10;                 if (!updated.ownerId.isNullOrBlank()) mapWithCourse[&quot;courseId&quot;] = updated.ownerId&#10;                 db.collection(&quot;events&quot;).document(updated.id).update(mapWithCourse as Map&lt;String, Any?&gt;)&#10;                      .addOnSuccessListener {&#10;                          fun replace(list: MutableList&lt;CalendarEvent&gt;) {&#10;                              val idx = list.indexOfFirst { it.id == updated.id }&#10;                              if (idx &gt;= 0) list[idx] = updated&#10;                          }&#10;                          replace(events)&#10;                          replace(upcomingEvents)&#10;                          showEditEventDialog = false; editingEvent = null&#10;                      }&#10;                      .addOnFailureListener { ex -&gt; scope.launch { snackbarHostState.showSnackbar(&quot;Error actualizando: ${ex.localizedMessage}&quot;) } }&#10;             }&#10;         }, role = role, userCourses = userCourses.toList())&#10;      }&#10;&#10;    // After listeners are set up, if an eventId was provided attempt to locate and select it&#10;    LaunchedEffect(eventId) {&#10;        if (eventId.isNullOrBlank()) return@LaunchedEffect&#10;        // try to find locally first&#10;        val found = events.find { it.id == eventId }&#10;        if (found != null) {&#10;            selectedDay = Calendar.getInstance().apply { time = found.date }&#10;            bottomSheetVisible = true&#10;        } else {&#10;            // try to fetch from top-level events&#10;            try {&#10;                val doc = db.collection(&quot;events&quot;).document(eventId).get().await()&#10;                if (doc.exists()) {&#10;                    val title = doc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                    val description = doc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                    val ts = doc.get(&quot;date&quot;)&#10;                    val d = when (ts) { is Timestamp -&gt; ts.toDate(); is Date -&gt; ts; else -&gt; null }&#10;                    val type = try { EventType.valueOf(doc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                    if (d != null) {&#10;                        selectedDay = Calendar.getInstance().apply { time = d }&#10;                        events.add(CalendarEvent(eventId, title, description, d, type, EventSource.GLOBAL, doc.getString(&quot;courseId&quot;)))&#10;                        bottomSheetVisible = true&#10;                    }&#10;                } else {&#10;                    // try users/{uid}/events&#10;                    val uid = auth.currentUser?.uid&#10;                    if (!uid.isNullOrBlank()) {&#10;                        val ud = db.collection(&quot;users&quot;).document(uid).collection(&quot;events&quot;).document(eventId).get().await()&#10;                        if (ud.exists()) {&#10;                            val title = ud.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                            val description = ud.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                            val ts = ud.get(&quot;date&quot;)&#10;                            val d = when (ts) { is Timestamp -&gt; ts.toDate(); is Date -&gt; ts; else -&gt; null }&#10;                            val type = try { EventType.valueOf(ud.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                            if (d != null) {&#10;                                selectedDay = Calendar.getInstance().apply { time = d }&#10;                                events.add(CalendarEvent(eventId, title, description, d, type, EventSource.USER, uid))&#10;                                bottomSheetVisible = true&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            } catch (_: Exception) { }&#10;        }&#10;    }&#10;}&#10;&#10;// Generador simple de ocurrencias para recurrencia básica&#10;fun generateOccurrences(startDate: Date, recurrence: String, rangeStart: Date, rangeEnd: Date): List&lt;Date&gt; {&#10;     val res = mutableListOf&lt;Date&gt;()&#10;     val cal = Calendar.getInstance().apply { time = startDate }&#10;     val endRangeCal = Calendar.getInstance().apply { time = rangeEnd }&#10;     val startRangeCal = Calendar.getInstance().apply { time = rangeStart }&#10;&#10;     when (recurrence.uppercase(Locale.getDefault())) {&#10;         &quot;DAILY&quot; -&gt; {&#10;             // avanzar hasta &gt;= startRange&#10;             while (cal.before(startRangeCal)) cal.add(Calendar.DAY_OF_MONTH, 1)&#10;             while (!cal.after(endRangeCal)) {&#10;                 res.add(cal.time)&#10;                 cal.add(Calendar.DAY_OF_MONTH, 1)&#10;             }&#10;         }&#10;         &quot;WEEKLY&quot; -&gt; {&#10;             while (cal.before(startRangeCal)) cal.add(Calendar.WEEK_OF_YEAR, 1)&#10;             while (!cal.after(endRangeCal)) {&#10;                 res.add(cal.time)&#10;                 cal.add(Calendar.WEEK_OF_YEAR, 1)&#10;             }&#10;         }&#10;         &quot;MONTHLY&quot; -&gt; {&#10;             while (cal.before(startRangeCal)) cal.add(Calendar.MONTH, 1)&#10;             while (!cal.after(endRangeCal)) {&#10;                 res.add(cal.time)&#10;                 cal.add(Calendar.MONTH, 1)&#10;             }&#10;         }&#10;         else -&gt; { /* no soportado */ }&#10;     }&#10;&#10;     return res&#10; }&#10;&#10;@Composable&#10;private fun CalendarGrid(&#10;    displayedMonth: Calendar,&#10;    selectedDay: Calendar?,&#10;    events: List&lt;CalendarEvent&gt;,&#10;    onDateSelected: (Calendar) -&gt; Unit&#10;) {&#10;    val calendar = (displayedMonth.clone() as Calendar).apply { set(Calendar.DAY_OF_MONTH, 1) }&#10;    // determinar primer día de semana según locale/WeekFields&#10;    val firstDowField = WeekFields.of(Locale.getDefault()).firstDayOfWeek&#10;    val firstDayOfWeek = (firstDowField.value - 1) // DayOfWeek.MONDAY.value==1&#10;    val daysInMonth = calendar.getActualMaximum(Calendar.DAY_OF_MONTH)&#10;&#10;    val today = Calendar.getInstance()&#10;&#10;    LazyVerticalGrid(&#10;        columns = GridCells.Fixed(7),&#10;        modifier = Modifier.height(300.dp)&#10;    ) {&#10;        // Espacios en blanco antes del primer día&#10;        items(firstDayOfWeek) {&#10;            Box(modifier = Modifier.aspectRatio(1f))&#10;        }&#10;&#10;        // Días del mes&#10;        items(daysInMonth) { day -&gt;&#10;            val dayNumber = day + 1&#10;            val thisDay = (calendar.clone() as Calendar).apply { set(Calendar.DAY_OF_MONTH, dayNumber) }&#10;&#10;            // usar LocalDate para evitar problemas de zona/hora&#10;            val thisLocal = Instant.ofEpochMilli(thisDay.time.time).atZone(ZoneId.systemDefault()).toLocalDate()&#10;&#10;            val dayEvents = events.filter { ev -&gt;&#10;                val evLocal = Instant.ofEpochMilli(ev.date.time).atZone(ZoneId.systemDefault()).toLocalDate()&#10;                evLocal == thisLocal&#10;            }&#10;            val hasEvent = dayEvents.isNotEmpty()&#10;&#10;            val isToday = Instant.ofEpochMilli(today.time.time).atZone(ZoneId.systemDefault()).toLocalDate() == thisLocal&#10;&#10;            val isSelected = selectedDay?.let { sel -&gt;&#10;                val selLocal = Instant.ofEpochMilli(sel.time.time).atZone(ZoneId.systemDefault()).toLocalDate()&#10;                selLocal == thisLocal&#10;            } ?: false&#10;&#10;            Box(&#10;                modifier = Modifier&#10;                    .aspectRatio(1f)&#10;                    .padding(2.dp)&#10;                    .clip(CircleShape)&#10;                    .background(&#10;                        color = when {&#10;                            isSelected -&gt; MaterialTheme.colorScheme.primary.copy(alpha = 0.25f)&#10;                            isToday -&gt; MaterialTheme.colorScheme.primaryContainer&#10;                            hasEvent -&gt; MaterialTheme.colorScheme.secondaryContainer.copy(alpha = 0.5f)&#10;                            else -&gt; Color.Transparent&#10;                        }&#10;                    )&#10;                    .clickable { onDateSelected(thisDay) },&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Column(&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    Text(&#10;                        text = dayNumber.toString(),&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        fontWeight = if (isToday || isSelected) FontWeight.Bold else FontWeight.Normal,&#10;                        color = if (isToday || isSelected) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.onSurface&#10;                    )&#10;                    if (hasEvent) {&#10;                        // mostrar hasta 3 puntos de colores según tipos distintos&#10;                        val types = dayEvents.map { it.type }.distinct()&#10;                        val maxDots = 3&#10;                        Row(horizontalArrangement = Arrangement.Center, verticalAlignment = Alignment.CenterVertically) {&#10;                            types.take(maxDots).forEach { t -&gt;&#10;                                val dotColor = when (t) {&#10;                                    EventType.CLASE -&gt; Color(0xFF2196F3)&#10;                                    EventType.EXAMEN -&gt; Color(0xFFF44336)&#10;                                    EventType.TAREA -&gt; Color(0xFFFFC107)&#10;                                    EventType.EVENTO -&gt; Color(0xFF4CAF50)&#10;                                }&#10;                                Box(modifier = Modifier.size(6.dp).background(dotColor, CircleShape))&#10;                                Spacer(Modifier.width(4.dp))&#10;                            }&#10;                            if (types.size &gt; maxDots) {&#10;                                Text(&quot;+${types.size - maxDots}&quot;, style = MaterialTheme.typography.bodySmall)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun EventCard(event: CalendarEvent, onEdit: ((CalendarEvent) -&gt; Unit)? = null, onDelete: ((CalendarEvent) -&gt; Unit)? = null) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Icon(&#10;                imageVector = when (event.type) {&#10;                    EventType.CLASE -&gt; Icons.Filled.School&#10;                    EventType.EXAMEN -&gt; Icons.Filled.Warning&#10;                    EventType.TAREA -&gt; Icons.AutoMirrored.Filled.Assignment&#10;                    EventType.EVENTO -&gt; Icons.AutoMirrored.Filled.EventNote&#10;                },&#10;                contentDescription = null,&#10;                tint = when (event.type) {&#10;                    EventType.CLASE -&gt; Color(0xFF2196F3)&#10;                    EventType.EXAMEN -&gt; Color(0xFFF44336)&#10;                    EventType.TAREA -&gt; Color(0xFFFFC107)&#10;                    EventType.EVENTO -&gt; Color(0xFF4CAF50)&#10;                }&#10;            )&#10;            Spacer(Modifier.width(12.dp))&#10;            Column(modifier = Modifier.weight(1f)) {&#10;                Text(event.title, style = MaterialTheme.typography.titleSmall, fontWeight = FontWeight.SemiBold)&#10;                Text(SimpleDateFormat(&quot;dd/MM/yyyy HH:mm&quot;, Locale.getDefault()).format(event.date), style = MaterialTheme.typography.bodySmall, color = MaterialTheme.colorScheme.onSurfaceVariant)&#10;                if (event.description.isNotBlank()) Text(event.description, style = MaterialTheme.typography.bodyMedium)&#10;            }&#10;            // acciones opcionales&#10;            if (onEdit != null) IconButton(onClick = { onEdit(event) }) { Icon(Icons.Filled.Edit, contentDescription = &quot;Editar&quot;) }&#10;            if (onDelete != null) IconButton(onClick = { onDelete(event) }) { Icon(Icons.Filled.Delete, contentDescription = &quot;Eliminar&quot;) }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun AddEventDialog(&#10;     initialDate: Date,&#10;     onDismiss: () -&gt; Unit,&#10;     onSave: (String, String, Date, EventType, String?) -&gt; Unit,&#10;     role: Role?,&#10;     userCourses: List&lt;Pair&lt;String,String&gt;&gt; = emptyList()&#10; ) {&#10;    val context = LocalContext.current&#10;    var title by remember { mutableStateOf(&quot;&quot;) }&#10;    var description by remember { mutableStateOf(&quot;&quot;) }&#10;    // fecha y hora seleccionadas separadas&#10;    var dateCal by remember { mutableStateOf(Calendar.getInstance().apply { time = initialDate }) }&#10;    var type by remember { mutableStateOf(EventType.EVENTO) }&#10;    var targetCourseId by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;    // funciones auxiliares para abrir pickers nativos&#10;    fun openDatePicker() {&#10;        val c = dateCal&#10;        android.app.DatePickerDialog(context, { _, y, m, d -&gt;&#10;            c.set(Calendar.YEAR, y)&#10;            c.set(Calendar.MONTH, m)&#10;            c.set(Calendar.DAY_OF_MONTH, d)&#10;            dateCal = c&#10;        }, c.get(Calendar.YEAR), c.get(Calendar.MONTH), c.get(Calendar.DAY_OF_MONTH)).show()&#10;    }&#10;&#10;    fun openTimePicker() {&#10;        val c = dateCal&#10;        android.app.TimePickerDialog(context, { _, hour, minute -&gt;&#10;            c.set(Calendar.HOUR_OF_DAY, hour)&#10;            c.set(Calendar.MINUTE, minute)&#10;            c.set(Calendar.SECOND, 0)&#10;            dateCal = c&#10;        }, c.get(Calendar.HOUR_OF_DAY), c.get(Calendar.MINUTE), true).show()&#10;    }&#10;&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = { Text(&quot;Agregar Evento&quot;) },&#10;        text = {&#10;            Column {&#10;                OutlinedTextField(value = title, onValueChange = { title = it }, label = { Text(&quot;Título&quot;) }, singleLine = true)&#10;                Spacer(Modifier.height(8.dp))&#10;                OutlinedTextField(value = description, onValueChange = { description = it }, label = { Text(&quot;Descripción&quot;) })&#10;                Spacer(Modifier.height(8.dp))&#10;                Row(verticalAlignment = Alignment.CenterVertically) {&#10;                    Text(&quot;Fecha: ${SimpleDateFormat(&quot;dd/MM/yyyy&quot;, Locale.getDefault()).format(dateCal.time)}&quot;)&#10;                    Spacer(Modifier.width(8.dp))&#10;                    TextButton(onClick = { openDatePicker() }) { Text(&quot;Seleccionar fecha&quot;) }&#10;                }&#10;                Spacer(Modifier.height(8.dp))&#10;                Row(verticalAlignment = Alignment.CenterVertically) {&#10;                    Text(&quot;Hora: ${String.format(Locale.getDefault(), &quot;%02d:%02d&quot;, dateCal.get(Calendar.HOUR_OF_DAY), dateCal.get(Calendar.MINUTE))}&quot;)&#10;                    Spacer(Modifier.width(8.dp))&#10;                    TextButton(onClick = { openTimePicker() }) { Text(&quot;Seleccionar hora&quot;) }&#10;                }&#10;                Spacer(Modifier.height(8.dp))&#10;                Column(modifier = Modifier.fillMaxWidth()) {&#10;                    EventType.entries.forEach { ev -&gt;&#10;                        Row(&#10;                            verticalAlignment = Alignment.CenterVertically,&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(vertical = 4.dp)&#10;                        ) {&#10;                            RadioButton(selected = type == ev, onClick = { type = ev })&#10;                            Spacer(Modifier.width(8.dp))&#10;                            Text(ev.name, modifier = Modifier.weight(1f))&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // target course selection for teachers&#10;                if (role == Role.DOCENTE) {&#10;                    Spacer(Modifier.height(8.dp))&#10;                    Text(&quot;Curso objetivo (opcional):&quot;, style = MaterialTheme.typography.labelMedium)&#10;                    // mostrar cursos disponibles para el docente&#10;                    LazyColumn(&#10;                        modifier = Modifier.heightIn(max = 200.dp),&#10;                        verticalArrangement = Arrangement.spacedBy(4.dp)&#10;                    ) {&#10;                        items(userCourses) { course -&gt;&#10;                            val isSelected = targetCourseId == course.first&#10;                            Row(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .clickable { targetCourseId = if (isSelected) null else course.first }&#10;                                    .padding(8.dp)&#10;                                    .background(&#10;                                        color = if (isSelected) MaterialTheme.colorScheme.primary.copy(alpha = 0.2f) else Color.Transparent,&#10;                                        shape = CircleShape&#10;                                    ),&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                Text(course.second, modifier = Modifier.weight(1f))&#10;                                if (isSelected) {&#10;                                    Icon(Icons.Filled.Check, contentDescription = &quot;Seleccionado&quot;, tint = MaterialTheme.colorScheme.primary)&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        },&#10;        confirmButton = {&#10;            TextButton(onClick = {&#10;                if (title.isBlank()) return@TextButton&#10;                onSave(title, description, dateCal.time, type, targetCourseId)&#10;            }) { Text(&quot;Guardar&quot;) }&#10;        },&#10;        dismissButton = {&#10;            TextButton(onClick = onDismiss) { Text(&quot;Cerrar&quot;) }&#10;        }&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun EditEventDialog(event: CalendarEvent, onDismiss: () -&gt; Unit, onSave: (CalendarEvent) -&gt; Unit, role: Role?, userCourses: List&lt;Pair&lt;String,String&gt;&gt; = emptyList()) {&#10;    val context = LocalContext.current&#10;    var title by remember { mutableStateOf(event.title) }&#10;    var description by remember { mutableStateOf(event.description) }&#10;    var dateCal by remember { mutableStateOf(Calendar.getInstance().apply { time = event.date }) }&#10;    var type by remember { mutableStateOf(event.type) }&#10;    var targetCourseId by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;    // cargar id de curso objetivo si es evento global&#10;    LaunchedEffect(event) {&#10;        targetCourseId = if (event.source == EventSource.GLOBAL) event.ownerId else null&#10;    }&#10;&#10;    fun openDatePicker() {&#10;        val c = dateCal&#10;        android.app.DatePickerDialog(context, { _, y, m, d -&gt; c.set(y, m, d); dateCal = c }, c.get(Calendar.YEAR), c.get(Calendar.MONTH), c.get(Calendar.DAY_OF_MONTH)).show()&#10;    }&#10;    fun openTimePicker() {&#10;        val c = dateCal&#10;        android.app.TimePickerDialog(context, { _, h, min -&gt; c.set(Calendar.HOUR_OF_DAY, h); c.set(Calendar.MINUTE, min); dateCal = c }, c.get(Calendar.HOUR_OF_DAY), c.get(Calendar.MINUTE), true).show()&#10;    }&#10;&#10;    AlertDialog(onDismissRequest = onDismiss, title = { Text(&quot;Editar Evento&quot;) }, text = {&#10;        Column {&#10;            OutlinedTextField(value = title, onValueChange = { title = it }, label = { Text(&quot;Título&quot;) }, singleLine = true)&#10;            Spacer(Modifier.height(8.dp))&#10;            OutlinedTextField(value = description, onValueChange = { description = it }, label = { Text(&quot;Descripción&quot;) })&#10;            Spacer(Modifier.height(8.dp))&#10;            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                Text(&quot;Fecha: ${SimpleDateFormat(&quot;dd/MM/yyyy&quot;, Locale.getDefault()).format(dateCal.time)}&quot;)&#10;                Spacer(Modifier.width(8.dp))&#10;                TextButton(onClick = { openDatePicker() }) { Text(&quot;Seleccionar fecha&quot;) }&#10;            }&#10;            Spacer(Modifier.height(8.dp))&#10;            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                Text(&quot;Hora: ${String.format(Locale.getDefault(), &quot;%02d:%02d&quot;, dateCal.get(Calendar.HOUR_OF_DAY), dateCal.get(Calendar.MINUTE))}&quot;)&#10;                Spacer(Modifier.width(8.dp))&#10;                TextButton(onClick = { openTimePicker() }) { Text(&quot;Seleccionar hora&quot;) }&#10;            }&#10;            Spacer(Modifier.height(8.dp))&#10;            Column(modifier = Modifier.fillMaxWidth()) {&#10;                EventType.entries.forEach { ev -&gt;&#10;                    Row(&#10;                        verticalAlignment = Alignment.CenterVertically,&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(vertical = 4.dp)&#10;                    ) {&#10;                        RadioButton(selected = type == ev, onClick = { type = ev })&#10;                        Spacer(Modifier.width(8.dp))&#10;                        Text(ev.name, modifier = Modifier.weight(1f))&#10;                    }&#10;                }&#10;            }&#10;&#10;            // target course selection for teachers&#10;            if (role == Role.DOCENTE) {&#10;                Spacer(Modifier.height(8.dp))&#10;                Text(&quot;Curso objetivo (opcional):&quot;, style = MaterialTheme.typography.labelMedium)&#10;                // mostrar cursos disponibles para el docente&#10;                LazyColumn(&#10;                    modifier = Modifier.heightIn(max = 200.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(4.dp)&#10;                ) {&#10;                    items(userCourses) { course -&gt;&#10;                        val isSelected = targetCourseId == course.first&#10;                        Row(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .clickable { targetCourseId = if (isSelected) null else course.first }&#10;                                .padding(8.dp)&#10;                                .background(&#10;                                    color = if (isSelected) MaterialTheme.colorScheme.primary.copy(alpha = 0.2f) else Color.Transparent,&#10;                                    shape = CircleShape&#10;                                ),&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            Text(course.second, modifier = Modifier.weight(1f))&#10;                            if (isSelected) {&#10;                                Icon(Icons.Filled.Check, contentDescription = &quot;Seleccionado&quot;, tint = MaterialTheme.colorScheme.primary)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }, confirmButton = {&#10;        TextButton(onClick = { onSave(CalendarEvent(event.id, title, description, dateCal.time, type, event.source, targetCourseId)) }) { Text(&quot;Guardar&quot;) }&#10;    }, dismissButton = { TextButton(onClick = onDismiss) { Text(&quot;Cerrar&quot;) } })&#10;}&#10;&#10;// helper to load upcoming events paginated&#10;private fun loadMoreUpcoming(db: FirebaseFirestore, auth: FirebaseAuth, dest: MutableList&lt;CalendarEvent&gt;, courseIds: List&lt;String&gt; = emptyList(), lastSnapshot: DocumentSnapshot? = null, cbLast: (DocumentSnapshot?) -&gt; Unit) {&#10;    val uid = auth.currentUser?.uid ?: return&#10;    val col = db.collection(&quot;users&quot;).document(uid).collection(&quot;events&quot;)&#10;    val PAGE_SIZE = 25&#10;    try {&#10;        var q = col.whereGreaterThanOrEqualTo(&quot;date&quot;, Timestamp.now()).orderBy(&quot;date&quot;)&#10;        if (lastSnapshot != null) q = q.startAfter(lastSnapshot)&#10;        q = q.limit(PAGE_SIZE.toLong())&#10;        q.get().addOnSuccessListener { snap -&gt;&#10;            val docs = snap.documents&#10;            for (doc in docs) {&#10;                val id = doc.id&#10;                val title = doc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                val description = doc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                val ts = doc.get(&quot;date&quot;)&#10;                val d = when (ts) {&#10;                    is Timestamp -&gt; ts.toDate()&#10;                    is Date -&gt; ts&#10;                    else -&gt; null&#10;                }&#10;                val type = try { EventType.valueOf(doc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                val owner = doc.getString(&quot;ownerId&quot;)&#10;                if (d != null) dest.add(CalendarEvent(id, title, description, d, type, EventSource.USER, owner))&#10;            }&#10;            cbLast(docs.lastOrNull())&#10;             // additionally fetch upcoming global events for user's courses (no strict pagination)&#10;             if (courseIds.isNotEmpty()) {&#10;                 courseIds.chunked(10).forEach { chunk -&gt;&#10;                     db.collection(&quot;events&quot;).whereIn(&quot;courseId&quot;, chunk).whereGreaterThanOrEqualTo(&quot;date&quot;, Timestamp.now()).orderBy(&quot;date&quot;).limit(PAGE_SIZE.toLong()).get().addOnSuccessListener { gsnap -&gt;&#10;                         for (gdoc in gsnap.documents) {&#10;                             val id = gdoc.id&#10;                             if (dest.any { it.id == id }) continue&#10;                             val title = gdoc.getString(&quot;title&quot;) ?: &quot;Evento&quot;&#10;                             val description = gdoc.getString(&quot;description&quot;) ?: &quot;&quot;&#10;                             val ts = gdoc.get(&quot;date&quot;)&#10;                             val d = when (ts) { is Timestamp -&gt; ts.toDate(); is Date -&gt; ts; else -&gt; null }&#10;                             val type = try { EventType.valueOf(gdoc.getString(&quot;type&quot;) ?: EventType.EVENTO.name) } catch (_: Exception) { EventType.EVENTO }&#10;                             val courseId = gdoc.getString(&quot;courseId&quot;)&#10;                             if (d != null) dest.add(CalendarEvent(id, title, description, d, type, EventSource.GLOBAL, courseId))&#10;                         }&#10;                     }&#10;                 }&#10;             }&#10;         }&#10;     } catch (_: Exception) {&#10;         // ignore&#10;         cbLast(null)&#10;     }&#10; }&#10;&#10;// helper: crea notificaciones en users/{id}/notifications&#10;fun createNotifsForIds(ids: List&lt;String&gt;, title: String, body: String, relatedId: String, db: FirebaseFirestore, auth: FirebaseAuth) {&#10;     if (ids.isEmpty()) return&#10;    // fallback sender used if name lookup fails&#10;    val fallbackSender = auth.currentUser?.email ?: auth.currentUser?.uid ?: &quot;Profesor&quot;&#10;    for (sid in ids) {&#10;        try {&#10;            val notif = hashMapOf(&#10;                &quot;titulo&quot; to title,&#10;                &quot;cuerpo&quot; to body.take(200),&#10;                &quot;remitente&quot; to fallbackSender,&#10;                &quot;senderName&quot; to fallbackSender,&#10;                &quot;fechaHora&quot; to Timestamp.now(),&#10;                &quot;leida&quot; to false,&#10;                &quot;relatedId&quot; to relatedId,&#10;                &quot;type&quot; to &quot;event&quot;&#10;            )&#10;            db.collection(&quot;users&quot;).document(sid).collection(&quot;notifications&quot;).add(notif)&#10;        } catch (_: Exception) { }&#10;    }&#10;}&#10;&#10;// Resolve current user's display name then call createNotifsForIds with senderName set&#10;fun resolveAndCreateNotifs(ids: List&lt;String&gt;, title: String, body: String, relatedId: String, db: FirebaseFirestore, auth: FirebaseAuth) {&#10;    val uid = auth.currentUser?.uid&#10;    if (uid == null) {&#10;        createNotifsForIds(ids, title, body, relatedId, db, auth)&#10;        return&#10;    }&#10;    try {&#10;        db.collection(&quot;users&quot;).document(uid).get().addOnSuccessListener { doc -&gt;&#10;            val name = doc.getString(&quot;name&quot;) ?: doc.getString(&quot;displayName&quot;) ?: auth.currentUser?.email ?: uid&#10;            // create notifications with senderName field&#10;            for (sid in ids) {&#10;                try {&#10;                    val notif = hashMapOf(&#10;                        &quot;titulo&quot; to title,&#10;                        &quot;cuerpo&quot; to body.take(200),&#10;                        &quot;remitente&quot; to uid,&#10;                        &quot;senderName&quot; to name,&#10;                        &quot;fechaHora&quot; to Timestamp.now(),&#10;                        &quot;leida&quot; to false,&#10;                        &quot;relatedId&quot; to relatedId,&#10;                        &quot;type&quot; to &quot;event&quot;&#10;                    )&#10;                    db.collection(&quot;users&quot;).document(sid).collection(&quot;notifications&quot;).add(notif)&#10;                } catch (_: Exception) {}&#10;            }&#10;        }.addOnFailureListener {&#10;            createNotifsForIds(ids, title, body, relatedId, db, auth)&#10;        }&#10;    } catch (_: Exception) {&#10;        createNotifsForIds(ids, title, body, relatedId, db, auth)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/appcolegios/admin/AdminEventCreateScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/appcolegios/admin/AdminEventCreateScreen.kt" />
              <option name="originalContent" value="&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="package com.example.appcolegios.admin&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.google.firebase.Timestamp&#10;import kotlinx.coroutines.launch&#10;import androidx.navigation.NavController&#10;import kotlinx.coroutines.tasks.await&#10;import androidx.compose.ui.platform.LocalContext&#10;import java.util.Calendar&#10;&#10;@Composable&#10;fun AdminEventCreateScreen(navController: NavController? = null) {&#10;    val db = FirebaseFirestore.getInstance()&#10;    val scope = rememberCoroutineScope()&#10;    val context = LocalContext.current&#10;&#10;    var title by remember { mutableStateOf(&quot;&quot;) }&#10;    var body by remember { mutableStateOf(&quot;&quot;) }&#10;    // Fecha/hora del evento (por defecto ahora)&#10;    var dateCal by remember { mutableStateOf(Calendar.getInstance()) }&#10;    var isLoading by remember { mutableStateOf(false) }&#10;    var status by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;    fun openDatePicker() {&#10;        val c = dateCal&#10;        android.app.DatePickerDialog(context, { _, y, m, d -&gt;&#10;            c.set(Calendar.YEAR, y)&#10;            c.set(Calendar.MONTH, m)&#10;            c.set(Calendar.DAY_OF_MONTH, d)&#10;            dateCal = c&#10;        }, c.get(Calendar.YEAR), c.get(Calendar.MONTH), c.get(Calendar.DAY_OF_MONTH)).show()&#10;    }&#10;    fun openTimePicker() {&#10;        val c = dateCal&#10;        android.app.TimePickerDialog(context, { _, hour, minute -&gt;&#10;            c.set(Calendar.HOUR_OF_DAY, hour)&#10;            c.set(Calendar.MINUTE, minute)&#10;            c.set(Calendar.SECOND, 0)&#10;            dateCal = c&#10;        }, c.get(Calendar.HOUR_OF_DAY), c.get(Calendar.MINUTE), true).show()&#10;    }&#10;&#10;    Column(Modifier.fillMaxSize().padding(16.dp), verticalArrangement = Arrangement.spacedBy(12.dp)) {&#10;        Text(&quot;Crear Evento / Notificación&quot;, style = MaterialTheme.typography.headlineSmall)&#10;        OutlinedTextField(value = title, onValueChange = { title = it }, label = { Text(&quot;Título&quot;) }, modifier = Modifier.fillMaxWidth())&#10;        OutlinedTextField(value = body, onValueChange = { body = it }, label = { Text(&quot;Cuerpo&quot;) }, modifier = Modifier.fillMaxWidth())&#10;&#10;        Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {&#10;            Button(onClick = { openDatePicker() }) { Text(&quot;Seleccionar fecha&quot;) }&#10;            Button(onClick = { openTimePicker() }) { Text(&quot;Seleccionar hora&quot;) }&#10;            Text(&quot;${java.text.SimpleDateFormat(&quot;dd/MM/yyyy HH:mm&quot;).format(dateCal.time)}&quot;)&#10;        }&#10;&#10;        Button(onClick = {&#10;            scope.launch {&#10;                isLoading = true&#10;                try {&#10;                    val eventId = db.collection(&quot;events&quot;).document().id&#10;                    val eventData = hashMapOf&lt;String, Any?&gt;(&#10;                        &quot;id&quot; to eventId,&#10;                        &quot;title&quot; to title,&#10;                        &quot;description&quot; to body,&#10;                        &quot;date&quot; to Timestamp(dateCal.time),&#10;                        &quot;type&quot; to &quot;EVENTO&quot;,&#10;                        &quot;createdAt&quot; to Timestamp.now(),&#10;                        &quot;senderName&quot; to &quot;ADMIN&quot;&#10;                    )&#10;                    // Guardar en top-level events&#10;                    db.collection(&quot;events&quot;).document(eventId).set(eventData).await()&#10;&#10;                    // Crear also global notification doc for audit/feeds&#10;                    val notifGlobal = hashMapOf(&#10;                        &quot;titulo&quot; to title,&#10;                        &quot;cuerpo&quot; to body,&#10;                        &quot;remitente&quot; to &quot;ADMIN&quot;,&#10;                        &quot;senderName&quot; to &quot;ADMIN&quot;,&#10;                        &quot;fechaHora&quot; to Timestamp.now(),&#10;                        &quot;leida&quot; to false,&#10;                        &quot;tipo&quot; to &quot;evento&quot;,&#10;                        &quot;relatedId&quot; to eventId&#10;                    )&#10;                    db.collection(&quot;notifications&quot;).add(notifGlobal).await()&#10;&#10;                    // Replicar notificaciones a cada usuario (users/{uid}/notifications)&#10;                    val usersSnap = db.collection(&quot;users&quot;).get().await()&#10;                    for (u in usersSnap.documents) {&#10;                        try {&#10;                            val localNotif = notifGlobal.toMutableMap()&#10;                            // para compatibilidad añadir 'type' también&#10;                            localNotif[&quot;type&quot;] = &quot;event&quot;&#10;                            db.collection(&quot;users&quot;).document(u.id).collection(&quot;notifications&quot;).add(localNotif).await()&#10;                        } catch (_: Exception) {&#10;                        }&#10;                    }&#10;&#10;                    status = &quot;Evento creado&quot;&#10;                    navController?.popBackStack()&#10;                } catch (e: Exception) {&#10;                    status = e.message&#10;                } finally {&#10;                    isLoading = false&#10;                }&#10;            }&#10;        }, enabled = !isLoading) {&#10;            Text(&quot;Crear y enviar&quot;)&#10;        }&#10;        if (status != null) Text(status!!)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/appcolegios/admin/AdminScheduleManageScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/appcolegios/admin/AdminScheduleManageScreen.kt" />
              <option name="originalContent" value="&#10;&#10;" />
              <option name="updatedContent" value="package com.example.appcolegios.admin&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import com.example.appcolegios.data.model.ClassSession&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.tasks.await&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.platform.LocalContext&#10;import java.util.Calendar&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Edit&#10;import androidx.compose.material.icons.filled.Delete&#10;&#10;@Composable&#10;fun AdminScheduleManageScreen(userIdArg: String? = null, onDone: () -&gt; Unit = {}) {&#10;    val db = FirebaseFirestore.getInstance()&#10;    val scope = rememberCoroutineScope()&#10;    val context = LocalContext.current&#10;&#10;    var userId by remember { mutableStateOf(userIdArg ?: &quot;&quot;) }&#10;    var sessions by remember { mutableStateOf&lt;List&lt;Pair&lt;String, ClassSession&gt;&gt;&gt;(emptyList()) }&#10;    var isLoading by remember { mutableStateOf(false) }&#10;    var error by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;    // Form state (used for create and edit)&#10;    var editingId by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    var formDay by remember { mutableStateOf(1) } // 1..7&#10;    var formSubject by remember { mutableStateOf(&quot;&quot;) }&#10;    var formTeacher by remember { mutableStateOf(&quot;&quot;) }&#10;    var formStart by remember { mutableStateOf(&quot;08:00&quot;) }&#10;    var formEnd by remember { mutableStateOf(&quot;09:00&quot;) }&#10;    var formClassroom by remember { mutableStateOf(&quot;&quot;) }&#10;&#10;    var showDeleteConfirm by remember { mutableStateOf(false) }&#10;    var toDeleteId by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;    suspend fun loadSessionsFor(uid: String) {&#10;        isLoading = true&#10;        error = null&#10;        try {&#10;            val snap = db.collection(&quot;students&quot;).document(uid).collection(&quot;schedule&quot;).get().await()&#10;            val list = mutableListOf&lt;Pair&lt;String, ClassSession&gt;&gt;()&#10;            for (doc in snap.documents) {&#10;                try {&#10;                    val cs = doc.toObject(ClassSession::class.java)&#10;                    if (cs != null) list.add(Pair(doc.id, cs))&#10;                } catch (_: Exception) {}&#10;            }&#10;            // sort by dayOfWeek then startTime&#10;            sessions = list.sortedWith(compareBy({ it.second.dayOfWeek }, { it.second.startTime }))&#10;        } catch (e: Exception) {&#10;            error = e.message&#10;            sessions = emptyList()&#10;        } finally {&#10;            isLoading = false&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(userId) {&#10;        if (userId.isBlank()) return@LaunchedEffect&#10;        loadSessionsFor(userId)&#10;    }&#10;&#10;    fun resetForm() {&#10;        editingId = null&#10;        formDay = 1&#10;        formSubject = &quot;&quot;&#10;        formTeacher = &quot;&quot;&#10;        formStart = &quot;08:00&quot;&#10;        formEnd = &quot;09:00&quot;&#10;        formClassroom = &quot;&quot;&#10;    }&#10;&#10;    fun fillFormFrom(id: String, cs: ClassSession) {&#10;        editingId = id&#10;        formDay = cs.dayOfWeek&#10;        formSubject = cs.subject&#10;        formTeacher = cs.teacher&#10;        formStart = cs.startTime&#10;        formEnd = cs.endTime&#10;        formClassroom = cs.classroom&#10;    }&#10;&#10;    Column(Modifier.fillMaxSize().padding(16.dp), verticalArrangement = Arrangement.spacedBy(12.dp)) {&#10;        Text(&quot;Gestionar Horario&quot;, style = MaterialTheme.typography.headlineSmall)&#10;&#10;        OutlinedTextField(value = userId, onValueChange = { userId = it }, label = { Text(&quot;UID de usuario (estudiante)&quot;) }, modifier = Modifier.fillMaxWidth())&#10;&#10;        Row(horizontalArrangement = Arrangement.spacedBy(8.dp), modifier = Modifier.fillMaxWidth()) {&#10;            Button(onClick = {&#10;                scope.launch {&#10;                    if (userId.isBlank()) { error = &quot;UID vacío&quot;; return@launch }&#10;                    loadSessionsFor(userId)&#10;                }&#10;            }) { Text(&quot;Cargar&quot;) }&#10;            Spacer(modifier = Modifier.weight(1f))&#10;            TextButton(onClick = { resetForm() }) { Text(&quot;Nuevo&quot;) }&#10;        }&#10;&#10;        if (isLoading) {&#10;            Box(Modifier.fillMaxWidth(), contentAlignment = Alignment.Center) { CircularProgressIndicator() }&#10;        }&#10;&#10;        // Formulario&#10;        Card(modifier = Modifier.fillMaxWidth()) {&#10;            Column(Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(8.dp)) {&#10;                Text(if (editingId == null) &quot;Crear sesión&quot; else &quot;Editar sesión&quot;, style = MaterialTheme.typography.titleMedium)&#10;&#10;                // Day of week selector&#10;                Row(verticalAlignment = Alignment.CenterVertically) {&#10;                    Text(&quot;Día:&quot;, modifier = Modifier.width(56.dp))&#10;                    val days = listOf(&quot;Lun&quot;,&quot;Mar&quot;,&quot;Mié&quot;,&quot;Jue&quot;,&quot;Vie&quot;,&quot;Sáb&quot;,&quot;Dom&quot;)&#10;                    var expanded by remember { mutableStateOf(false) }&#10;                    Box {&#10;                        Button(onClick = { expanded = true }) { Text(days[(formDay-1).coerceIn(0,6)]) }&#10;                        DropdownMenu(expanded = expanded, onDismissRequest = { expanded = false }) {&#10;                            days.forEachIndexed { idx, d -&gt;&#10;                                DropdownMenuItem(text = { Text(d) }, onClick = { formDay = idx+1; expanded = false })&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                OutlinedTextField(value = formSubject, onValueChange = { formSubject = it }, label = { Text(&quot;Materia&quot;) }, modifier = Modifier.fillMaxWidth())&#10;                OutlinedTextField(value = formTeacher, onValueChange = { formTeacher = it }, label = { Text(&quot;Profesor&quot;) }, modifier = Modifier.fillMaxWidth())&#10;&#10;                Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {&#10;                    OutlinedTextField(value = formStart, onValueChange = { formStart = it }, label = { Text(&quot;Inicio (HH:mm)&quot;) }, modifier = Modifier.weight(1f))&#10;                    OutlinedTextField(value = formEnd, onValueChange = { formEnd = it }, label = { Text(&quot;Fin (HH:mm)&quot;) }, modifier = Modifier.weight(1f))&#10;                }&#10;                OutlinedTextField(value = formClassroom, onValueChange = { formClassroom = it }, label = { Text(&quot;Aula&quot;) }, modifier = Modifier.fillMaxWidth())&#10;&#10;                Row(horizontalArrangement = Arrangement.spacedBy(8.dp), modifier = Modifier.fillMaxWidth()) {&#10;                    Button(onClick = {&#10;                        scope.launch {&#10;                            if (userId.isBlank()) { error = &quot;UID vacío&quot;; return@launch }&#10;                            if (formSubject.isBlank()) { error = &quot;Materia vacía&quot;; return@launch }&#10;                            val cs = ClassSession(dayOfWeek = formDay, subject = formSubject, teacher = formTeacher, startTime = formStart, endTime = formEnd, classroom = formClassroom)&#10;                            try {&#10;                                if (editingId == null) {&#10;                                    db.collection(&quot;students&quot;).document(userId).collection(&quot;schedule&quot;).add(cs).await()&#10;                                } else {&#10;                                    db.collection(&quot;students&quot;).document(userId).collection(&quot;schedule&quot;).document(editingId!!).set(cs).await()&#10;                                }&#10;                                // recargar&#10;                                loadSessionsFor(userId)&#10;                                resetForm()&#10;                            } catch (e: Exception) {&#10;                                error = e.message&#10;                            }&#10;                        }&#10;                    }) { Text(if (editingId == null) &quot;Guardar&quot; else &quot;Actualizar&quot;) }&#10;&#10;                    if (editingId != null) {&#10;                        OutlinedButton(onClick = { resetForm() }) { Text(&quot;Cancelar&quot;) }&#10;                    }&#10;                }&#10;&#10;                if (error != null) Text(error ?: &quot;&quot;, color = MaterialTheme.colorScheme.error)&#10;            }&#10;        }&#10;&#10;        Spacer(Modifier.height(8.dp))&#10;&#10;        Text(&quot;Sesiones&quot;, style = MaterialTheme.typography.titleMedium)&#10;&#10;        if (sessions.isEmpty()) {&#10;            Text(&quot;(sin sesiones)&quot;, color = MaterialTheme.colorScheme.onSurfaceVariant)&#10;        } else {&#10;            LazyColumn(contentPadding = PaddingValues(4.dp)) {&#10;                items(sessions) { pair -&gt;&#10;                    val id = pair.first&#10;                    val s = pair.second&#10;                    Card(modifier = Modifier.fillMaxWidth().padding(vertical = 4.dp)) {&#10;                        Row(modifier = Modifier.fillMaxWidth().padding(12.dp), verticalAlignment = Alignment.CenterVertically) {&#10;                            Column(modifier = Modifier.weight(1f)) {&#10;                                val days = listOf(&quot;Lunes&quot;,&quot;Martes&quot;,&quot;Miércoles&quot;,&quot;Jueves&quot;,&quot;Viernes&quot;,&quot;Sábado&quot;,&quot;Domingo&quot;)&#10;                                Text(s.subject, style = MaterialTheme.typography.titleMedium)&#10;                                Text(&quot;${days.getOrNull(s.dayOfWeek-1) ?: s.dayOfWeek} · ${s.startTime} - ${s.endTime} · ${s.classroom}&quot;)&#10;                            }&#10;                            IconButton(onClick = { fillFormFrom(id, s) }) { Icon(Icons.Filled.Edit, contentDescription = &quot;Editar&quot;) }&#10;                            IconButton(onClick = { toDeleteId = id; showDeleteConfirm = true }) { Icon(Icons.Filled.Delete, contentDescription = &quot;Borrar&quot;) }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(Modifier.weight(1f))&#10;&#10;        Button(onClick = onDone, modifier = Modifier.fillMaxWidth()) { Text(&quot;Listo&quot;) }&#10;    }&#10;&#10;    if (showDeleteConfirm &amp;&amp; toDeleteId != null) {&#10;        AlertDialog(onDismissRequest = { showDeleteConfirm = false; toDeleteId = null }, title = { Text(&quot;Confirmar&quot;) }, text = { Text(&quot;Eliminar sesión?&quot;) }, confirmButton = {&#10;            TextButton(onClick = {&#10;                scope.launch {&#10;                    try {&#10;                        if (!toDeleteId.isNullOrBlank() &amp;&amp; userId.isNotBlank()) {&#10;                            db.collection(&quot;students&quot;).document(userId).collection(&quot;schedule&quot;).document(toDeleteId!!).delete().await()&#10;                            loadSessionsFor(userId)&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        error = e.message&#10;                    } finally {&#10;                        showDeleteConfirm = false&#10;                        toDeleteId = null&#10;                    }&#10;                }&#10;            }) { Text(&quot;Eliminar&quot;) }&#10;        }, dismissButton = { TextButton(onClick = { showDeleteConfirm = false; toDeleteId = null }) { Text(&quot;Cancelar&quot;) } })&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/appcolegios/admin/AdminScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/appcolegios/admin/AdminScreen.kt" />
              <option name="originalContent" value="@file:Suppress(&quot;RedundantQualifierName&quot;, &quot;RemoveRedundantQualifierName&quot;, &quot;RedundantQualifiedName&quot;, &quot;RedundantQualifier&quot;, &quot;UNUSED&quot;, &quot;unused&quot;)&#10;&#10;package com.example.appcolegios.admin&#10;&#10;import android.content.Intent&#10;import android.net.Uri&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.google.firebase.Timestamp&#10;import kotlinx.coroutines.launch&#10;import java.io.BufferedReader&#10;import java.io.InputStreamReader&#10;import kotlinx.coroutines.tasks.await&#10;import com.example.appcolegios.data.UserData&#10;import com.example.appcolegios.data.UserPreferencesRepository&#10;import com.example.appcolegios.data.model.Role&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.runtime.collectAsState&#10;import com.example.appcolegios.auth.RegisterActivity&#10;import org.apache.poi.ss.usermodel.WorkbookFactory&#10;import java.io.BufferedInputStream&#10;import com.google.firebase.FirebaseApp&#10;import com.google.firebase.FirebaseOptions&#10;import com.google.firebase.auth.FirebaseAuth&#10;import org.apache.poi.ss.usermodel.Row&#10;import com.example.appcolegios.data.TestDataInitializer&#10;import com.google.firebase.firestore.FieldValue&#10;&#10;// Helper local para leer celdas de forma segura&#10;private fun safeCellValue(row: Row, index: Int): String? = row.getCell(index)?.toString()?.trim()?.takeIf { it.isNotBlank() }&#10;&#10;@Composable&#10;fun AdminScreen() {&#10;    val context = LocalContext.current&#10;    val userPrefs = remember { UserPreferencesRepository(context) }&#10;    val userData = userPrefs.userData.collectAsState(initial = UserData(null, null, null)).value&#10;    // Tratar rol nulo o vacío como ADMIN&#10;    val role = if (userData.role.isNullOrBlank()) Role.ADMIN else Role.fromString(userData.role)&#10;&#10;    if (role != Role.ADMIN) {&#10;        Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {&#10;            Text(&quot;No autorizado&quot;, color = MaterialTheme.colorScheme.error)&#10;        }&#10;        return&#10;    }&#10;&#10;    val scope = rememberCoroutineScope()&#10;    val db = remember { FirebaseFirestore.getInstance() }&#10;&#10;    var status by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    var isLoading by remember { mutableStateOf(false) }&#10;&#10;    val filePicker = rememberLauncherForActivityResult(ActivityResultContracts.OpenDocument()) { uri: Uri? -&gt;&#10;        if (uri != null) {&#10;            scope.launch {&#10;                isLoading = true&#10;                status = null&#10;                try {&#10;                    context.contentResolver.takePersistableUriPermission(uri, Intent.FLAG_GRANT_READ_URI_PERMISSION)&#10;                } catch (_: Exception) {}&#10;&#10;                // Intentar inicializar FirebaseApp secundaria (importer) si existe google-services&#10;                var authImporter: FirebaseAuth? = null&#10;                try {&#10;                    val opts = FirebaseOptions.fromResource(context)&#10;                    val importerApp = if (opts != null) {&#10;                        try { FirebaseApp.getInstance(&quot;importer&quot;) } catch (_: IllegalStateException) { FirebaseApp.initializeApp(context, opts, &quot;importer&quot;) }&#10;                    } else null&#10;                    authImporter = if (importerApp != null) FirebaseAuth.getInstance(importerApp) else null&#10;                } catch (_: Exception) { authImporter = null }&#10;&#10;                try {&#10;                    // Detectar por extensión si es CSV o XLSX&#10;                    val name = uri.lastPathSegment ?: &quot;&quot;&#10;                    val isXlsx = name.endsWith(&quot;.xlsx&quot;, ignoreCase = true) || name.endsWith(&quot;.xls&quot;, ignoreCase = true)&#10;                    var count = 0&#10;                    if (isXlsx) {&#10;                        // Leer con Apache POI&#10;                        context.contentResolver.openInputStream(uri)?.use { input -&gt;&#10;                            BufferedInputStream(input).use { bis -&gt;&#10;                                val wb = WorkbookFactory.create(bis)&#10;                                val sheet = wb.getSheetAt(0)&#10;                                for (r in 1..sheet.lastRowNum) {&#10;                                    val row = sheet.getRow(r) ?: continue&#10;                                    // Soportar dos formatos:&#10;                                    // Formato completo (9 cols): 0 nombre,1 apellidos,2 tipoDoc,3 numeroDoc,4 celular,5 direccion,6 email,7 pass,8 rol&#10;                                    // Formato compacto (&gt;=5 cols): 0 nombre,1 apellidos,2 tipo,3 email,4 role&#10;                                    val cellCount = row.lastCellNum?.toInt() ?: 0&#10;                                    var nombre = &quot;&quot;&#10;                                    var apellidos = &quot;&quot;&#10;                                    var tipo = &quot;&quot;&#10;                                    var email = &quot;&quot;&#10;                                    var pass: String? = null&#10;                                    var rol = &quot;ESTUDIANTE&quot;&#10;&#10;                                    if (cellCount &gt;= 9) {&#10;                                        nombre = row.getCell(0)?.toString()?.trim() ?: &quot;&quot;&#10;                                        @Suppress(&quot;RemoveRedundantQualifierName&quot;)&#10;                                        apellidos = safeCellValue(row, 1) ?: &quot;&quot;&#10;                                        @Suppress(&quot;RemoveRedundantQualifierName&quot;)&#10;                                        tipo = safeCellValue(row, 2) ?: &quot;&quot;&#10;                                        // salto campos intermedios&#10;                                        email = safeCellValue(row, 6) ?: &quot;&quot;&#10;                                        val cell7 = safeCellValue(row,7)&#10;                                        pass = cell7&#10;                                        // leer rol&#10;                                        val rawRol = safeCellValue(row,8) ?: &quot;&quot;&#10;                                        rol = if (rawRol.isBlank()) &quot;ESTUDIANTE&quot; else rawRol&#10;                                    } else if (cellCount &gt;= 5) {&#10;                                        nombre = safeCellValue(row, 0) ?: row.getCell(0)?.toString()?.trim() ?: &quot;&quot;&#10;                                        @Suppress(&quot;RemoveRedundantQualifierName&quot;)&#10;                                        apellidos = safeCellValue(row, 1) ?: &quot;&quot;&#10;                                        @Suppress(&quot;RemoveRedundantQualifierName&quot;)&#10;                                        tipo = safeCellValue(row, 2) ?: &quot;&quot;&#10;                                        email = safeCellValue(row, 3) ?: &quot;&quot;&#10;                                        rol = safeCellValue(row, 4) ?: &quot;ESTUDIANTE&quot;&#10;                                        // si hay columna 5 posible password&#10;                                        if (cellCount &gt; 5) pass = safeCellValue(row, 5)&#10;                                    } else {&#10;                                        // intentar una heuristica: buscar el primer email-like cell&#10;                                        for (c in 0 until cellCount) {&#10;                                            val v = row.getCell(c)?.toString()?.trim() ?: &quot;&quot;&#10;                                            if (v.contains(&quot;@&quot;)) { email = v; break }&#10;                                        }&#10;                                        nombre = row.getCell(0)?.toString()?.trim() ?: &quot;&quot;&#10;                                    }&#10;&#10;                                    if (email.isBlank() || nombre.isBlank()) continue&#10;&#10;                                    val roleParsed = when (rol.uppercase()) {&#10;                                        &quot;PADRE&quot;, &quot;PARENT&quot; -&gt; &quot;PADRE&quot;&#10;                                        &quot;DOCENTE&quot;, &quot;TEACHER&quot; -&gt; &quot;DOCENTE&quot;&#10;                                        &quot;ADMIN&quot;, &quot;ADMINISTRADOR&quot; -&gt; &quot;ADMIN&quot;&#10;                                        else -&gt; &quot;ESTUDIANTE&quot;&#10;                                    }&#10;&#10;                                    val coll = when (roleParsed) {&#10;                                        &quot;PADRE&quot; -&gt; &quot;parents&quot;&#10;                                        &quot;DOCENTE&quot; -&gt; &quot;teachers&quot;&#10;                                        &quot;ADMIN&quot; -&gt; &quot;admins&quot;&#10;                                        else -&gt; &quot;students&quot;&#10;                                    }&#10;&#10;                                    try {&#10;                                        if (pass != null &amp;&amp; authImporter != null) {&#10;                                            // Crear en Auth y guardar con UID&#10;                                            val res = authImporter.createUserWithEmailAndPassword(email, pass).await()&#10;                                            val uid = res.user?.uid ?: db.collection(coll).document().id&#10;                                            val data = hashMapOf(&#10;                                                &quot;nombres&quot; to nombre,&#10;                                                &quot;apellidos&quot; to apellidos,&#10;                                                &quot;email&quot; to email,&#10;                                                &quot;tipo&quot; to tipo,&#10;                                                &quot;role&quot; to roleParsed,&#10;                                                &quot;importedAt&quot; to Timestamp.now()&#10;                                            )&#10;                                            db.collection(coll).document(uid).set(data).await()&#10;                                            // Además, crear documento en la colección &quot;users&quot; para que la app lo encuentre&#10;                                            try {&#10;                                                val displayName = (&quot;$nombre $apellidos&quot;).trim()&#10;                                                val userMap = hashMapOf(&#10;                                                    &quot;displayName&quot; to displayName,&#10;                                                    &quot;email&quot; to email,&#10;                                                    &quot;role&quot; to roleParsed&#10;                                                )&#10;                                                db.collection(&quot;users&quot;).document(uid).set(userMap).await()&#10;                                            } catch (_: Exception) { }&#10;                                            // enviar verificacion de forma asíncrona y esperar&#10;                                            try {&#10;                                                res.user?.let { it.sendEmailVerification().await() }&#10;                                            } catch (_: Exception) { }&#10;                                            // Asegurarse de no dejar al importer autenticado&#10;                                            try { authImporter.signOut() } catch (_: Exception) {}&#10;                                        } else {&#10;                                            // Guardar doc y encolar petición para backend&#10;                                            val data = hashMapOf(&#10;                                                &quot;nombres&quot; to nombre,&#10;                                                &quot;apellidos&quot; to apellidos,&#10;                                                &quot;email&quot; to email,&#10;                                                &quot;tipo&quot; to tipo,&#10;                                                &quot;role&quot; to roleParsed,&#10;                                                &quot;importedAt&quot; to Timestamp.now()&#10;                                            )&#10;                                            db.collection(coll).add(data).await()&#10;                                            db.collection(&quot;auth_queue&quot;).add(hashMapOf(&#10;                                                &quot;email&quot; to email,&#10;                                                &quot;role&quot; to roleParsed,&#10;                                                &quot;displayName&quot; to (&quot;$nombre $apellidos&quot;).trim(),&#10;                                                &quot;requestedAt&quot; to Timestamp.now()&#10;                                            )).await()&#10;&#10;                                            // Cambio mínimo: crear también un documento en &quot;users&quot; para que la app tenga acceso al correo&#10;                                            try {&#10;                                                val userMap = hashMapOf(&#10;                                                    &quot;displayName&quot; to (&quot;$nombre $apellidos&quot;).trim(),&#10;                                                    &quot;email&quot; to email,&#10;                                                    &quot;role&quot; to roleParsed,&#10;                                                    &quot;importedAt&quot; to Timestamp.now()&#10;                                                )&#10;                                                db.collection(&quot;users&quot;).add(userMap).await()&#10;                                            } catch (_: Exception) { }&#10;&#10;                                            // Intentar enviar email de restablecimiento (si la cuenta ya existe esto ayudará al usuario a establecer contraseña)&#10;                                            try {&#10;                                                val mainAuth = FirebaseAuth.getInstance()&#10;                                                mainAuth.sendPasswordResetEmail(email).await()&#10;                                            } catch (_: Exception) { }&#10;                                        }&#10;                                        count++&#10;                                    } catch (e: Exception) {&#10;                                        // registrar error y continuar&#10;                                    }&#10;                                }&#10;                                wb.close()&#10;                            }&#10;                        }&#10;                    } else {&#10;                        // CSV (mantener comportamiento anterior, con intento de creación si hay password column)&#10;                        context.contentResolver.openInputStream(uri)?.use { input -&gt;&#10;                            val reader = BufferedReader(InputStreamReader(input))&#10;                            reader.readLine() // descartar encabezado&#10;                            var line: String?&#10;                            var localCount = 0&#10;                            while (true) {&#10;                                line = reader.readLine() ?: break&#10;                                val parts = line.split(',')&#10;                                if (parts.size &gt;= 3) {&#10;                                    val type = parts[0].trim().lowercase()&#10;                                    val email = parts[1].trim()&#10;                                    val name = parts[2].trim()&#10;                                    val parsedRole = when (parts.getOrNull(3)?.trim()?.uppercase()) {&#10;                                        &quot;PADRE&quot; -&gt; &quot;PADRE&quot;&#10;                                        &quot;DOCENTE&quot; -&gt; &quot;DOCENTE&quot;&#10;                                        &quot;ADMIN&quot; -&gt; &quot;ADMIN&quot;&#10;                                        else -&gt; &quot;ESTUDIANTE&quot;&#10;                                    }&#10;                                    val maybePass = parts.getOrNull(4)?.trim()?.takeIf { it.isNotBlank() }&#10;                                    val coll = when (parsedRole) {&#10;                                        &quot;PADRE&quot; -&gt; &quot;parents&quot;&#10;                                        &quot;DOCENTE&quot; -&gt; &quot;teachers&quot;&#10;                                        &quot;ADMIN&quot; -&gt; &quot;admins&quot;&#10;                                        else -&gt; &quot;students&quot;&#10;                                    }&#10;&#10;                                    try {&#10;                                        if (maybePass != null &amp;&amp; authImporter != null) {&#10;                                            val res = authImporter.createUserWithEmailAndPassword(email, maybePass).await()&#10;                                            val uid = res.user?.uid ?: db.collection(coll).document().id&#10;                                            db.collection(coll).document(uid).set(hashMapOf(&#10;                                                &quot;name&quot; to name,&#10;                                                &quot;email&quot; to email,&#10;                                                &quot;role&quot; to parsedRole,&#10;                                                &quot;type&quot; to type,&#10;                                                &quot;importedAt&quot; to Timestamp.now()&#10;                                            )).await()&#10;                                        } else {&#10;                                            db.collection(coll).add(hashMapOf(&#10;                                                &quot;email&quot; to email,&#10;                                                &quot;name&quot; to name,&#10;                                                &quot;role&quot; to parsedRole,&#10;                                                &quot;type&quot; to type,&#10;                                                &quot;importedAt&quot; to Timestamp.now()&#10;                                            )).await()&#10;                                            db.collection(&quot;auth_queue&quot;).add(hashMapOf(&#10;                                                &quot;email&quot; to email,&#10;                                                &quot;role&quot; to parsedRole,&#10;                                                &quot;displayName&quot; to name,&#10;                                                &quot;requestedAt&quot; to Timestamp.now()&#10;                                            )).await()&#10;                                        }&#10;                                        localCount++&#10;                                    } catch (e: Exception) {&#10;                                        // continuar&#10;                                    }&#10;                                }&#10;                            }&#10;                            count = localCount&#10;                        }&#10;                    }&#10;&#10;                    status = &quot;Se importaron $count registros correctamente.&quot;&#10;                } catch (e: Exception) {&#10;                    status = &quot;Error importando: ${e.message}&quot;&#10;                } finally {&#10;                    isLoading = false&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;    ) {&#10;        Text(&#10;            &quot;Panel de Administración&quot;,&#10;            style = MaterialTheme.typography.headlineMedium,&#10;            fontWeight = FontWeight.Bold&#10;        )&#10;&#10;        // Nueva tarjeta: Registrar usuario&#10;        Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(12.dp)) {&#10;            ElevatedCard(modifier = Modifier.weight(1f), onClick = {&#10;                // Lanzar RegisterActivity en modo admin (no afectar sesión)&#10;                val intent = android.content.Intent(context, RegisterActivity::class.java)&#10;                intent.putExtra(&quot;fromAdmin&quot;, true)&#10;                context.startActivity(intent)&#10;            }) {&#10;                Box(Modifier.height(84.dp).fillMaxWidth(), contentAlignment = Alignment.Center) {&#10;                    Text(&quot;Registrar usuario&quot;)&#10;                }&#10;            }&#10;&#10;            // Se eliminaron las tarjetas &quot;Accesos Admin&quot; y &quot;Dashboard&quot; para dejar solo la opción de registrar usuario&#10;            Spacer(modifier = Modifier.weight(1f))&#10;            Spacer(modifier = Modifier.weight(1f))&#10;        }&#10;&#10;        if (status != null) {&#10;            Card(&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = if (status!!.contains(&quot;Error&quot;))&#10;                        MaterialTheme.colorScheme.errorContainer&#10;                    else&#10;                        MaterialTheme.colorScheme.primaryContainer&#10;                )&#10;            ) {&#10;                Text(&#10;                    status!!,&#10;                    modifier = Modifier.padding(16.dp),&#10;                    color = if (status!!.contains(&quot;Error&quot;))&#10;                        MaterialTheme.colorScheme.onErrorContainer&#10;                    else&#10;                        MaterialTheme.colorScheme.onPrimaryContainer&#10;                )&#10;            }&#10;        }&#10;&#10;        if (isLoading) {&#10;            CircularProgressIndicator()&#10;        }&#10;&#10;        // Botón para inicializar datos de prueba&#10;        Card(&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.surface&#10;            ),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;        ) {&#10;            Column(Modifier.padding(16.dp)) {&#10;                Text(&#10;                    &quot;Inicializar Datos de Prueba&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;                Spacer(Modifier.height(8.dp))&#10;                Text(&#10;                    &quot;Crea usuarios de prueba con información completa:\n&quot; +&#10;                    &quot;• Estudiante: jcamilodiaz7@gmail.com\n&quot; +&#10;                    &quot;• Profesor: hermanitos605@gmail.com\n&quot; +&#10;                    &quot;• Admin: jcamilodiaz777@gmail.com\n&quot; +&#10;                    &quot;• Padre: hermanitos604@gmail.com&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium&#10;                )&#10;                Spacer(Modifier.height(12.dp))&#10;                Button(&#10;                    onClick = {&#10;                        scope.launch {&#10;                            isLoading = true&#10;                            status = null&#10;                            try {&#10;                                TestDataInitializer.initializeAllTestData()&#10;                                status = &quot;✅ Datos de prueba inicializados correctamente&quot;&#10;                            } catch (e: Exception) {&#10;                                status = &quot;❌ Error: ${e.message}&quot;&#10;                            } finally {&#10;                                isLoading = false&#10;                            }&#10;                        }&#10;                    },&#10;                    enabled = !isLoading,&#10;                    modifier = Modifier.fillMaxWidth()&#10;                ) {&#10;                    Text(&quot;Inicializar Datos de Prueba&quot;)&#10;                }&#10;            }&#10;        }&#10;&#10;        // Botón para importar desde CSV/XLSX&#10;        Button(&#10;            onClick = { filePicker.launch(arrayOf(&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;,&quot;text/*&quot;,&quot;text/csv&quot;,&quot;text/comma-separated-values&quot;)) },&#10;            enabled = !isLoading,&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            Text(&quot;Importar desde CSV / Excel (.xlsx)&quot;)&#10;        }&#10;&#10;        Text(&#10;            &quot;Formato CSV: tipo,email,nombre,rol\nEjemplo: estudiante,juan@mail.com,Juan Pérez,ESTUDIANTE&quot;,&#10;            style = MaterialTheme.typography.bodySmall,&#10;            color = MaterialTheme.colorScheme.onSurfaceVariant&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="@file:Suppress(&quot;RedundantQualifierName&quot;, &quot;RemoveRedundantQualifierName&quot;, &quot;RedundantQualifiedName&quot;, &quot;RedundantQualifier&quot;, &quot;UNUSED&quot;, &quot;unused&quot;)&#13;&#10;&#13;&#10;package com.example.appcolegios.admin&#13;&#10;&#13;&#10;import android.content.Intent&#13;&#10;import android.net.Uri&#13;&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#13;&#10;import androidx.activity.result.contract.ActivityResultContracts&#13;&#10;import androidx.compose.foundation.layout.*&#13;&#10;import androidx.compose.material3.*&#13;&#10;import androidx.compose.runtime.*&#13;&#10;import androidx.compose.ui.Alignment&#13;&#10;import androidx.compose.ui.Modifier&#13;&#10;import androidx.compose.ui.text.font.FontWeight&#13;&#10;import androidx.compose.ui.unit.dp&#13;&#10;import com.google.firebase.firestore.FirebaseFirestore&#13;&#10;import com.google.firebase.Timestamp&#13;&#10;import kotlinx.coroutines.launch&#13;&#10;import java.io.BufferedReader&#13;&#10;import java.io.InputStreamReader&#13;&#10;import kotlinx.coroutines.tasks.await&#13;&#10;import com.example.appcolegios.data.UserData&#13;&#10;import com.example.appcolegios.data.UserPreferencesRepository&#13;&#10;import com.example.appcolegios.data.model.Role&#13;&#10;import androidx.compose.ui.platform.LocalContext&#13;&#10;import androidx.compose.runtime.collectAsState&#13;&#10;import com.example.appcolegios.auth.RegisterActivity&#13;&#10;import org.apache.poi.ss.usermodel.WorkbookFactory&#13;&#10;import java.io.BufferedInputStream&#13;&#10;import com.google.firebase.FirebaseApp&#13;&#10;import com.google.firebase.FirebaseOptions&#13;&#10;import com.google.firebase.auth.FirebaseAuth&#13;&#10;import org.apache.poi.ss.usermodel.Row&#13;&#10;import com.example.appcolegios.data.TestDataInitializer&#13;&#10;import com.google.firebase.firestore.FieldValue&#13;&#10;import androidx.navigation.NavController&#13;&#10;import androidx.compose.foundation.clickable&#13;&#10;&#13;&#10;// Helper local para leer celdas de forma segura&#13;&#10;private fun safeCellValue(row: Row, index: Int): String? = row.getCell(index)?.toString()?.trim()?.takeIf { it.isNotBlank() }&#13;&#10;&#13;&#10;@Composable&#13;&#10;fun AdminScreen(navController: NavController? = null) {&#13;&#10;    val context = LocalContext.current&#13;&#10;    val userPrefs = remember { UserPreferencesRepository(context) }&#13;&#10;    val userData = userPrefs.userData.collectAsState(initial = UserData(null, null, null)).value&#13;&#10;    // Tratar rol nulo o vacío como ADMIN&#13;&#10;    val role = if (userData.role.isNullOrBlank()) Role.ADMIN else Role.fromString(userData.role)&#13;&#10;&#13;&#10;    if (role != Role.ADMIN) {&#13;&#10;        Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {&#13;&#10;            Text(&quot;No autorizado&quot;, color = MaterialTheme.colorScheme.error)&#13;&#10;        }&#13;&#10;        return&#13;&#10;    }&#13;&#10;&#13;&#10;    val scope = rememberCoroutineScope()&#13;&#10;    val db = remember { FirebaseFirestore.getInstance() }&#13;&#10;&#13;&#10;    var status by remember { mutableStateOf&lt;String?&gt;(null) }&#13;&#10;    var isLoading by remember { mutableStateOf(false) }&#13;&#10;&#13;&#10;    val filePicker = rememberLauncherForActivityResult(ActivityResultContracts.OpenDocument()) { uri: Uri? -&gt;&#13;&#10;        if (uri != null) {&#13;&#10;            scope.launch {&#13;&#10;                isLoading = true&#13;&#10;                status = null&#13;&#10;                try {&#13;&#10;                    context.contentResolver.takePersistableUriPermission(uri, Intent.FLAG_GRANT_READ_URI_PERMISSION)&#13;&#10;                } catch (_: Exception) {}&#13;&#10;&#13;&#10;                // Intentar inicializar FirebaseApp secundaria (importer) si existe google-services&#13;&#10;                var authImporter: FirebaseAuth? = null&#13;&#10;                try {&#13;&#10;                    val opts = FirebaseOptions.fromResource(context)&#13;&#10;                    val importerApp = if (opts != null) {&#13;&#10;                        try { FirebaseApp.getInstance(&quot;importer&quot;) } catch (_: IllegalStateException) { FirebaseApp.initializeApp(context, opts, &quot;importer&quot;) }&#13;&#10;                    } else null&#13;&#10;                    authImporter = if (importerApp != null) FirebaseAuth.getInstance(importerApp) else null&#13;&#10;                } catch (_: Exception) { authImporter = null }&#13;&#10;&#13;&#10;                try {&#13;&#10;                    // Detectar por extensión si es CSV o XLSX&#13;&#10;                    val name = uri.lastPathSegment ?: &quot;&quot;&#13;&#10;                    val isXlsx = name.endsWith(&quot;.xlsx&quot;, ignoreCase = true) || name.endsWith(&quot;.xls&quot;, ignoreCase = true)&#13;&#10;                    var count = 0&#13;&#10;                    if (isXlsx) {&#13;&#10;                        // Leer con Apache POI&#13;&#10;                        context.contentResolver.openInputStream(uri)?.use { input -&gt;&#13;&#10;                            BufferedInputStream(input).use { bis -&gt;&#13;&#10;                                val wb = WorkbookFactory.create(bis)&#13;&#10;                                val sheet = wb.getSheetAt(0)&#13;&#10;                                for (r in 1..sheet.lastRowNum) {&#13;&#10;                                    val row = sheet.getRow(r) ?: continue&#13;&#10;                                    // Soportar dos formatos:&#13;&#10;                                    // Formato completo (9 cols): 0 nombre,1 apellidos,2 tipoDoc,3 numeroDoc,4 celular,5 direccion,6 email,7 pass,8 rol&#13;&#10;                                    // Formato compacto (&gt;=5 cols): 0 nombre,1 apellidos,2 tipo,3 email,4 role&#13;&#10;                                    val cellCount = row.lastCellNum?.toInt() ?: 0&#13;&#10;                                    var nombre = &quot;&quot;&#13;&#10;                                    var apellidos = &quot;&quot;&#13;&#10;                                    var tipo = &quot;&quot;&#13;&#10;                                    var email = &quot;&quot;&#13;&#10;                                    var pass: String? = null&#13;&#10;                                    var rol = &quot;ESTUDIANTE&quot;&#13;&#10;&#13;&#10;                                    if (cellCount &gt;= 9) {&#13;&#10;                                        nombre = row.getCell(0)?.toString()?.trim() ?: &quot;&quot;&#13;&#10;                                        @Suppress(&quot;RemoveRedundantQualifierName&quot;)&#13;&#10;                                        apellidos = safeCellValue(row, 1) ?: &quot;&quot;&#13;&#10;                                        @Suppress(&quot;RemoveRedundantQualifierName&quot;)&#13;&#10;                                        tipo = safeCellValue(row, 2) ?: &quot;&quot;&#13;&#10;                                        // salto campos intermedios&#13;&#10;                                        email = safeCellValue(row, 6) ?: &quot;&quot;&#13;&#10;                                        val cell7 = safeCellValue(row,7)&#13;&#10;                                        pass = cell7&#13;&#10;                                        // leer rol&#13;&#10;                                        val rawRol = safeCellValue(row,8) ?: &quot;&quot;&#13;&#10;                                        rol = if (rawRol.isBlank()) &quot;ESTUDIANTE&quot; else rawRol&#13;&#10;                                    } else if (cellCount &gt;= 5) {&#13;&#10;                                        nombre = safeCellValue(row, 0) ?: row.getCell(0)?.toString()?.trim() ?: &quot;&quot;&#13;&#10;                                        @Suppress(&quot;RemoveRedundantQualifierName&quot;)&#13;&#10;                                        apellidos = safeCellValue(row, 1) ?: &quot;&quot;&#13;&#10;                                        @Suppress(&quot;RemoveRedundantQualifierName&quot;)&#13;&#10;                                        tipo = safeCellValue(row, 2) ?: &quot;&quot;&#13;&#10;                                        email = safeCellValue(row, 3) ?: &quot;&quot;&#13;&#10;                                        rol = safeCellValue(row, 4) ?: &quot;ESTUDIANTE&quot;&#13;&#10;                                        // si hay columna 5 posible password&#13;&#10;                                        if (cellCount &gt; 5) pass = safeCellValue(row, 5)&#13;&#10;                                    } else {&#13;&#10;                                        // intentar una heuristica: buscar el primer email-like cell&#13;&#10;                                        for (c in 0 until cellCount) {&#13;&#10;                                            val v = row.getCell(c)?.toString()?.trim() ?: &quot;&quot;&#13;&#10;                                            if (v.contains(&quot;@&quot;)) { email = v; break }&#13;&#10;                                        }&#13;&#10;                                        nombre = row.getCell(0)?.toString()?.trim() ?: &quot;&quot;&#13;&#10;                                    }&#13;&#10;&#13;&#10;                                    if (email.isBlank() || nombre.isBlank()) continue&#13;&#10;&#13;&#10;                                    val roleParsed = when (rol.uppercase()) {&#13;&#10;                                        &quot;PADRE&quot;, &quot;PARENT&quot; -&gt; &quot;PADRE&quot;&#13;&#10;                                        &quot;DOCENTE&quot;, &quot;TEACHER&quot; -&gt; &quot;DOCENTE&quot;&#13;&#10;                                        &quot;ADMIN&quot;, &quot;ADMINISTRADOR&quot; -&gt; &quot;ADMIN&quot;&#13;&#10;                                        else -&gt; &quot;ESTUDIANTE&quot;&#13;&#10;                                    }&#13;&#10;&#13;&#10;                                    val coll = when (roleParsed) {&#13;&#10;                                        &quot;PADRE&quot; -&gt; &quot;parents&quot;&#13;&#10;                                        &quot;DOCENTE&quot; -&gt; &quot;teachers&quot;&#13;&#10;                                        &quot;ADMIN&quot; -&gt; &quot;admins&quot;&#13;&#10;                                        else -&gt; &quot;students&quot;&#13;&#10;                                    }&#13;&#10;&#13;&#10;                                    try {&#13;&#10;                                        if (pass != null &amp;&amp; authImporter != null) {&#13;&#10;                                            // Crear en Auth y guardar con UID&#13;&#10;                                            val res = authImporter.createUserWithEmailAndPassword(email, pass).await()&#13;&#10;                                            val uid = res.user?.uid ?: db.collection(coll).document().id&#13;&#10;                                            val data = hashMapOf(&#13;&#10;                                                &quot;nombres&quot; to nombre,&#13;&#10;                                                &quot;apellidos&quot; to apellidos,&#13;&#10;                                                &quot;email&quot; to email,&#13;&#10;                                                &quot;tipo&quot; to tipo,&#13;&#10;                                                &quot;role&quot; to roleParsed,&#13;&#10;                                                &quot;importedAt&quot; to Timestamp.now()&#13;&#10;                                            )&#13;&#10;                                            db.collection(coll).document(uid).set(data).await()&#13;&#10;                                            // Además, crear documento en la colección &quot;users&quot; para que la app lo encuentre&#13;&#10;                                            try {&#13;&#10;                                                val displayName = (&quot;$nombre $apellidos&quot;).trim()&#13;&#10;                                                val userMap = hashMapOf(&#13;&#10;                                                    &quot;displayName&quot; to displayName,&#13;&#10;                                                    &quot;email&quot; to email,&#13;&#10;                                                    &quot;role&quot; to roleParsed&#13;&#10;                                                )&#13;&#10;                                                db.collection(&quot;users&quot;).document(uid).set(userMap).await()&#13;&#10;                                            } catch (_: Exception) { }&#13;&#10;                                            // enviar verificacion de forma asíncrona y esperar&#13;&#10;                                            try {&#13;&#10;                                                res.user?.let { it.sendEmailVerification().await() }&#13;&#10;                                            } catch (_: Exception) { }&#13;&#10;                                            // Asegurarse de no dejar al importer autenticado&#13;&#10;                                            try { authImporter.signOut() } catch (_: Exception) {}&#13;&#10;                                        } else {&#13;&#10;                                            // Guardar doc y encolar petición para backend&#13;&#10;                                            val data = hashMapOf(&#13;&#10;                                                &quot;nombres&quot; to nombre,&#13;&#10;                                                &quot;apellidos&quot; to apellidos,&#13;&#10;                                                &quot;email&quot; to email,&#13;&#10;                                                &quot;tipo&quot; to tipo,&#13;&#10;                                                &quot;role&quot; to roleParsed,&#13;&#10;                                                &quot;importedAt&quot; to Timestamp.now()&#13;&#10;                                            )&#13;&#10;                                            db.collection(coll).add(data).await()&#13;&#10;                                            db.collection(&quot;auth_queue&quot;).add(hashMapOf(&#13;&#10;                                                &quot;email&quot; to email,&#13;&#10;                                                &quot;role&quot; to roleParsed,&#13;&#10;                                                &quot;displayName&quot; to (&quot;$nombre $apellidos&quot;).trim(),&#13;&#10;                                                &quot;requestedAt&quot; to Timestamp.now()&#13;&#10;                                            )).await()&#13;&#10;&#13;&#10;                                            // Cambio mínimo: crear también un documento en &quot;users&quot; para que la app tenga acceso al correo&#13;&#10;                                            try {&#13;&#10;                                                val userMap = hashMapOf(&#13;&#10;                                                    &quot;displayName&quot; to (&quot;$nombre $apellidos&quot;).trim(),&#13;&#10;                                                    &quot;email&quot; to email,&#13;&#10;                                                    &quot;role&quot; to roleParsed,&#13;&#10;                                                    &quot;importedAt&quot; to Timestamp.now()&#13;&#10;                                                )&#13;&#10;                                                db.collection(&quot;users&quot;).add(userMap).await()&#13;&#10;                                            } catch (_: Exception) { }&#13;&#10;&#13;&#10;                                            // Intentar enviar email de restablecimiento (si la cuenta ya existe esto ayudará al usuario a establecer contraseña)&#13;&#10;                                            try {&#13;&#10;                                                val mainAuth = FirebaseAuth.getInstance()&#13;&#10;                                                mainAuth.sendPasswordResetEmail(email).await()&#13;&#10;                                            } catch (_: Exception) { }&#13;&#10;                                        }&#13;&#10;                                        count++&#13;&#10;                                    } catch (e: Exception) {&#13;&#10;                                        // registrar error y continuar&#13;&#10;                                    }&#13;&#10;                                }&#13;&#10;                                wb.close()&#13;&#10;                            }&#13;&#10;                        }&#13;&#10;                    } else {&#13;&#10;                        // CSV (mantener comportamiento anterior, con intento de creación si hay password column)&#13;&#10;                        context.contentResolver.openInputStream(uri)?.use { input -&gt;&#13;&#10;                            val reader = BufferedReader(InputStreamReader(input))&#13;&#10;                            reader.readLine() // descartar encabezado&#13;&#10;                            var line: String?&#13;&#10;                            var localCount = 0&#13;&#10;                            while (true) {&#13;&#10;                                line = reader.readLine() ?: break&#13;&#10;                                val parts = line.split(',')&#13;&#10;                                if (parts.size &gt;= 3) {&#13;&#10;                                    val type = parts[0].trim().lowercase()&#13;&#10;                                    val email = parts[1].trim()&#13;&#10;                                    val name = parts[2].trim()&#13;&#10;                                    val parsedRole = when (parts.getOrNull(3)?.trim()?.uppercase()) {&#13;&#10;                                        &quot;PADRE&quot; -&gt; &quot;PADRE&quot;&#13;&#10;                                        &quot;DOCENTE&quot; -&gt; &quot;DOCENTE&quot;&#13;&#10;                                        &quot;ADMIN&quot; -&gt; &quot;ADMIN&quot;&#13;&#10;                                        else -&gt; &quot;ESTUDIANTE&quot;&#13;&#10;                                    }&#13;&#10;                                    val maybePass = parts.getOrNull(4)?.trim()?.takeIf { it.isNotBlank() }&#13;&#10;                                    val coll = when (parsedRole) {&#13;&#10;                                        &quot;PADRE&quot; -&gt; &quot;parents&quot;&#13;&#10;                                        &quot;DOCENTE&quot; -&gt; &quot;teachers&quot;&#13;&#10;                                        &quot;ADMIN&quot; -&gt; &quot;admins&quot;&#13;&#10;                                        else -&gt; &quot;students&quot;&#13;&#10;                                    }&#13;&#10;&#13;&#10;                                    try {&#13;&#10;                                        if (maybePass != null &amp;&amp; authImporter != null) {&#13;&#10;                                            val res = authImporter.createUserWithEmailAndPassword(email, maybePass).await()&#13;&#10;                                            val uid = res.user?.uid ?: db.collection(coll).document().id&#13;&#10;                                            db.collection(coll).document(uid).set(hashMapOf(&#13;&#10;                                                &quot;name&quot; to name,&#13;&#10;                                                &quot;email&quot; to email,&#13;&#10;                                                &quot;role&quot; to parsedRole,&#13;&#10;                                                &quot;type&quot; to type,&#13;&#10;                                                &quot;importedAt&quot; to Timestamp.now()&#13;&#10;                                            )).await()&#13;&#10;                                        } else {&#13;&#10;                                            db.collection(coll).add(hashMapOf(&#13;&#10;                                                &quot;email&quot; to email,&#13;&#10;                                                &quot;name&quot; to name,&#13;&#10;                                                &quot;role&quot; to parsedRole,&#13;&#10;                                                &quot;type&quot; to type,&#13;&#10;                                                &quot;importedAt&quot; to Timestamp.now()&#13;&#10;                                            )).await()&#13;&#10;                                            db.collection(&quot;auth_queue&quot;).add(hashMapOf(&#13;&#10;                                                &quot;email&quot; to email,&#13;&#10;                                                &quot;role&quot; to parsedRole,&#13;&#10;                                                &quot;displayName&quot; to name,&#13;&#10;                                                &quot;requestedAt&quot; to Timestamp.now()&#13;&#10;                                            )).await()&#13;&#10;                                        }&#13;&#10;                                        localCount++&#13;&#10;                                    } catch (e: Exception) {&#13;&#10;                                        // continuar&#13;&#10;                                    }&#13;&#10;                                }&#13;&#10;                            }&#13;&#10;                            count = localCount&#13;&#10;                        }&#13;&#10;                    }&#13;&#10;&#13;&#10;                    status = &quot;Se importaron $count registros correctamente.&quot;&#13;&#10;                } catch (e: Exception) {&#13;&#10;                    status = &quot;Error importando: ${e.message}&quot;&#13;&#10;                } finally {&#13;&#10;                    isLoading = false&#13;&#10;                }&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    Column(&#13;&#10;        modifier = Modifier&#13;&#10;            .fillMaxSize()&#13;&#10;            .padding(16.dp),&#13;&#10;        verticalArrangement = Arrangement.spacedBy(16.dp)&#13;&#10;    ) {&#13;&#10;        Text(&#13;&#10;            &quot;Panel de Administración&quot;,&#13;&#10;            style = MaterialTheme.typography.headlineMedium,&#13;&#10;            fontWeight = FontWeight.Bold&#13;&#10;        )&#13;&#10;&#13;&#10;        // Nueva tarjeta: Registrar usuario&#13;&#10;        Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(12.dp)) {&#13;&#10;            ElevatedCard(modifier = Modifier.weight(1f), onClick = {&#13;&#10;                // Lanzar RegisterActivity en modo admin (no afectar sesión)&#13;&#10;                val intent = android.content.Intent(context, RegisterActivity::class.java)&#13;&#10;                intent.putExtra(&quot;fromAdmin&quot;, true)&#13;&#10;                context.startActivity(intent)&#13;&#10;            }) {&#13;&#10;                Box(Modifier.height(84.dp).fillMaxWidth(), contentAlignment = Alignment.Center) {&#13;&#10;                    Text(&quot;Registrar usuario&quot;)&#13;&#10;                }&#13;&#10;            }&#13;&#10;&#13;&#10;            // Botón para ver perfiles&#13;&#10;            ElevatedCard(modifier = Modifier.weight(1f), onClick = {&#13;&#10;                navController?.navigate(com.example.appcolegios.navigation.AppRoutes.AdminUsers.route)&#13;&#10;            }) {&#13;&#10;                Box(Modifier.height(84.dp).fillMaxWidth(), contentAlignment = Alignment.Center) {&#13;&#10;                    Text(&quot;Ver perfiles&quot;)&#13;&#10;                }&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        // Botones adicionales: gestionar horarios y crear evento/notification&#13;&#10;        Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(12.dp)) {&#13;&#10;            ElevatedCard(modifier = Modifier.weight(1f), onClick = {&#13;&#10;                // Navegar a pantalla de gestión de horarios (sin userId -&gt; lista o selección)&#13;&#10;                navController?.navigate(com.example.appcolegios.navigation.AppRoutes.AdminScheduleManage.route.replace(&quot;{userId}&quot;, &quot;&quot;))&#13;&#10;            }) {&#13;&#10;                Box(Modifier.height(84.dp).fillMaxWidth(), contentAlignment = Alignment.Center) {&#13;&#10;                    Text(&quot;Gestionar horarios&quot;)&#13;&#10;                }&#13;&#10;            }&#13;&#10;&#13;&#10;            ElevatedCard(modifier = Modifier.weight(1f), onClick = {&#13;&#10;                navController?.navigate(com.example.appcolegios.navigation.AppRoutes.AdminEventCreate.route)&#13;&#10;            }) {&#13;&#10;                Box(Modifier.height(84.dp).fillMaxWidth(), contentAlignment = Alignment.Center) {&#13;&#10;                    Text(&quot;Crear evento / Notificación&quot;)&#13;&#10;                }&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        if (status != null) {&#13;&#10;            Card(&#13;&#10;                colors = CardDefaults.cardColors(&#13;&#10;                    containerColor = if (status!!.contains(&quot;Error&quot;))&#13;&#10;                        MaterialTheme.colorScheme.errorContainer&#13;&#10;                    else&#13;&#10;                        MaterialTheme.colorScheme.primaryContainer&#13;&#10;                )&#13;&#10;            ) {&#13;&#10;                Text(&#13;&#10;                    status!!,&#13;&#10;                    modifier = Modifier.padding(16.dp),&#13;&#10;                    color = if (status!!.contains(&quot;Error&quot;))&#13;&#10;                        MaterialTheme.colorScheme.onErrorContainer&#13;&#10;                    else&#13;&#10;                        MaterialTheme.colorScheme.onPrimaryContainer&#13;&#10;                )&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        if (isLoading) {&#13;&#10;            CircularProgressIndicator()&#13;&#10;        }&#13;&#10;&#13;&#10;        // Botón para inicializar datos de prueba&#13;&#10;        Card(&#13;&#10;            colors = CardDefaults.cardColors(&#13;&#10;                containerColor = MaterialTheme.colorScheme.surface&#13;&#10;            ),&#13;&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#13;&#10;        ) {&#13;&#10;            Column(Modifier.padding(16.dp)) {&#13;&#10;                Text(&#13;&#10;                    &quot;Inicializar Datos de Prueba&quot;,&#13;&#10;                    style = MaterialTheme.typography.titleMedium,&#13;&#10;                    fontWeight = FontWeight.Bold&#13;&#10;                )&#13;&#10;                Spacer(Modifier.height(8.dp))&#13;&#10;                Text(&#13;&#10;                    &quot;Crea usuarios de prueba con información completa:\n&quot; +&#13;&#10;                    &quot;• Estudiante: jcamilodiaz7@gmail.com\n&quot; +&#13;&#10;                    &quot;• Profesor: hermanitos605@gmail.com\n&quot; +&#13;&#10;                    &quot;• Admin: jcamilodiaz777@gmail.com\n&quot; +&#13;&#10;                    &quot;• Padre: hermanitos604@gmail.com&quot;,&#13;&#10;                    style = MaterialTheme.typography.bodyMedium&#13;&#10;                )&#13;&#10;                Spacer(Modifier.height(12.dp))&#13;&#10;                Button(&#13;&#10;                    onClick = {&#13;&#10;                        scope.launch {&#13;&#10;                            isLoading = true&#13;&#10;                            status = null&#13;&#10;                            try {&#13;&#10;                                TestDataInitializer.initializeAllTestData()&#13;&#10;                                status = &quot;✅ Datos de prueba inicializados correctamente&quot;&#13;&#10;                            } catch (e: Exception) {&#13;&#10;                                status = &quot;❌ Error: ${e.message}&quot;&#13;&#10;                            } finally {&#13;&#10;                                isLoading = false&#13;&#10;                            }&#13;&#10;                        }&#13;&#10;                    },&#13;&#10;                    enabled = !isLoading,&#13;&#10;                    modifier = Modifier.fillMaxWidth()&#13;&#10;                ) {&#13;&#10;                    Text(&quot;Inicializar Datos de Prueba&quot;)&#13;&#10;                }&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        // Botón para importar desde CSV/XLSX&#13;&#10;        Button(&#13;&#10;            onClick = { filePicker.launch(arrayOf(&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;,&quot;text/*&quot;,&quot;text/csv&quot;,&quot;text/comma-separated-values&quot;)) },&#13;&#10;            enabled = !isLoading,&#13;&#10;            modifier = Modifier.fillMaxWidth()&#13;&#10;        ) {&#13;&#10;            Text(&quot;Importar desde CSV / Excel (.xlsx)&quot;)&#13;&#10;        }&#13;&#10;&#13;&#10;        Text(&#13;&#10;            &quot;Formato CSV: tipo,email,nombre,rol\nEjemplo: estudiante,juan@mail.com,Juan Pérez,ESTUDIANTE&quot;,&#13;&#10;            style = MaterialTheme.typography.bodySmall,&#13;&#10;            color = MaterialTheme.colorScheme.onSurfaceVariant&#13;&#10;        )&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/appcolegios/admin/AdminUsersScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/appcolegios/admin/AdminUsersScreen.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.example.appcolegios.admin&#10;&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.tasks.await&#10;import androidx.compose.ui.Alignment&#10;&#10;@Composable&#10;fun AdminUsersScreen(onUserSelected: (String) -&gt; Unit = {}) {&#10;    val db = FirebaseFirestore.getInstance()&#10;    val scope = rememberCoroutineScope()&#10;    var users by remember { mutableStateOf&lt;List&lt;Map&lt;String, Any&gt;&gt;&gt;(emptyList()) }&#10;    var isLoading by remember { mutableStateOf(true) }&#10;    var error by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;    LaunchedEffect(Unit) {&#10;        isLoading = true&#10;        try {&#10;            val snap = db.collection(&quot;users&quot;).get().await()&#10;            val list = mutableListOf&lt;Map&lt;String, Any&gt;&gt;()&#10;            for (doc in snap.documents) {&#10;                val map = doc.data?.toMutableMap() ?: mutableMapOf()&#10;                map[&quot;id&quot;] = doc.id&#10;                list.add(map)&#10;            }&#10;            users = list&#10;        } catch (e: Exception) {&#10;            error = e.message&#10;        } finally {&#10;            isLoading = false&#10;        }&#10;    }&#10;&#10;    if (isLoading) {&#10;        Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) { CircularProgressIndicator() }&#10;        return&#10;    }&#10;    if (error != null) {&#10;        Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) { Text(&quot;Error: $error&quot;) }&#10;        return&#10;    }&#10;&#10;    Card(Modifier.fillMaxSize().padding(8.dp)) {&#10;        LazyColumn(contentPadding = PaddingValues(8.dp)) {&#10;            items(users) { u -&gt;&#10;                val id = u[&quot;id&quot;] as? String ?: &quot;&quot;&#10;                val name = (u[&quot;displayName&quot;] as? String) ?: (u[&quot;name&quot;] as? String) ?: &quot;(sin nombre)&quot;&#10;                Column(modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .clickable { onUserSelected(id) }&#10;                    .padding(vertical = 8.dp)&#10;                ) {&#10;                    Text(name, style = MaterialTheme.typography.titleMedium)&#10;                    Spacer(Modifier.height(4.dp))&#10;                    Text(u[&quot;email&quot;] as? String ?: &quot;&quot;, style = MaterialTheme.typography.bodySmall)&#10;                }&#10;                Divider(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.08f))&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/appcolegios/auth/SplashActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/appcolegios/auth/SplashActivity.kt" />
              <option name="updatedContent" value="package com.example.appcolegios.auth&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.os.Handler&#10;import android.os.Looper&#10;import android.view.animation.Animation&#10;import android.view.animation.AnimationUtils&#10;import android.widget.ImageView&#10;import androidx.appcompat.app.AppCompatActivity&#10;import com.example.appcolegios.R&#10;&#10;class SplashActivity : AppCompatActivity() {&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_splash)&#10;&#10;        // Animación de fade in para el logo&#10;        val logoView: ImageView = findViewById(R.id.splashLogo)&#10;        val fadeIn: Animation = AnimationUtils.loadAnimation(this, R.anim.fade_in)&#10;        logoView.startAnimation(fadeIn)&#10;&#10;        // Al terminar la animación, iniciar LoginActivity&#10;        fadeIn.setAnimationListener(object : Animation.AnimationListener {&#10;            override fun onAnimationStart(animation: Animation) {}&#10;            override fun onAnimationRepeat(animation: Animation) {}&#10;            override fun onAnimationEnd(animation: Animation) {&#10;                // Retardo breve antes de iniciar&#10;                Handler(Looper.getMainLooper()).postDelayed({&#10;                    startActivity(Intent(this@SplashActivity, com.example.appcolegios.auth.LoginActivity::class.java))&#10;                    finish()&#10;                }, 300)&#10;            }&#10;        })&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/appcolegios/data/model/Models.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/appcolegios/data/model/Models.kt" />
              <option name="originalContent" value="@file:Suppress(&quot;unused&quot;) // Suprime warnings de modelos aún no referenciados (Guardian, enums y constantes) conservándolos para futuras funcionalidades&#10;&#10;package com.example.appcolegios.data.model&#10;&#10;import com.google.firebase.firestore.DocumentId&#10;import java.util.Date&#10;&#10;data class Student(&#10;    val id: String = &quot;&quot;,&#10;    val nombre: String = &quot;&quot;,&#10;    val curso: String = &quot;&quot;,&#10;    val grupo: String = &quot;&quot;,&#10;    val numeroLista: Int = 0,&#10;    val correoInstitucional: String = &quot;&quot;,&#10;    val eps: String = &quot;&quot;,&#10;    val estadoMatricula: String = &quot;&quot;,&#10;    val promedio: Double = 0.0,&#10;    val avatarUrl: String? = null&#10;)&#10;&#10;data class Guardian(&#10;    val id: String,&#10;    val nombre: String,&#10;    val telefono: String,&#10;    val parentesco: String&#10;)&#10;&#10;data class Grade(&#10;    val materiaId: String,&#10;    val materia: String,&#10;    val periodo: Int,&#10;    val calificacion: Double,&#10;    val ponderacion: Double&#10;)&#10;&#10;data class AttendanceEntry(&#10;    val fecha: Date,&#10;    val estado: AttendanceStatus&#10;)&#10;&#10;enum class AttendanceStatus {&#10;    PRESENTE, AUSENTE, TARDE&#10;}&#10;&#10;data class Homework(&#10;    val id: String,&#10;    val materia: String,&#10;    val titulo: String,&#10;    val descripcion: String,&#10;    val deadline: Date,&#10;    val progreso: Float,&#10;    val completada: Boolean&#10;)&#10;&#10;data class Notification(&#10;    @DocumentId val id: String = &quot;&quot;,&#10;    val titulo: String = &quot;&quot;,&#10;    val cuerpo: String = &quot;&quot;,&#10;    val remitente: String = &quot;&quot;,&#10;    val senderName: String? = null,&#10;    val fechaHora: Date = Date(0),&#10;    val avatarUrl: String? = null,&#10;    val leida: Boolean = false&#10;)&#10;&#10;data class Message(&#10;    val id: String = &quot;&quot;,&#10;    val fromId: String = &quot;&quot;,&#10;    val toId: String = &quot;&quot;,&#10;    val texto: String = &quot;&quot;,&#10;    val fechaHora: Date = Date(0),&#10;    val tipo: MessageType = MessageType.TEXTO,&#10;    val estado: MessageStatus = MessageStatus.ENVIADO&#10;)&#10;&#10;enum class MessageType {&#10;    TEXTO, IMAGEN&#10;}&#10;&#10;enum class MessageStatus {&#10;    ENVIADO, ENTREGADO, LEIDO&#10;}&#10;&#10;data class Event(&#10;    val id: String,&#10;    val titulo: String,&#10;    val fechaHora: Date,&#10;    val categoria: EventCategory,&#10;    val descripcion: String,&#10;    val icon: String? = null&#10;)&#10;&#10;enum class EventCategory {&#10;    ACADEMICO, ADMINISTRATIVO&#10;}&#10;&#10;enum class TransportMode {&#10;    A_PIE, BICICLETA, PUBLICO, PARTICULAR&#10;}&#10;&#10;enum class ArrivalStatus {&#10;    EN_CAMINO, LLEGADO&#10;}&#10;" />
              <option name="updatedContent" value="@file:Suppress(&quot;unused&quot;) // Suprime warnings de modelos aún no referenciados (Guardian, enums y constantes) conservándolos para futuras funcionalidades&#10;&#10;package com.example.appcolegios.data.model&#10;&#10;import com.google.firebase.firestore.DocumentId&#10;import java.util.Date&#10;&#10;data class Student(&#10;    val id: String = &quot;&quot;,&#10;    val nombre: String = &quot;&quot;,&#10;    val curso: String = &quot;&quot;,&#10;    val grupo: String = &quot;&quot;,&#10;    val numeroLista: Int = 0,&#10;    val correoInstitucional: String = &quot;&quot;,&#10;    val eps: String = &quot;&quot;,&#10;    val estadoMatricula: String = &quot;&quot;,&#10;    val promedio: Double = 0.0,&#10;    val avatarUrl: String? = null&#10;)&#10;&#10;data class Guardian(&#10;    val id: String,&#10;    val nombre: String,&#10;    val telefono: String,&#10;    val parentesco: String&#10;)&#10;&#10;data class Grade(&#10;    val materiaId: String,&#10;    val materia: String,&#10;    val periodo: Int,&#10;    val calificacion: Double,&#10;    val ponderacion: Double&#10;)&#10;&#10;data class AttendanceEntry(&#10;    val fecha: Date,&#10;    val estado: AttendanceStatus&#10;)&#10;&#10;enum class AttendanceStatus {&#10;    PRESENTE, AUSENTE, TARDE&#10;}&#10;&#10;data class Homework(&#10;    val id: String,&#10;    val materia: String,&#10;    val titulo: String,&#10;    val descripcion: String,&#10;    val deadline: Date,&#10;    val progreso: Float,&#10;    val completada: Boolean&#10;)&#10;&#10;data class Notification(&#10;    @DocumentId val id: String = &quot;&quot;,&#10;    val titulo: String = &quot;&quot;,&#10;    val cuerpo: String = &quot;&quot;,&#10;    val remitente: String = &quot;&quot;,&#10;    val senderName: String? = null,&#10;    val fechaHora: Date = Date(0),&#10;    val avatarUrl: String? = null,&#10;    val leida: Boolean = false,&#10;    // campo opcional para distinguir tipo de notificación (p.ej. &quot;evento&quot;)&#10;    val tipo: String? = null,&#10;    // id relacionado (por ejemplo eventId) para navegar desde notificación hacia recurso&#10;    val relatedId: String? = null&#10;)&#10;&#10;data class Message(&#10;    val id: String = &quot;&quot;,&#10;    val fromId: String = &quot;&quot;,&#10;    val toId: String = &quot;&quot;,&#10;    val texto: String = &quot;&quot;,&#10;    val fechaHora: Date = Date(0),&#10;    val tipo: MessageType = MessageType.TEXTO,&#10;    val estado: MessageStatus = MessageStatus.ENVIADO&#10;)&#10;&#10;enum class MessageType {&#10;    TEXTO, IMAGEN&#10;}&#10;&#10;enum class MessageStatus {&#10;    ENVIADO, ENTREGADO, LEIDO&#10;}&#10;&#10;data class Event(&#10;    val id: String,&#10;    val titulo: String,&#10;    val fechaHora: Date,&#10;    val categoria: EventCategory,&#10;    val descripcion: String,&#10;    val icon: String? = null&#10;)&#10;&#10;enum class EventCategory {&#10;    ACADEMICO, ADMINISTRATIVO&#10;}&#10;&#10;enum class TransportMode {&#10;    A_PIE, BICICLETA, PUBLICO, PARTICULAR&#10;}&#10;&#10;enum class ArrivalStatus {&#10;    EN_CAMINO, LLEGADO&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/appcolegios/mensajes/ChatScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/appcolegios/mensajes/ChatScreen.kt" />
              <option name="originalContent" value="package com.example.appcolegios.mensajes&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.text.KeyboardActions&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.automirrored.filled.Send&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.compose.ui.text.input.ImeAction&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.navigation.NavController&#10;import coil.compose.AsyncImage&#10;import com.example.appcolegios.R&#10;import com.example.appcolegios.data.model.Message&#10;import com.google.firebase.auth.FirebaseAuth&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ChatScreen(&#10;    navController: NavController,&#10;    otherUserId: String,&#10;    chatViewModel: ChatViewModel = viewModel()&#10;) {&#10;    val uiState by chatViewModel.uiState.collectAsState()&#10;    var text by remember { mutableStateOf(&quot;&quot;) }&#10;    val currentUserId = FirebaseAuth.getInstance().currentUser?.uid&#10;&#10;    LaunchedEffect(otherUserId) { chatViewModel.loadMessagesWith(otherUserId) }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = {&#10;                    Row(verticalAlignment = Alignment.CenterVertically) {&#10;                        AsyncImage(&#10;                            model = uiState.otherUserAvatarUrl,&#10;                            contentDescription = uiState.otherUserName ?: stringResource(R.string.chat),&#10;                            modifier = Modifier&#10;                                .size(36.dp)&#10;                                .clip(CircleShape),&#10;                            contentScale = ContentScale.Crop,&#10;                            fallback = painterResource(id = R.drawable.ic_launcher_foreground)&#10;                        )&#10;                        Spacer(modifier = Modifier.width(12.dp))&#10;                        Text(uiState.otherUserName ?: stringResource(R.string.chat))&#10;                    }&#10;                },&#10;                navigationIcon = {&#10;                    IconButton(onClick = { navController.popBackStack() }) {&#10;                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = stringResource(R.string.back))&#10;                    }&#10;                }&#10;            )&#10;        },&#10;        bottomBar = {&#10;            MessageInput(&#10;                text = text,&#10;                onTextChange = { text = it },&#10;                onSend = {&#10;                    if (text.isNotBlank()) {&#10;                        chatViewModel.sendMessage(text, otherUserId)&#10;                        text = &quot;&quot;&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    ) { paddingValues -&gt;&#10;        LazyColumn(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues)&#10;                .padding(horizontal = 8.dp),&#10;            reverseLayout = true&#10;        ) {&#10;            items(uiState.messages.reversed()) { message -&gt;&#10;                MessageBubble(message = message, isFromCurrentUser = message.fromId == currentUserId)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun MessageBubble(message: Message, isFromCurrentUser: Boolean) {&#10;    Row(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(vertical = 4.dp),&#10;        horizontalArrangement = if (isFromCurrentUser) Arrangement.End else Arrangement.Start&#10;    ) {&#10;        Box(&#10;            modifier = Modifier&#10;                .background(&#10;                    color = if (isFromCurrentUser) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.surfaceVariant,&#10;                    shape = RoundedCornerShape(12.dp)&#10;                )&#10;                .padding(horizontal = 12.dp, vertical = 8.dp)&#10;        ) {&#10;            Text(&#10;                text = message.texto,&#10;                color = if (isFromCurrentUser) MaterialTheme.colorScheme.onPrimary else MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun MessageInput(text: String, onTextChange: (String) -&gt; Unit, onSend: () -&gt; Unit) {&#10;    Surface(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        shadowElevation = 8.dp&#10;    ) {&#10;        Row(&#10;            modifier = Modifier.padding(horizontal = 8.dp, vertical = 4.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            OutlinedTextField(&#10;                value = text,&#10;                onValueChange = onTextChange,&#10;                modifier = Modifier.weight(1f),&#10;                placeholder = { Text(stringResource(R.string.write_message_placeholder)) },&#10;                keyboardOptions = KeyboardOptions(imeAction = ImeAction.Send),&#10;                keyboardActions = KeyboardActions(onSend = { onSend() })&#10;            )&#10;            IconButton(onClick = onSend) {&#10;                Icon(Icons.AutoMirrored.Filled.Send, contentDescription = stringResource(R.string.enviar_mensaje_cd))&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.appcolegios.mensajes&#13;&#10;&#13;&#10;import androidx.compose.foundation.background&#13;&#10;import androidx.compose.foundation.layout.*&#13;&#10;import androidx.compose.foundation.lazy.LazyColumn&#13;&#10;import androidx.compose.foundation.lazy.items&#13;&#10;import androidx.compose.foundation.shape.CircleShape&#13;&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#13;&#10;import androidx.compose.foundation.text.KeyboardActions&#13;&#10;import androidx.compose.foundation.text.KeyboardOptions&#13;&#10;import androidx.compose.material.icons.Icons&#13;&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#13;&#10;import androidx.compose.material.icons.automirrored.filled.Send&#13;&#10;import androidx.compose.material3.*&#13;&#10;import androidx.compose.runtime.*&#13;&#10;import androidx.compose.ui.Alignment&#13;&#10;import androidx.compose.ui.Modifier&#13;&#10;import androidx.compose.ui.draw.clip&#13;&#10;import androidx.compose.ui.layout.ContentScale&#13;&#10;import androidx.compose.ui.res.painterResource&#13;&#10;import androidx.compose.ui.res.stringResource&#13;&#10;import androidx.compose.ui.text.input.ImeAction&#13;&#10;import androidx.compose.ui.unit.dp&#13;&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#13;&#10;import androidx.navigation.NavController&#13;&#10;import coil.compose.AsyncImage&#13;&#10;import com.example.appcolegios.R&#13;&#10;import com.example.appcolegios.data.model.Message&#13;&#10;import com.google.firebase.auth.FirebaseAuth&#13;&#10;&#13;&#10;@OptIn(ExperimentalMaterial3Api::class)&#13;&#10;@Composable&#13;&#10;fun ChatScreen(&#13;&#10;    navController: NavController,&#13;&#10;    otherUserId: String,&#13;&#10;    chatViewModel: ChatViewModel = viewModel()&#13;&#10;) {&#13;&#10;    val uiState by chatViewModel.uiState.collectAsState()&#13;&#10;    var text by remember { mutableStateOf(&quot;&quot;) }&#13;&#10;    val currentUserId = FirebaseAuth.getInstance().currentUser?.uid&#13;&#10;&#13;&#10;    LaunchedEffect(otherUserId) { chatViewModel.loadMessagesWith(otherUserId) }&#13;&#10;&#13;&#10;    Scaffold(&#13;&#10;        topBar = {&#13;&#10;            TopAppBar(&#13;&#10;                title = {&#13;&#10;                    Row(verticalAlignment = Alignment.CenterVertically) {&#13;&#10;                        AsyncImage(&#13;&#10;                            model = uiState.otherUserAvatarUrl,&#13;&#10;                            contentDescription = uiState.otherUserName ?: stringResource(R.string.chat),&#13;&#10;                            modifier = Modifier&#13;&#10;                                .size(36.dp)&#13;&#10;                                .clip(CircleShape),&#13;&#10;                            contentScale = ContentScale.Crop,&#13;&#10;                            fallback = painterResource(id = R.drawable.ic_launcher_foreground)&#13;&#10;                        )&#13;&#10;                        Spacer(modifier = Modifier.width(12.dp))&#13;&#10;                        Text(uiState.otherUserName ?: stringResource(R.string.chat))&#13;&#10;                    }&#13;&#10;                },&#13;&#10;                navigationIcon = {&#13;&#10;                    IconButton(onClick = { navController.popBackStack() }) {&#13;&#10;                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = stringResource(R.string.back))&#13;&#10;                    }&#13;&#10;                }&#13;&#10;            )&#13;&#10;        },&#13;&#10;        bottomBar = {&#13;&#10;            MessageInput(&#13;&#10;                text = text,&#13;&#10;                onTextChange = { text = it },&#13;&#10;                onSend = {&#13;&#10;                    if (text.isNotBlank()) {&#13;&#10;                        chatViewModel.sendMessage(text, otherUserId)&#13;&#10;                        text = &quot;&quot;&#13;&#10;                    }&#13;&#10;                }&#13;&#10;            )&#13;&#10;        }&#13;&#10;    ) { paddingValues -&gt;&#13;&#10;        LazyColumn(&#13;&#10;            modifier = Modifier&#13;&#10;                .fillMaxSize()&#13;&#10;                .padding(paddingValues)&#13;&#10;                .padding(horizontal = 8.dp),&#13;&#10;            reverseLayout = true&#13;&#10;        ) {&#13;&#10;            items(items = uiState.messages.reversed(), key = { it.id }) { message -&gt;&#13;&#10;                MessageBubble(message = message, isFromCurrentUser = message.fromId == currentUserId)&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;@Composable&#13;&#10;fun MessageBubble(message: Message, isFromCurrentUser: Boolean) {&#13;&#10;    Row(&#13;&#10;        modifier = Modifier&#13;&#10;            .fillMaxWidth()&#13;&#10;            .padding(vertical = 4.dp),&#13;&#10;        horizontalArrangement = if (isFromCurrentUser) Arrangement.End else Arrangement.Start&#13;&#10;    ) {&#13;&#10;        Box(&#13;&#10;            modifier = Modifier&#13;&#10;                .background(&#13;&#10;                    color = if (isFromCurrentUser) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.surfaceVariant,&#13;&#10;                    shape = RoundedCornerShape(12.dp)&#13;&#10;                )&#13;&#10;                .padding(horizontal = 12.dp, vertical = 8.dp)&#13;&#10;                .widthIn(max = 280.dp)&#13;&#10;        ) {&#13;&#10;            Text(&#13;&#10;                text = message.texto,&#13;&#10;                color = if (isFromCurrentUser) MaterialTheme.colorScheme.onPrimary else MaterialTheme.colorScheme.onSurfaceVariant&#13;&#10;            )&#13;&#10;        }&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;@Composable&#13;&#10;fun MessageInput(text: String, onTextChange: (String) -&gt; Unit, onSend: () -&gt; Unit) {&#13;&#10;    Surface(&#13;&#10;        modifier = Modifier.fillMaxWidth(),&#13;&#10;        shadowElevation = 8.dp&#13;&#10;    ) {&#13;&#10;        Row(&#13;&#10;            modifier = Modifier.padding(horizontal = 8.dp, vertical = 4.dp),&#13;&#10;            verticalAlignment = Alignment.CenterVertically&#13;&#10;        ) {&#13;&#10;            OutlinedTextField(&#13;&#10;                value = text,&#13;&#10;                onValueChange = onTextChange,&#13;&#10;                modifier = Modifier.weight(1f),&#13;&#10;                placeholder = { Text(stringResource(R.string.write_message_placeholder)) },&#13;&#10;                keyboardOptions = KeyboardOptions(imeAction = ImeAction.Send),&#13;&#10;                keyboardActions = KeyboardActions(onSend = { onSend() })&#13;&#10;            )&#13;&#10;            IconButton(onClick = onSend) {&#13;&#10;                Icon(Icons.AutoMirrored.Filled.Send, contentDescription = stringResource(R.string.enviar_mensaje_cd))&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/appcolegios/navigation/AppNavigation.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/appcolegios/navigation/AppNavigation.kt" />
              <option name="originalContent" value="@file:OptIn(ExperimentalMaterial3Api::class)&#10;&#10;package com.example.appcolegios.navigation&#10;&#10;import android.app.Activity&#10;import android.content.Intent&#10;import androidx.compose.animation.core.animateFloatAsState&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.Message&#10;import androidx.compose.material.icons.automirrored.filled.Logout&#10;import androidx.compose.material.icons.filled.Home&#10;import androidx.compose.material.icons.filled.Menu&#10;import androidx.compose.material.icons.filled.Notifications&#10;import androidx.compose.material.icons.filled.Person&#10;import androidx.compose.material.icons.filled.MoreVert&#10;import androidx.compose.material.icons.filled.CreditCard&#10;import androidx.compose.material.icons.filled.DirectionsBus&#10;import androidx.compose.material.icons.filled.School&#10;import androidx.compose.material.icons.automirrored.filled.Assignment&#10;import androidx.compose.material.icons.automirrored.filled.EventNote&#10;import androidx.compose.material.icons.filled.CalendarToday&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.compose.ui.unit.dp&#10;import androidx.navigation.NavDestination.Companion.hierarchy&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.compose.currentBackStackEntryAsState&#10;import androidx.navigation.compose.rememberNavController&#10;import com.example.appcolegios.R&#10;import com.example.appcolegios.academico.AttendanceScreen&#10;import com.example.appcolegios.academico.AnnouncementsScreen&#10;import com.example.appcolegios.academico.CalendarScreen&#10;import com.example.appcolegios.academico.ScheduleScreen&#10;import com.example.appcolegios.academico.NotesScreen&#10;import com.example.appcolegios.academico.TasksScreen&#10;import com.example.appcolegios.auth.LoginActivity&#10;import com.example.appcolegios.auth.RegisterScreen&#10;import com.example.appcolegios.auth.ResetPasswordScreen&#10;import com.example.appcolegios.auth.SplashScreen&#10;import com.example.appcolegios.home.HomeScreen&#10;import com.example.appcolegios.dashboard.DashboardScreen&#10;import com.example.appcolegios.mensajes.ChatScreen&#10;import com.example.appcolegios.mensajes.ConversationsScreen&#10;import com.example.appcolegios.mensajes.NewMessageScreen&#10;import com.example.appcolegios.notificaciones.NotificationsScreen&#10;import com.example.appcolegios.pagos.PaymentsScreen&#10;import com.example.appcolegios.perfil.ProfileScreen&#10;import com.example.appcolegios.transporte.TransportScreen&#10;import com.example.appcolegios.admin.AdminScreen&#10;import com.example.appcolegios.ubicacion.UbicacionScreen&#10;import kotlinx.coroutines.launch&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.appcolegios.data.UserPreferencesRepository&#10;import androidx.navigation.NavType&#10;import androidx.navigation.navArgument&#10;import android.widget.Toast&#10;import com.example.appcolegios.auth.VerifyEmailScreen&#10;import com.example.appcolegios.teacher.TeacherHomeScreen&#10;import com.example.appcolegios.student.StudentHomeScreen&#10;&#10;@Composable&#10;fun AppNavigation(&#10;    startDestination: String = AppRoutes.Splash.route,&#10;    initialRole: String? = null,&#10;    unreadNotificationsCount: Int = 0,&#10;    unreadMessagesCount: Int = 0&#10;) {&#10;    val navController = rememberNavController()&#10;    val backStackEntry = navController.currentBackStackEntryAsState().value&#10;    val currentDestination = backStackEntry?.destination&#10;&#10;    // Mostrar chrome en todas las rutas salvo pantallas de auth/splash&#10;    val authlessRoutes = setOf(&#10;        AppRoutes.Splash.route,&#10;        AppRoutes.Login.route,&#10;        AppRoutes.Register.route,&#10;        AppRoutes.VerifyEmail.route,&#10;        AppRoutes.ResetPassword.route&#10;    )&#10;&#10;    val showChrome = currentDestination?.route !in authlessRoutes&#10;&#10;    val drawerState = rememberDrawerState(DrawerValue.Closed)&#10;    val scope = rememberCoroutineScope()&#10;&#10;    val context = LocalContext.current&#10;    val userPrefs = UserPreferencesRepository(context)&#10;    val userData = userPrefs.userData.collectAsState(initial = com.example.appcolegios.data.UserData(null, null, null)).value&#10;    // Preferir el role inyectado (initialRole) para evitar condiciones de carrera; si no está, usar el de prefs&#10;    val roleString = if (!initialRole.isNullOrBlank()) initialRole else (userData.role ?: &quot;&quot; )&#10;    val isAdmin = roleString.equals(&quot;ADMIN&quot;, ignoreCase = true)&#10;    val isDocente = roleString.equals(&quot;DOCENTE&quot;, ignoreCase = true)&#10;    val isStudent = roleString.equals(&quot;ESTUDIANTE&quot;, ignoreCase = true)&#10;&#10;    val bottomItems = if (isAdmin) {&#10;        listOf(&#10;            // Para admin, Inicio debe llevar al Home (pantalla de inicio que muestra todas las opciones admin)&#10;            BottomItem(stringResource(R.string.home), AppRoutes.Home.route, Icons.Filled.Home),&#10;            BottomItem(stringResource(R.string.profile), AppRoutes.Profile.route, Icons.Filled.Person)&#10;        )&#10;    } else {&#10;        listOf(&#10;            BottomItem(stringResource(R.string.home), AppRoutes.Home.route, Icons.Filled.Home),&#10;            BottomItem(stringResource(R.string.messages), AppRoutes.Messages.route, Icons.AutoMirrored.Filled.Message),&#10;            BottomItem(stringResource(R.string.notifications), AppRoutes.Notifications.route, Icons.Filled.Notifications),&#10;            BottomItem(stringResource(R.string.schedule), AppRoutes.Schedule.route, Icons.Filled.CalendarToday),&#10;            BottomItem(stringResource(R.string.profile), AppRoutes.Profile.route, Icons.Filled.Person)&#10;        )&#10;    }&#10;&#10;    // Badges en tiempo real desde Firestore&#10;    val badgesVm: BadgesViewModel = viewModel()&#10;    val badgesState = badgesVm.state.collectAsState().value&#10;&#10;    val notifCount = if (badgesState.unreadNotifications &gt; 0) badgesState.unreadNotifications else unreadNotificationsCount&#10;    val msgCount = if (badgesState.unreadMessages &gt; 0) badgesState.unreadMessages else unreadMessagesCount&#10;&#10;    val content: @Composable () -&gt; Unit = {&#10;        NavHost(navController = navController, startDestination = startDestination) {&#10;            composable(AppRoutes.Splash.route) { SplashScreen(navController) }&#10;            composable(AppRoutes.Login.route) {&#10;                val localContext = LocalContext.current&#10;                LaunchedEffect(Unit) {&#10;                    val intent = Intent(localContext, LoginActivity::class.java)&#10;                    localContext.startActivity(intent)&#10;                    if (localContext is Activity) {&#10;                        localContext.finish()&#10;                    }&#10;                }&#10;                // Puedes mostrar una pantalla vacía o de carga mientras se lanza la actividad&#10;                Box(modifier = Modifier.fillMaxSize()) {}&#10;            }&#10;            composable(AppRoutes.Register.route) {&#10;                RegisterScreen(&#10;                    onRegisterSuccess = {&#10;                        // Mostrar mensaje de éxito y navegar a verificación de correo&#10;                        Toast.makeText(context, &quot;Registro exitoso. Verifica tu correo.&quot;, Toast.LENGTH_SHORT).show()&#10;                        navController.navigate(AppRoutes.VerifyEmail.route) {&#10;                            popUpTo(0) { inclusive = true }&#10;                        }&#10;                    },&#10;                    onNavigateToLogin = { navController.popBackStack() }&#10;                )&#10;            }&#10;            // Nueva ruta para registro desde Admin (solo crea documento en Firestore)&#10;            composable(AppRoutes.RegisterAdmin.route) {&#10;                RegisterScreen(&#10;                    onRegisterSuccess = {&#10;                        Toast.makeText(context, &quot;Usuario creado correctamente&quot;, Toast.LENGTH_SHORT).show()&#10;                        // Al crear desde admin solo volver al home del admin&#10;                        navController.navigate(AppRoutes.Home.route) {&#10;                            popUpTo(0) { inclusive = true }&#10;                        }&#10;                    },&#10;                    onNavigateToLogin = { navController.popBackStack() },&#10;                    createOnly = true&#10;                )&#10;            }&#10;            composable(AppRoutes.ResetPassword.route) {&#10;                ResetPasswordScreen(&#10;                    onPasswordResetSent = { navController.popBackStack() },&#10;                    onNavigateToLogin = { navController.popBackStack() }&#10;                )&#10;            }&#10;            composable(AppRoutes.Home.route) { HomeScreen(navController = navController) }&#10;            composable(AppRoutes.Profile.route) { ProfileScreen() }&#10;            composable(AppRoutes.Payments.route) { PaymentsScreen() }&#10;            composable(AppRoutes.Transport.route) { TransportScreen() }&#10;            composable(AppRoutes.Notes.route) {&#10;                if (isDocente) {&#10;                    com.example.appcolegios.academico.TeacherNotesScreen(navController = navController)&#10;                } else {&#10;                    NotesScreen()&#10;                }&#10;            }&#10;            composable(AppRoutes.Attendance.route) { AttendanceScreen() }&#10;            composable(AppRoutes.Announcements.route) { AnnouncementsScreen(navController) }&#10;            composable(AppRoutes.Tasks.route) { TasksScreen() }&#10;            // Ruta para calificar (Cursos -&gt; Estudiantes -&gt; Notas)&#10;            composable(AppRoutes.Grading.route) { com.example.appcolegios.academico.GradingScreen() }&#10;            composable(AppRoutes.Notifications.route) { NotificationsScreen() }&#10;            composable(AppRoutes.Messages.route) { ConversationsScreen(navController = navController) }&#10;            composable(AppRoutes.Calendar.route) { CalendarScreen() }&#10;            composable(AppRoutes.Schedule.route) { ScheduleScreen() }&#10;            composable(AppRoutes.Admin.route) { AdminScreen() }&#10;            composable(AppRoutes.TeacherHome.route) { TeacherHomeScreen(navController) }&#10;            composable(AppRoutes.StudentHome.route) { StudentHomeScreen(navController = navController) }&#10;            // Ruta Ubicación del colegio&#10;            composable(AppRoutes.Ubicacion.route) { UbicacionScreen() }&#10;            composable(&#10;                route = AppRoutes.Chat.route,&#10;                arguments = listOf(navArgument(&quot;otherUserId&quot;) { type = NavType.StringType })&#10;            ) { backStackEntry2 -&gt;&#10;                val otherUserId = backStackEntry2.arguments?.getString(&quot;otherUserId&quot;) ?: &quot;&quot;&#10;                ChatScreen(navController = navController, otherUserId = otherUserId)&#10;            }&#10;            composable(AppRoutes.NewMessage.route) {&#10;                NewMessageScreen(&#10;                    onUserSelected = { userId -&gt;&#10;                        navController.navigate(&quot;chat/$userId&quot;)&#10;                    },&#10;                    onBack = { navController.popBackStack() }&#10;                )&#10;            }&#10;            composable(AppRoutes.VerifyEmail.route) {&#10;                VerifyEmailScreen(onDone = { navController.navigate(AppRoutes.Splash.route) {&#10;                    popUpTo(0) { inclusive = true }&#10;                } }, onVerified = { dest -&gt;&#10;                    navController.navigate(dest) {&#10;                        popUpTo(0) { inclusive = true }&#10;                    }&#10;                })&#10;            }&#10;            composable(AppRoutes.Dashboard.route) { DashboardScreen() }&#10;        }&#10;    }&#10;&#10;    if (!showChrome) {&#10;        // Rutas de auth/splash sin chrome&#10;        content()&#10;    } else {&#10;        // Drawer lateral funcional con opciones&#10;        ModalNavigationDrawer(&#10;            drawerState = drawerState,&#10;            drawerContent = {&#10;                ModalDrawerSheet {&#10;                    Spacer(Modifier.height(12.dp))&#10;                    Text(&#10;                        &quot;Menú&quot;,&#10;                        modifier = Modifier.padding(16.dp),&#10;                        style = MaterialTheme.typography.titleLarge&#10;                    )&#10;                    HorizontalDivider()&#10;&#10;                    // Opción Home / Admin&#10;                    if (isAdmin) {&#10;                        // Drawer item para administradores: ir a Admin&#10;                        NavigationDrawerItem(&#10;                            icon = { Icon(Icons.Filled.Home, contentDescription = null) },&#10;                            label = { Text(stringResource(R.string.panel_admin)) },&#10;                            selected = currentDestination?.route == AppRoutes.Admin.route,&#10;                            onClick = {&#10;                                scope.launch { drawerState.close() }&#10;                                navController.navigate(AppRoutes.Admin.route) {&#10;                                    launchSingleTop = true&#10;                                    restoreState = true&#10;                                }&#10;                            },&#10;                            modifier = Modifier.padding(horizontal = 12.dp)&#10;                        )&#10;                    } else {&#10;                        // Opción Home para usuarios no-admin (restaurada: menú completo)&#10;                        NavigationDrawerItem(&#10;                            icon = { Icon(Icons.Filled.Home, contentDescription = null) },&#10;                            label = { Text(stringResource(R.string.home)) },&#10;                            selected = currentDestination?.route == AppRoutes.Home.route,&#10;                            onClick = {&#10;                                scope.launch { drawerState.close() }&#10;                                navController.navigate(AppRoutes.Home.route) {&#10;                                    launchSingleTop = true&#10;                                    restoreState = true&#10;                                }&#10;                            },&#10;                            modifier = Modifier.padding(horizontal = 12.dp)&#10;                        )&#10;&#10;                        // Mensajes&#10;                        NavigationDrawerItem(&#10;                            icon = { Icon(Icons.AutoMirrored.Filled.Message, contentDescription = null) },&#10;                            label = { Text(stringResource(R.string.messages)) },&#10;                            selected = currentDestination?.route == AppRoutes.Messages.route,&#10;                            onClick = {&#10;                                scope.launch { drawerState.close() }&#10;                                navController.navigate(AppRoutes.Messages.route) {&#10;                                    launchSingleTop = true&#10;                                    restoreState = true&#10;                                }&#10;                            },&#10;                            modifier = Modifier.padding(horizontal = 12.dp)&#10;                        )&#10;&#10;                        // Notificaciones&#10;                        NavigationDrawerItem(&#10;                            icon = { Icon(Icons.Filled.Notifications, contentDescription = null) },&#10;                            label = { Text(stringResource(R.string.notifications)) },&#10;                            selected = currentDestination?.route == AppRoutes.Notifications.route,&#10;                            onClick = {&#10;                                scope.launch { drawerState.close() }&#10;                                navController.navigate(AppRoutes.Notifications.route) {&#10;                                    launchSingleTop = true&#10;                                    restoreState = true&#10;                                }&#10;                            },&#10;                            modifier = Modifier.padding(horizontal = 12.dp)&#10;                        )&#10;&#10;                        // Pagos&#10;                        if (!isStudent &amp;&amp; !isDocente) {&#10;                            NavigationDrawerItem(&#10;                                icon = { Icon(Icons.Filled.CreditCard, contentDescription = null) },&#10;                                label = { Text(stringResource(R.string.payments)) },&#10;                                selected = currentDestination?.route == AppRoutes.Payments.route,&#10;                                onClick = {&#10;                                    scope.launch { drawerState.close() }&#10;                                    navController.navigate(AppRoutes.Payments.route) {&#10;                                        launchSingleTop = true&#10;                                        restoreState = true&#10;                                    }&#10;                                },&#10;                                modifier = Modifier.padding(horizontal = 12.dp)&#10;                            )&#10;                        }&#10;&#10;                        // Transporte&#10;                        NavigationDrawerItem(&#10;                            icon = { Icon(Icons.Filled.DirectionsBus, contentDescription = null) },&#10;                            label = { Text(stringResource(R.string.transporte)) },&#10;                            selected = currentDestination?.route == AppRoutes.Transport.route,&#10;                            onClick = {&#10;                                scope.launch { drawerState.close() }&#10;                                navController.navigate(AppRoutes.Transport.route) {&#10;                                    launchSingleTop = true&#10;                                    restoreState = true&#10;                                }&#10;                            },&#10;                            modifier = Modifier.padding(horizontal = 12.dp)&#10;                        )&#10;&#10;                        // Notas&#10;                        NavigationDrawerItem(&#10;                            icon = { Icon(Icons.Filled.School, contentDescription = null) },&#10;                            label = { Text(stringResource(R.string.notes)) },&#10;                            selected = currentDestination?.route == AppRoutes.Notes.route,&#10;                            onClick = {&#10;                                scope.launch { drawerState.close() }&#10;                                navController.navigate(AppRoutes.Notes.route) {&#10;                                    launchSingleTop = true&#10;                                    restoreState = true&#10;                                }&#10;                            },&#10;                            modifier = Modifier.padding(horizontal = 12.dp)&#10;                        )&#10;&#10;                        // Asistencia&#10;                        NavigationDrawerItem(&#10;                            icon = { Icon(Icons.AutoMirrored.Filled.Assignment, contentDescription = null) },&#10;                            label = { Text(stringResource(R.string.attendance)) },&#10;                            selected = currentDestination?.route == AppRoutes.Attendance.route,&#10;                            onClick = {&#10;                                scope.launch { drawerState.close() }&#10;                                navController.navigate(AppRoutes.Attendance.route) {&#10;                                    launchSingleTop = true&#10;                                    restoreState = true&#10;                                }&#10;                            },&#10;                            modifier = Modifier.padding(horizontal = 12.dp)&#10;                        )&#10;&#10;                        // Tareas&#10;                        NavigationDrawerItem(&#10;                            icon = { Icon(Icons.AutoMirrored.Filled.EventNote, contentDescription = null) },&#10;                            label = { Text(stringResource(R.string.tasks)) },&#10;                            selected = currentDestination?.route == AppRoutes.Tasks.route,&#10;                            onClick = {&#10;                                scope.launch { drawerState.close() }&#10;                                navController.navigate(AppRoutes.Tasks.route) {&#10;                                    launchSingleTop = true&#10;                                    restoreState = true&#10;                                }&#10;                            },&#10;                            modifier = Modifier.padding(horizontal = 12.dp)&#10;                        )&#10;&#10;                        // Calendario&#10;                        NavigationDrawerItem(&#10;                            icon = { Icon(Icons.Filled.CalendarToday, contentDescription = null) },&#10;                            label = { Text(stringResource(R.string.calendar)) },&#10;                            selected = currentDestination?.route == AppRoutes.Calendar.route,&#10;                            onClick = {&#10;                                scope.launch { drawerState.close() }&#10;                                navController.navigate(AppRoutes.Calendar.route) {&#10;                                    launchSingleTop = true&#10;                                    restoreState = true&#10;                                }&#10;                            },&#10;                            modifier = Modifier.padding(horizontal = 12.dp)&#10;                        )&#10;                    }&#10;&#10;                    // Opciones comunes: Perfil y Cerrar sesión&#10;                    NavigationDrawerItem(&#10;                        icon = { Icon(Icons.Filled.Person, contentDescription = null) },&#10;                        label = { Text(stringResource(R.string.profile)) },&#10;                        selected = currentDestination?.route == AppRoutes.Profile.route,&#10;                        onClick = {&#10;                            scope.launch { drawerState.close() }&#10;                            navController.navigate(AppRoutes.Profile.route) {&#10;                                launchSingleTop = true&#10;                                restoreState = true&#10;                            }&#10;                        },&#10;                        modifier = Modifier.padding(horizontal = 12.dp)&#10;                    )&#10;&#10;                    // Logout&#10;                    NavigationDrawerItem(&#10;                        icon = { Icon(Icons.AutoMirrored.Filled.Logout, contentDescription = null) },&#10;                        label = { Text(stringResource(R.string.logout)) },&#10;                        selected = false,&#10;                        onClick = {&#10;                            scope.launch { drawerState.close() }&#10;                            // limpiar datos locales y lanzar actividad de login para cerrar sesión&#10;                            scope.launch {&#10;                                try {&#10;                                    userPrefs.clearAllUserData()&#10;                                } catch (_: Exception) {}&#10;                                val activity = context as? Activity&#10;                                val intent = Intent(context, LoginActivity::class.java)&#10;                                context.startActivity(intent)&#10;                                activity?.finish()&#10;                            }&#10;                        },&#10;                        modifier = Modifier.padding(horizontal = 12.dp)&#10;                    )&#10;                }&#10;            }&#10;        ) {&#10;            Scaffold(&#10;                topBar = {&#10;                    var overflowOpen by androidx.compose.runtime.remember { androidx.compose.runtime.mutableStateOf(false) }&#10;                    CenterAlignedTopAppBar(&#10;                        title = {&#10;                            Text(&#10;                                when (currentDestination?.route) {&#10;                                    AppRoutes.Home.route -&gt; stringResource(R.string.home)&#10;                                    AppRoutes.Messages.route -&gt; stringResource(R.string.messages)&#10;                                    AppRoutes.Notifications.route -&gt; stringResource(R.string.notifications)&#10;                                    AppRoutes.Profile.route -&gt; stringResource(R.string.profile)&#10;                                    AppRoutes.Payments.route -&gt; stringResource(R.string.payments)&#10;                                    AppRoutes.Transport.route -&gt; stringResource(R.string.transporte)&#10;                                    AppRoutes.Notes.route -&gt; stringResource(R.string.notes)&#10;                                    AppRoutes.Attendance.route -&gt; stringResource(R.string.attendance)&#10;                                    AppRoutes.Tasks.route -&gt; stringResource(R.string.tasks)&#10;                                    AppRoutes.Calendar.route -&gt; stringResource(R.string.calendar)&#10;                                    AppRoutes.TeacherHome.route -&gt; stringResource(R.string.home)&#10;                                    AppRoutes.StudentHome.route -&gt; stringResource(R.string.home)&#10;                                    AppRoutes.Admin.route -&gt; stringResource(R.string.panel_admin)&#10;                                    AppRoutes.Dashboard.route -&gt; stringResource(R.string.dashboard)&#10;                                    else -&gt; stringResource(R.string.app_name)&#10;                                }&#10;                            )&#10;                        },&#10;                        navigationIcon = {&#10;                            // Ícono de menú que abre el drawer&#10;                            IconButton(onClick = { scope.launch { drawerState.open() } }) {&#10;                                Icon(Icons.Filled.Menu, contentDescription = &quot;Menú&quot;)&#10;                            }&#10;                        },&#10;                        actions = {&#10;                            // Notificaciones con badge&#10;                            IconButton(onClick = { navController.navigate(AppRoutes.Notifications.route) }) {&#10;                                BadgedBox(badge = {&#10;                                    if (notifCount &gt; 0) {&#10;                                        Badge { Text(if (notifCount &gt; 99) &quot;99+&quot; else notifCount.toString()) }&#10;                                    }&#10;                                }) {&#10;                                    Icon(Icons.Filled.Notifications, contentDescription = &quot;Notificaciones&quot;)&#10;                                }&#10;                            }&#10;                            // Overflow con accesos: Perfil, Pagos, Calendario y Dashboard (admin)&#10;                            IconButton(onClick = { overflowOpen = true }) {&#10;                                Icon(Icons.Filled.MoreVert, contentDescription = &quot;Más opciones&quot;)&#10;                            }&#10;                            DropdownMenu(expanded = overflowOpen, onDismissRequest = { overflowOpen = false }) {&#10;                                DropdownMenuItem(text = { Text(stringResource(R.string.profile)) }, onClick = {&#10;                                    overflowOpen = false&#10;                                    navController.navigate(AppRoutes.Profile.route)&#10;                                })&#10;                                if (!isStudent &amp;&amp; !isDocente) {&#10;                                    DropdownMenuItem(text = { Text(stringResource(R.string.payments)) }, onClick = {&#10;                                        overflowOpen = false&#10;                                        navController.navigate(AppRoutes.Payments.route)&#10;                                    })&#10;                                }&#10;                                DropdownMenuItem(text = { Text(stringResource(R.string.calendar)) }, onClick = {&#10;                                    overflowOpen = false&#10;                                    navController.navigate(AppRoutes.Calendar.route)&#10;                                })&#10;                                // El menú overflow ya no muestra &quot;Dashboard&quot; para evitar duplicado&#10;                                // (la opción Dashboard permanece en el drawer lateral para administradores)&#10;                            }&#10;                        },&#10;                        colors = TopAppBarDefaults.centerAlignedTopAppBarColors(&#10;                            containerColor = MaterialTheme.colorScheme.primaryContainer,&#10;                            titleContentColor = MaterialTheme.colorScheme.onPrimaryContainer,&#10;                            navigationIconContentColor = MaterialTheme.colorScheme.onPrimaryContainer,&#10;                            actionIconContentColor = MaterialTheme.colorScheme.onPrimaryContainer&#10;                        )&#10;                    )&#10;                },&#10;                bottomBar = {&#10;                    NavigationBar(containerColor = MaterialTheme.colorScheme.surface) {&#10;                        bottomItems.forEach { item -&gt;&#10;                            val selected = currentDestination?.hierarchy?.any { it.route == item.route } == true&#10;                            val scale by animateFloatAsState(targetValue = if (selected) 1f else 0.95f, label = &quot;nav_icon_scale&quot;)&#10;                            NavigationBarItem(&#10;                                selected = selected,&#10;                                onClick = {&#10;                                    // Navegación directa al destino (simple y confiable para evitar problemas desde Admin)&#10;                                    navController.navigate(item.route) {&#10;                                        launchSingleTop = true&#10;                                        restoreState = true&#10;                                    }&#10;                                },&#10;                                icon = {&#10;                                    val iconModifier = Modifier.graphicsLayer(scaleX = scale, scaleY = scale)&#10;                                    when (item.route) {&#10;                                        AppRoutes.Notifications.route -&gt; {&#10;                                            BadgedBox(badge = {&#10;                                                if (notifCount &gt; 0) {&#10;                                                    Badge { Text(if (notifCount &gt; 99) &quot;99+&quot; else notifCount.toString()) }&#10;                                                }&#10;                                            }) { Icon(item.icon, contentDescription = item.label, modifier = iconModifier) }&#10;                                        }&#10;                                        AppRoutes.Messages.route -&gt; {&#10;                                            BadgedBox(badge = {&#10;                                                if (msgCount &gt; 0) {&#10;                                                    Badge { Text(if (msgCount &gt; 99) &quot;99+&quot; else msgCount.toString()) }&#10;                                                }&#10;                                            }) { Icon(item.icon, contentDescription = item.label, modifier = iconModifier) }&#10;                                        }&#10;                                        else -&gt; Icon(item.icon, contentDescription = item.label, modifier = iconModifier)&#10;                                    }&#10;                                },&#10;                                label = { Text(item.label) }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            ) { innerPadding -&gt;&#10;                Box(Modifier.padding(innerPadding)) {&#10;                    content()&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;private data class BottomItem(val label: String, val route: String, val icon: androidx.compose.ui.graphics.vector.ImageVector)&#10;" />
              <option name="updatedContent" value="@file:OptIn(ExperimentalMaterial3Api::class)&#10;&#10;package com.example.appcolegios.navigation&#10;&#10;import android.app.Activity&#10;import android.content.Intent&#10;import androidx.compose.animation.core.animateFloatAsState&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.Message&#10;import androidx.compose.material.icons.automirrored.filled.Logout&#10;import androidx.compose.material.icons.filled.Home&#10;import androidx.compose.material.icons.filled.Menu&#10;import androidx.compose.material.icons.filled.Notifications&#10;import androidx.compose.material.icons.filled.Person&#10;import androidx.compose.material.icons.filled.MoreVert&#10;import androidx.compose.material.icons.filled.CreditCard&#10;import androidx.compose.material.icons.filled.DirectionsBus&#10;import androidx.compose.material.icons.filled.School&#10;import androidx.compose.material.icons.automirrored.filled.Assignment&#10;import androidx.compose.material.icons.automirrored.filled.EventNote&#10;import androidx.compose.material.icons.filled.CalendarToday&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.compose.ui.unit.dp&#10;import androidx.navigation.NavDestination.Companion.hierarchy&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.compose.currentBackStackEntryAsState&#10;import androidx.navigation.compose.rememberNavController&#10;import com.example.appcolegios.R&#10;import com.example.appcolegios.academico.AttendanceScreen&#10;import com.example.appcolegios.academico.AnnouncementsScreen&#10;import com.example.appcolegios.academico.CalendarScreen&#10;import com.example.appcolegios.academico.ScheduleScreen&#10;import com.example.appcolegios.academico.NotesScreen&#10;import com.example.appcolegios.academico.TasksScreen&#10;import com.example.appcolegios.auth.LoginActivity&#10;import com.example.appcolegios.auth.RegisterScreen&#10;import com.example.appcolegios.auth.ResetPasswordScreen&#10;import com.example.appcolegios.auth.SplashScreen&#10;import com.example.appcolegios.home.HomeScreen&#10;import com.example.appcolegios.dashboard.DashboardScreen&#10;import com.example.appcolegios.mensajes.ChatScreen&#10;import com.example.appcolegios.mensajes.ConversationsScreen&#10;import com.example.appcolegios.mensajes.NewMessageScreen&#10;import com.example.appcolegios.notificaciones.NotificationsScreen&#10;import com.example.appcolegios.pagos.PaymentsScreen&#10;import com.example.appcolegios.perfil.ProfileScreen&#10;import com.example.appcolegios.transporte.TransportScreen&#10;import com.example.appcolegios.admin.AdminScreen&#10;import com.example.appcolegios.admin.AdminUsersScreen&#10;import com.example.appcolegios.ubicacion.UbicacionScreen&#10;import kotlinx.coroutines.launch&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.appcolegios.data.UserPreferencesRepository&#10;import androidx.navigation.NavType&#10;import androidx.navigation.navArgument&#10;import android.widget.Toast&#10;import com.example.appcolegios.auth.VerifyEmailScreen&#10;import com.example.appcolegios.teacher.TeacherHomeScreen&#10;import com.example.appcolegios.student.StudentHomeScreen&#10;&#10;@Composable&#10;fun AppNavigation(&#10;    startDestination: String = AppRoutes.Splash.route,&#10;    initialRole: String? = null,&#10;    unreadNotificationsCount: Int = 0,&#10;    unreadMessagesCount: Int = 0&#10;) {&#10;    val navController = rememberNavController()&#10;    val backStackEntry = navController.currentBackStackEntryAsState().value&#10;    val currentDestination = backStackEntry?.destination&#10;&#10;    // Mostrar chrome en todas las rutas salvo pantallas de auth/splash&#10;    val authlessRoutes = setOf(&#10;        AppRoutes.Splash.route,&#10;        AppRoutes.Login.route,&#10;        AppRoutes.Register.route,&#10;        AppRoutes.VerifyEmail.route,&#10;        AppRoutes.ResetPassword.route&#10;    )&#10;&#10;    val showChrome = currentDestination?.route !in authlessRoutes&#10;&#10;    val drawerState = rememberDrawerState(DrawerValue.Closed)&#10;    val scope = rememberCoroutineScope()&#10;&#10;    val context = LocalContext.current&#10;    val userPrefs = UserPreferencesRepository(context)&#10;    val userData = userPrefs.userData.collectAsState(initial = com.example.appcolegios.data.UserData(null, null, null)).value&#10;    // Preferir el role inyectado (initialRole) para evitar condiciones de carrera; si no está, usar el de prefs&#10;    val roleString = if (!initialRole.isNullOrBlank()) initialRole else (userData.role ?: &quot;&quot; )&#10;    val isAdmin = roleString.equals(&quot;ADMIN&quot;, ignoreCase = true)&#10;    val isDocente = roleString.equals(&quot;DOCENTE&quot;, ignoreCase = true)&#10;    val isStudent = roleString.equals(&quot;ESTUDIANTE&quot;, ignoreCase = true)&#10;&#10;    val bottomItems = if (isAdmin) {&#10;        listOf(&#10;            // Para admin, Inicio debe llevar al Home (pantalla de inicio que muestra todas las opciones admin)&#10;            BottomItem(stringResource(R.string.home), AppRoutes.Home.route, Icons.Filled.Home),&#10;            BottomItem(stringResource(R.string.profile), AppRoutes.Profile.route, Icons.Filled.Person)&#10;        )&#10;    } else {&#10;        listOf(&#10;            BottomItem(stringResource(R.string.home), AppRoutes.Home.route, Icons.Filled.Home),&#10;            BottomItem(stringResource(R.string.messages), AppRoutes.Messages.route, Icons.AutoMirrored.Filled.Message),&#10;            BottomItem(stringResource(R.string.notifications), AppRoutes.Notifications.route, Icons.Filled.Notifications),&#10;            BottomItem(stringResource(R.string.schedule), AppRoutes.Schedule.route, Icons.Filled.CalendarToday),&#10;            BottomItem(stringResource(R.string.profile), AppRoutes.Profile.route, Icons.Filled.Person)&#10;        )&#10;    }&#10;&#10;    // Badges en tiempo real desde Firestore&#10;    val badgesVm: BadgesViewModel = viewModel()&#10;    val badgesState = badgesVm.state.collectAsState().value&#10;&#10;    val notifCount = if (badgesState.unreadNotifications &gt; 0) badgesState.unreadNotifications else unreadNotificationsCount&#10;    val msgCount = if (badgesState.unreadMessages &gt; 0) badgesState.unreadMessages else unreadMessagesCount&#10;&#10;    val content: @Composable () -&gt; Unit = {&#10;        NavHost(navController = navController, startDestination = startDestination) {&#10;            composable(AppRoutes.Splash.route) { SplashScreen(navController) }&#10;            composable(AppRoutes.Login.route) {&#10;                val localContext = LocalContext.current&#10;                LaunchedEffect(Unit) {&#10;                    val intent = Intent(localContext, LoginActivity::class.java)&#10;                    localContext.startActivity(intent)&#10;                    if (localContext is Activity) {&#10;                        localContext.finish()&#10;                    }&#10;                }&#10;                // Puedes mostrar una pantalla vacía o de carga mientras se lanza la actividad&#10;                Box(modifier = Modifier.fillMaxSize()) {}&#10;            }&#10;            composable(AppRoutes.Register.route) {&#10;                RegisterScreen(&#10;                    onRegisterSuccess = {&#10;                        // Mostrar mensaje de éxito y navegar a verificación de correo&#10;                        Toast.makeText(context, &quot;Registro exitoso. Verifica tu correo.&quot;, Toast.LENGTH_SHORT).show()&#10;                        navController.navigate(AppRoutes.VerifyEmail.route) {&#10;                            popUpTo(0) { inclusive = true }&#10;                        }&#10;                    },&#10;                    onNavigateToLogin = { navController.popBackStack() }&#10;                )&#10;            }&#10;            // Nueva ruta para registro desde Admin (solo crea documento en Firestore)&#10;            composable(AppRoutes.RegisterAdmin.route) {&#10;                RegisterScreen(&#10;                    onRegisterSuccess = {&#10;                        Toast.makeText(context, &quot;Usuario creado correctamente&quot;, Toast.LENGTH_SHORT).show()&#10;                        // Al crear desde admin solo volver al home del admin&#10;                        navController.navigate(AppRoutes.Home.route) {&#10;                            popUpTo(0) { inclusive = true }&#10;                        }&#10;                    },&#10;                    onNavigateToLogin = { navController.popBackStack() },&#10;                    createOnly = true&#10;                )&#10;            }&#10;            composable(AppRoutes.ResetPassword.route) {&#10;                ResetPasswordScreen(&#10;                    onPasswordResetSent = { navController.popBackStack() },&#10;                    onNavigateToLogin = { navController.popBackStack() }&#10;                )&#10;            }&#10;            composable(AppRoutes.Home.route) { HomeScreen(navController = navController) }&#10;            composable(AppRoutes.Profile.route) { ProfileScreen() }&#10;            composable(AppRoutes.Payments.route) { PaymentsScreen() }&#10;            composable(AppRoutes.Transport.route) { TransportScreen() }&#10;            composable(AppRoutes.Notes.route) {&#10;                if (isDocente) {&#10;                    com.example.appcolegios.academico.TeacherNotesScreen(navController = navController)&#10;                } else {&#10;                    NotesScreen()&#10;                }&#10;            }&#10;            composable(AppRoutes.Attendance.route) { AttendanceScreen() }&#10;            composable(AppRoutes.Announcements.route) { AnnouncementsScreen(navController) }&#10;            composable(AppRoutes.Tasks.route) { TasksScreen() }&#10;            // Ruta para calificar (Cursos -&gt; Estudiantes -&gt; Notas)&#10;            composable(AppRoutes.Grading.route) { com.example.appcolegios.academico.GradingScreen() }&#10;            composable(AppRoutes.Notifications.route) { NotificationsScreen(navController = navController) }&#10;            composable(AppRoutes.Messages.route) { ConversationsScreen(navController = navController) }&#10;            composable(AppRoutes.Calendar.route) { CalendarScreen() }&#10;            composable(AppRoutes.Schedule.route) { ScheduleScreen() }&#10;            composable(AppRoutes.Admin.route) { AdminScreen(navController) }&#10;            composable(AppRoutes.AdminUsers.route) { AdminUsersScreen(onUserSelected = { uid -&gt;&#10;                // navegar a gestión de horario del usuario seleccionado&#10;                navController.navigate(com.example.appcolegios.navigation.AppRoutes.AdminScheduleManage.route.replace(&quot;{userId}&quot;, uid))&#10;            }) }&#10;            composable(AppRoutes.AdminEventCreate.route) { com.example.appcolegios.admin.AdminEventCreateScreen(navController)&#10;            }&#10;            composable(AppRoutes.TeacherHome.route) { TeacherHomeScreen(navController) }&#10;            composable(AppRoutes.StudentHome.route) { StudentHomeScreen(navController = navController) }&#10;            // Ruta Ubicación del colegio&#10;            composable(AppRoutes.Ubicacion.route) { UbicacionScreen() }&#10;            composable(&#10;                route = AppRoutes.Chat.route,&#10;                arguments = listOf(navArgument(&quot;otherUserId&quot;) { type = NavType.StringType })&#10;            ) { backStackEntry2 -&gt;&#10;                val otherUserId = backStackEntry2.arguments?.getString(&quot;otherUserId&quot;) ?: &quot;&quot;&#10;                ChatScreen(navController = navController, otherUserId = otherUserId)&#10;            }&#10;            composable(AppRoutes.NewMessage.route) {&#10;                NewMessageScreen(&#10;                    onUserSelected = { userId -&gt;&#10;                        navController.navigate(&quot;chat/$userId&quot;)&#10;                    },&#10;                    onBack = { navController.popBackStack() }&#10;                )&#10;            }&#10;            composable(AppRoutes.VerifyEmail.route) {&#10;                VerifyEmailScreen(onDone = { navController.navigate(AppRoutes.Splash.route) {&#10;                    popUpTo(0) { inclusive = true }&#10;                } }, onVerified = { dest -&gt;&#10;                    navController.navigate(dest) {&#10;                        popUpTo(0) { inclusive = true }&#10;                    }&#10;                })&#10;            }&#10;            composable(AppRoutes.Dashboard.route) { DashboardScreen() }&#10;            composable(&#10;                route = com.example.appcolegios.navigation.AppRoutes.AdminScheduleManage.route,&#10;                arguments = listOf(navArgument(&quot;userId&quot;) { type = NavType.StringType; defaultValue = &quot;&quot; })&#10;            ) { backStackEntry -&gt;&#10;                val uid = backStackEntry.arguments?.getString(&quot;userId&quot;)&#10;                com.example.appcolegios.admin.AdminScheduleManageScreen(userIdArg = uid, onDone = { navController.popBackStack() })&#10;            }&#10;            composable(&#10;                route = AppRoutes.CalendarEvent.route,&#10;                arguments = listOf(navArgument(&quot;eventId&quot;) { type = NavType.StringType })&#10;            ) { backStackEntry -&gt;&#10;                val eid = backStackEntry.arguments?.getString(&quot;eventId&quot;) ?: &quot;&quot;&#10;                CalendarScreen(eventId = eid)&#10;            }&#10;        }&#10;    }&#10;&#10;    if (!showChrome) {&#10;        // Rutas de auth/splash sin chrome&#10;        content()&#10;    } else {&#10;        // Drawer lateral funcional con opciones&#10;        ModalNavigationDrawer(&#10;            drawerState = drawerState,&#10;            drawerContent = {&#10;                ModalDrawerSheet {&#10;                    Spacer(Modifier.height(12.dp))&#10;                    Text(&#10;                        &quot;Menú&quot;,&#10;                        modifier = Modifier.padding(16.dp),&#10;                        style = MaterialTheme.typography.titleLarge&#10;                    )&#10;                    HorizontalDivider()&#10;&#10;                    // Opción Home / Admin&#10;                    if (isAdmin) {&#10;                        // Drawer item para administradores: ir a Admin&#10;                        NavigationDrawerItem(&#10;                            icon = { Icon(Icons.Filled.Home, contentDescription = null) },&#10;                            label = { Text(stringResource(R.string.panel_admin)) },&#10;                            selected = currentDestination?.route == AppRoutes.Admin.route,&#10;                            onClick = {&#10;                                scope.launch { drawerState.close() }&#10;                                navController.navigate(AppRoutes.Admin.route) {&#10;                                    launchSingleTop = true&#10;                                    restoreState = true&#10;                                }&#10;                            },&#10;                            modifier = Modifier.padding(horizontal = 12.dp)&#10;                        )&#10;                    } else {&#10;                        // Opción Home para usuarios no-admin (restaurada: menú completo)&#10;                        NavigationDrawerItem(&#10;                            icon = { Icon(Icons.Filled.Home, contentDescription = null) },&#10;                            label = { Text(stringResource(R.string.home)) },&#10;                            selected = currentDestination?.route == AppRoutes.Home.route,&#10;                            onClick = {&#10;                                scope.launch { drawerState.close() }&#10;                                navController.navigate(AppRoutes.Home.route) {&#10;                                    launchSingleTop = true&#10;                                    restoreState = true&#10;                                }&#10;                            },&#10;                            modifier = Modifier.padding(horizontal = 12.dp)&#10;                        )&#10;&#10;                        // Mensajes&#10;                        NavigationDrawerItem(&#10;                            icon = { Icon(Icons.AutoMirrored.Filled.Message, contentDescription = null) },&#10;                            label = { Text(stringResource(R.string.messages)) },&#10;                            selected = currentDestination?.route == AppRoutes.Messages.route,&#10;                            onClick = {&#10;                                scope.launch { drawerState.close() }&#10;                                navController.navigate(AppRoutes.Messages.route) {&#10;                                    launchSingleTop = true&#10;                                    restoreState = true&#10;                                }&#10;                            },&#10;                            modifier = Modifier.padding(horizontal = 12.dp)&#10;                        )&#10;&#10;                        // Notificaciones&#10;                        NavigationDrawerItem(&#10;                            icon = { Icon(Icons.Filled.Notifications, contentDescription = null) },&#10;                            label = { Text(stringResource(R.string.notifications)) },&#10;                            selected = currentDestination?.route == AppRoutes.Notifications.route,&#10;                            onClick = {&#10;                                scope.launch { drawerState.close() }&#10;                                navController.navigate(AppRoutes.Notifications.route) {&#10;                                    launchSingleTop = true&#10;                                    restoreState = true&#10;                                }&#10;                            },&#10;                            modifier = Modifier.padding(horizontal = 12.dp)&#10;                        )&#10;&#10;                        // Pagos&#10;                        if (!isStudent &amp;&amp; !isDocente) {&#10;                            NavigationDrawerItem(&#10;                                icon = { Icon(Icons.Filled.CreditCard, contentDescription = null) },&#10;                                label = { Text(stringResource(R.string.payments)) },&#10;                                selected = currentDestination?.route == AppRoutes.Payments.route,&#10;                                onClick = {&#10;                                    scope.launch { drawerState.close() }&#10;                                    navController.navigate(AppRoutes.Payments.route) {&#10;                                        launchSingleTop = true&#10;                                        restoreState = true&#10;                                    }&#10;                                },&#10;                                modifier = Modifier.padding(horizontal = 12.dp)&#10;                            )&#10;                        }&#10;&#10;                        // Transporte&#10;                        NavigationDrawerItem(&#10;                            icon = { Icon(Icons.Filled.DirectionsBus, contentDescription = null) },&#10;                            label = { Text(stringResource(R.string.transporte)) },&#10;                            selected = currentDestination?.route == AppRoutes.Transport.route,&#10;                            onClick = {&#10;                                scope.launch { drawerState.close() }&#10;                                navController.navigate(AppRoutes.Transport.route) {&#10;                                    launchSingleTop = true&#10;                                    restoreState = true&#10;                                }&#10;                            },&#10;                            modifier = Modifier.padding(horizontal = 12.dp)&#10;                        )&#10;&#10;                        // Notas&#10;                        NavigationDrawerItem(&#10;                            icon = { Icon(Icons.Filled.School, contentDescription = null) },&#10;                            label = { Text(stringResource(R.string.notes)) },&#10;                            selected = currentDestination?.route == AppRoutes.Notes.route,&#10;                            onClick = {&#10;                                scope.launch { drawerState.close() }&#10;                                navController.navigate(AppRoutes.Notes.route) {&#10;                                    launchSingleTop = true&#10;                                    restoreState = true&#10;                                }&#10;                            },&#10;                            modifier = Modifier.padding(horizontal = 12.dp)&#10;                        )&#10;&#10;                        // Asistencia&#10;                        NavigationDrawerItem(&#10;                            icon = { Icon(Icons.AutoMirrored.Filled.Assignment, contentDescription = null) },&#10;                            label = { Text(stringResource(R.string.attendance)) },&#10;                            selected = currentDestination?.route == AppRoutes.Attendance.route,&#10;                            onClick = {&#10;                                scope.launch { drawerState.close() }&#10;                                navController.navigate(AppRoutes.Attendance.route) {&#10;                                    launchSingleTop = true&#10;                                    restoreState = true&#10;                                }&#10;                            },&#10;                            modifier = Modifier.padding(horizontal = 12.dp)&#10;                        )&#10;&#10;                        // Tareas&#10;                        NavigationDrawerItem(&#10;                            icon = { Icon(Icons.AutoMirrored.Filled.EventNote, contentDescription = null) },&#10;                            label = { Text(stringResource(R.string.tasks)) },&#10;                            selected = currentDestination?.route == AppRoutes.Tasks.route,&#10;                            onClick = {&#10;                                scope.launch { drawerState.close() }&#10;                                navController.navigate(AppRoutes.Tasks.route) {&#10;                                    launchSingleTop = true&#10;                                    restoreState = true&#10;                                }&#10;                            },&#10;                            modifier = Modifier.padding(horizontal = 12.dp)&#10;                        )&#10;&#10;                        // Calendario&#10;                        NavigationDrawerItem(&#10;                            icon = { Icon(Icons.Filled.CalendarToday, contentDescription = null) },&#10;                            label = { Text(stringResource(R.string.calendar)) },&#10;                            selected = currentDestination?.route == AppRoutes.Calendar.route,&#10;                            onClick = {&#10;                                scope.launch { drawerState.close() }&#10;                                navController.navigate(AppRoutes.Calendar.route) {&#10;                                    launchSingleTop = true&#10;                                    restoreState = true&#10;                                }&#10;                            },&#10;                            modifier = Modifier.padding(horizontal = 12.dp)&#10;                        )&#10;                    }&#10;&#10;                    // Opciones comunes: Perfil y Cerrar sesión&#10;                    NavigationDrawerItem(&#10;                        icon = { Icon(Icons.Filled.Person, contentDescription = null) },&#10;                        label = { Text(stringResource(R.string.profile)) },&#10;                        selected = currentDestination?.route == AppRoutes.Profile.route,&#10;                        onClick = {&#10;                            scope.launch { drawerState.close() }&#10;                            navController.navigate(AppRoutes.Profile.route) {&#10;                                launchSingleTop = true&#10;                                restoreState = true&#10;                            }&#10;                        },&#10;                        modifier = Modifier.padding(horizontal = 12.dp)&#10;                    )&#10;&#10;                    // Logout&#10;                    NavigationDrawerItem(&#10;                        icon = { Icon(Icons.AutoMirrored.Filled.Logout, contentDescription = null) },&#10;                        label = { Text(stringResource(R.string.logout)) },&#10;                        selected = false,&#10;                        onClick = {&#10;                            scope.launch { drawerState.close() }&#10;                            // limpiar datos locales y lanzar actividad de login para cerrar sesión&#10;                            scope.launch {&#10;                                try {&#10;                                    userPrefs.clearAllUserData()&#10;                                } catch (_: Exception) {}&#10;                                val activity = context as? Activity&#10;                                val intent = Intent(context, LoginActivity::class.java)&#10;                                context.startActivity(intent)&#10;                                activity?.finish()&#10;                            }&#10;                        },&#10;                        modifier = Modifier.padding(horizontal = 12.dp)&#10;                    )&#10;                }&#10;            }&#10;        ) {&#10;            Scaffold(&#10;                topBar = {&#10;                    var overflowOpen by androidx.compose.runtime.remember { androidx.compose.runtime.mutableStateOf(false) }&#10;                    CenterAlignedTopAppBar(&#10;                        title = {&#10;                            Text(&#10;                                when (currentDestination?.route) {&#10;                                    AppRoutes.Home.route -&gt; stringResource(R.string.home)&#10;                                    AppRoutes.Messages.route -&gt; stringResource(R.string.messages)&#10;                                    AppRoutes.Notifications.route -&gt; stringResource(R.string.notifications)&#10;                                    AppRoutes.Profile.route -&gt; stringResource(R.string.profile)&#10;                                    AppRoutes.Payments.route -&gt; stringResource(R.string.payments)&#10;                                    AppRoutes.Transport.route -&gt; stringResource(R.string.transporte)&#10;                                    AppRoutes.Notes.route -&gt; stringResource(R.string.notes)&#10;                                    AppRoutes.Attendance.route -&gt; stringResource(R.string.attendance)&#10;                                    AppRoutes.Tasks.route -&gt; stringResource(R.string.tasks)&#10;                                    AppRoutes.Calendar.route -&gt; stringResource(R.string.calendar)&#10;                                    AppRoutes.TeacherHome.route -&gt; stringResource(R.string.home)&#10;                                    AppRoutes.StudentHome.route -&gt; stringResource(R.string.home)&#10;                                    AppRoutes.Admin.route -&gt; stringResource(R.string.panel_admin)&#10;                                    AppRoutes.Dashboard.route -&gt; stringResource(R.string.dashboard)&#10;                                    else -&gt; stringResource(R.string.app_name)&#10;                                }&#10;                            )&#10;                        },&#10;                        navigationIcon = {&#10;                            // Ícono de menú que abre el drawer&#10;                            IconButton(onClick = { scope.launch { drawerState.open() } }) {&#10;                                Icon(Icons.Filled.Menu, contentDescription = &quot;Menú&quot;)&#10;                            }&#10;                        },&#10;                        actions = {&#10;                            // Notificaciones con badge&#10;                            IconButton(onClick = { navController.navigate(AppRoutes.Notifications.route) }) {&#10;                                BadgedBox(badge = {&#10;                                    if (notifCount &gt; 0) {&#10;                                        Badge { Text(if (notifCount &gt; 99) &quot;99+&quot; else notifCount.toString()) }&#10;                                    }&#10;                                }) {&#10;                                    Icon(Icons.Filled.Notifications, contentDescription = &quot;Notificaciones&quot;)&#10;                                }&#10;                            }&#10;                            // Overflow con accesos: Perfil, Pagos, Calendario y Dashboard (admin)&#10;                            IconButton(onClick = { overflowOpen = true }) {&#10;                                Icon(Icons.Filled.MoreVert, contentDescription = &quot;Más opciones&quot;)&#10;                            }&#10;                            DropdownMenu(expanded = overflowOpen, onDismissRequest = { overflowOpen = false }) {&#10;                                DropdownMenuItem(text = { Text(stringResource(R.string.profile)) }, onClick = {&#10;                                    overflowOpen = false&#10;                                    navController.navigate(AppRoutes.Profile.route)&#10;                                })&#10;                                if (!isStudent &amp;&amp; !isDocente) {&#10;                                    DropdownMenuItem(text = { Text(stringResource(R.string.payments)) }, onClick = {&#10;                                        overflowOpen = false&#10;                                        navController.navigate(AppRoutes.Payments.route)&#10;                                    })&#10;                                }&#10;                                DropdownMenuItem(text = { Text(stringResource(R.string.calendar)) }, onClick = {&#10;                                    overflowOpen = false&#10;                                    navController.navigate(AppRoutes.Calendar.route)&#10;                                })&#10;                                // El menú overflow ya no muestra &quot;Dashboard&quot; para evitar duplicado&#10;                                // (la opción Dashboard permanece en el drawer lateral para administradores)&#10;                            }&#10;                        },&#10;                        colors = TopAppBarDefaults.centerAlignedTopAppBarColors(&#10;                            containerColor = MaterialTheme.colorScheme.primaryContainer,&#10;                            titleContentColor = MaterialTheme.colorScheme.onPrimaryContainer,&#10;                            navigationIconContentColor = MaterialTheme.colorScheme.onPrimaryContainer,&#10;                            actionIconContentColor = MaterialTheme.colorScheme.onPrimaryContainer&#10;                        )&#10;                    )&#10;                },&#10;                bottomBar = {&#10;                    NavigationBar(containerColor = MaterialTheme.colorScheme.surface) {&#10;                        bottomItems.forEach { item -&gt;&#10;                            val selected = currentDestination?.hierarchy?.any { it.route == item.route } == true&#10;                            val scale by animateFloatAsState(targetValue = if (selected) 1f else 0.95f, label = &quot;nav_icon_scale&quot;)&#10;                            NavigationBarItem(&#10;                                selected = selected,&#10;                                onClick = {&#10;                                    // Navegación directa al destino (simple y confiable para evitar problemas desde Admin)&#10;                                    navController.navigate(item.route) {&#10;                                        launchSingleTop = true&#10;                                        restoreState = true&#10;                                    }&#10;                                },&#10;                                icon = {&#10;                                    val iconModifier = Modifier.graphicsLayer(scaleX = scale, scaleY = scale)&#10;                                    when (item.route) {&#10;                                        AppRoutes.Notifications.route -&gt; {&#10;                                            BadgedBox(badge = {&#10;                                                if (notifCount &gt; 0) {&#10;                                                    Badge { Text(if (notifCount &gt; 99) &quot;99+&quot; else notifCount.toString()) }&#10;                                                }&#10;                                            }) { Icon(item.icon, contentDescription = item.label, modifier = iconModifier) }&#10;                                        }&#10;                                        AppRoutes.Messages.route -&gt; {&#10;                                            BadgedBox(badge = {&#10;                                                if (msgCount &gt; 0) {&#10;                                                    Badge { Text(if (msgCount &gt; 99) &quot;99+&quot; else msgCount.toString()) }&#10;                                                }&#10;                                            }) { Icon(item.icon, contentDescription = item.label, modifier = iconModifier) }&#10;                                        }&#10;                                        else -&gt; Icon(item.icon, contentDescription = item.label, modifier = iconModifier)&#10;                                    }&#10;                                },&#10;                                label = { Text(item.label) }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            ) { innerPadding -&gt;&#10;                Box(Modifier.padding(innerPadding)) {&#10;                    content()&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;private data class BottomItem(val label: String, val route: String, val icon: androidx.compose.ui.graphics.vector.ImageVector)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/appcolegios/navigation/AppRoutes.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/appcolegios/navigation/AppRoutes.kt" />
              <option name="originalContent" value="package com.example.appcolegios.navigation&#10;&#10;sealed class AppRoutes(val route: String) {&#10;    object Splash : AppRoutes(&quot;splash&quot;)&#10;    object Login : AppRoutes(&quot;login&quot;)&#10;    object Register : AppRoutes(&quot;register&quot;)&#10;    object RegisterAdmin : AppRoutes(&quot;register_admin&quot;)&#10;    object ResetPassword : AppRoutes(&quot;reset_password&quot;)&#10;    object Home : AppRoutes(&quot;home&quot;)&#10;    object Profile : AppRoutes(&quot;profile&quot;)&#10;    object Payments : AppRoutes(&quot;payments&quot;)&#10;    object Transport : AppRoutes(&quot;transport&quot;)&#10;    object Notes : AppRoutes(&quot;notes&quot;)&#10;    object Attendance : AppRoutes(&quot;attendance&quot;)&#10;    object Announcements : AppRoutes(&quot;announcements&quot;)&#10;    object Tasks : AppRoutes(&quot;tasks&quot;)&#10;    object Notifications : AppRoutes(&quot;notifications&quot;)&#10;    object Messages : AppRoutes(&quot;messages&quot;)&#10;    object Calendar : AppRoutes(&quot;calendar&quot;)&#10;    object Schedule : AppRoutes(&quot;schedule&quot;)&#10;    object Admin : AppRoutes(&quot;admin&quot;)&#10;    object Dashboard : AppRoutes(&quot;dashboard&quot;)&#10;    object TeacherHome : AppRoutes(&quot;teacher_home&quot;)&#10;    object Grading : AppRoutes(&quot;grading&quot;)&#10;    object StudentHome : AppRoutes(&quot;student_home&quot;)&#10;    object VerifyEmail : AppRoutes(&quot;verify_email&quot;)&#10;    object Chat : AppRoutes(&quot;chat/{otherUserId}&quot;)&#10;    object NewMessage : AppRoutes(&quot;new_message&quot;)&#10;    object Ubicacion : AppRoutes(&quot;ubicacion&quot;)&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.example.appcolegios.navigation&#10;&#10;sealed class AppRoutes(val route: String) {&#10;    object Splash : AppRoutes(&quot;splash&quot;)&#10;    object Login : AppRoutes(&quot;login&quot;)&#10;    object Register : AppRoutes(&quot;register&quot;)&#10;    object RegisterAdmin : AppRoutes(&quot;register_admin&quot;)&#10;    object ResetPassword : AppRoutes(&quot;reset_password&quot;)&#10;    object Home : AppRoutes(&quot;home&quot;)&#10;    object Profile : AppRoutes(&quot;profile&quot;)&#10;    object Payments : AppRoutes(&quot;payments&quot;)&#10;    object Transport : AppRoutes(&quot;transport&quot;)&#10;    object Notes : AppRoutes(&quot;notes&quot;)&#10;    object Attendance : AppRoutes(&quot;attendance&quot;)&#10;    object Announcements : AppRoutes(&quot;announcements&quot;)&#10;    object Tasks : AppRoutes(&quot;tasks&quot;)&#10;    object Notifications : AppRoutes(&quot;notifications&quot;)&#10;    object Messages : AppRoutes(&quot;messages&quot;)&#10;    object Calendar : AppRoutes(&quot;calendar&quot;)&#10;    object Schedule : AppRoutes(&quot;schedule&quot;)&#10;    object Admin : AppRoutes(&quot;admin&quot;)&#10;    object Dashboard : AppRoutes(&quot;dashboard&quot;)&#10;    object TeacherHome : AppRoutes(&quot;teacher_home&quot;)&#10;    object Grading : AppRoutes(&quot;grading&quot;)&#10;    object StudentHome : AppRoutes(&quot;student_home&quot;)&#10;    object VerifyEmail : AppRoutes(&quot;verify_email&quot;)&#10;    object Chat : AppRoutes(&quot;chat/{otherUserId}&quot;)&#10;    object NewMessage : AppRoutes(&quot;new_message&quot;)&#10;    object Ubicacion : AppRoutes(&quot;ubicacion&quot;)&#10;&#10;    // Admin helpers&#10;    object AdminUsers : AppRoutes(&quot;admin_users&quot;)&#10;    object AdminScheduleManage : AppRoutes(&quot;admin_schedule/{userId}&quot;)&#10;    object AdminEventCreate : AppRoutes(&quot;admin_event_create&quot;)&#10;&#10;    // Calendar deep link to open specific event&#10;    object CalendarEvent : AppRoutes(&quot;calendar/{eventId}&quot;)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/appcolegios/notificaciones/NotificationsScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/appcolegios/notificaciones/NotificationsScreen.kt" />
              <option name="originalContent" value="package com.example.appcolegios.notificaciones&#10;&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.appcolegios.R&#10;import com.example.appcolegios.data.model.Notification&#10;import com.example.appcolegios.util.DateFormats&#10;import kotlinx.coroutines.launch&#10;import com.example.appcolegios.demo.DemoData&#10;&#10;@Composable&#10;fun NotificationsScreen(notificationsViewModel: NotificationsViewModel = viewModel()) {&#10;    val uiState by notificationsViewModel.uiState.collectAsState()&#10;    val scope = rememberCoroutineScope()&#10;&#10;    var cutoffDays by remember { mutableStateOf&lt;Int?&gt;(7) }&#10;    var expanded by remember { mutableStateOf(false) }&#10;&#10;    LaunchedEffect(cutoffDays) { notificationsViewModel.refresh(cutoffDays) }&#10;&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;    ) {&#10;        Column(modifier = Modifier.fillMaxSize()) {&#10;            Row(modifier = Modifier.fillMaxWidth().padding(12.dp), horizontalArrangement = Arrangement.End) {&#10;                Text(&quot;Mostrar últimos:&quot;)&#10;                Spacer(Modifier.width(8.dp))&#10;                Box {&#10;                    Button(onClick = { expanded = true }) { Text(cutoffDays?.toString() ?: &quot;Todos&quot;) }&#10;                    DropdownMenu(expanded = expanded, onDismissRequest = { expanded = false }) {&#10;                        DropdownMenuItem(text = { Text(&quot;7 días&quot;) }, onClick = { cutoffDays = 7; expanded = false })&#10;                        DropdownMenuItem(text = { Text(&quot;30 días&quot;) }, onClick = { cutoffDays = 30; expanded = false })&#10;                        DropdownMenuItem(text = { Text(&quot;90 días&quot;) }, onClick = { cutoffDays = 90; expanded = false })&#10;                        DropdownMenuItem(text = { Text(&quot;Todos&quot;) }, onClick = { cutoffDays = null; expanded = false })&#10;                    }&#10;                }&#10;            }&#10;&#10;            if (uiState.isLoading) {&#10;                CircularProgressIndicator(&#10;                    modifier = Modifier.align(Alignment.CenterHorizontally),&#10;                    color = MaterialTheme.colorScheme.primary&#10;                )&#10;            } else {&#10;                when {&#10;                    uiState.error != null -&gt; {&#10;                        Box(&#10;                            modifier = Modifier.fillMaxSize(),&#10;                            contentAlignment = Alignment.Center&#10;                        ) { Text(stringResource(R.string.error_label) + &quot;: &quot; + (uiState.error ?: &quot;&quot;), color = MaterialTheme.colorScheme.error) }&#10;                    }&#10;                    else -&gt; {&#10;                        val isDemo = DemoData.isDemoUser()&#10;                        val dataToShow = if (uiState.notifications.isEmpty() &amp;&amp; isDemo) DemoData.demoNotifications() else uiState.notifications&#10;                        if (dataToShow.isEmpty()) {&#10;                            Box(&#10;                                modifier = Modifier.fillMaxSize(),&#10;                                contentAlignment = Alignment.Center&#10;                            ) { Text(stringResource(R.string.no_new_notifications), color = MaterialTheme.colorScheme.onBackground) }&#10;                        } else {&#10;                            NotificationList(&#10;                                groupedNotifications = dataToShow,&#10;                                onNotificationClick = { notification -&gt;&#10;                                    scope.launch { notificationsViewModel.markAsRead(notification.id) }&#10;                                }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun NotificationList(&#10;    groupedNotifications: Map&lt;String, List&lt;Notification&gt;&gt;,&#10;    onNotificationClick: (Notification) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    LazyColumn(&#10;        modifier = modifier&#10;            .fillMaxSize(),&#10;        contentPadding = PaddingValues(vertical = 8.dp)&#10;    ) {&#10;        groupedNotifications.forEach { (dateHeader, notifications) -&gt;&#10;            item(key = &quot;header_$dateHeader&quot;) {&#10;                val headerText = when (dateHeader) {&#10;                    &quot;Hoy&quot; -&gt; stringResource(R.string.today)&#10;                    &quot;Ayer&quot; -&gt; stringResource(R.string.yesterday)&#10;                    else -&gt; dateHeader&#10;                }&#10;                Text(&#10;                    text = headerText,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = MaterialTheme.colorScheme.onBackground,&#10;                    modifier = Modifier.padding(horizontal = 16.dp, vertical = 8.dp)&#10;                )&#10;            }&#10;            items(&#10;                items = notifications,&#10;                key = { it.id }&#10;            ) { notification -&gt;&#10;                NotificationItem(notification = notification, onClick = { onNotificationClick(notification) })&#10;                HorizontalDivider(&#10;                    color = MaterialTheme.colorScheme.secondary.copy(alpha = 0.3f),&#10;                    thickness = 1.dp,&#10;                    modifier = Modifier.padding(horizontal = 16.dp)&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun NotificationItem(notification: Notification, onClick: () -&gt; Unit) {&#10;    val time = remember(notification.id, notification.fechaHora) { DateFormats.formatTime(notification.fechaHora) }&#10;&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .clickable { onClick() }&#10;            .padding(horizontal = 16.dp, vertical = 4.dp),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),&#10;        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface)&#10;    ) {&#10;        Column(modifier = Modifier.padding(16.dp)) {&#10;            Text(&#10;                text = notification.titulo,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                fontWeight = if (notification.leida) FontWeight.Normal else FontWeight.Bold,&#10;                color = MaterialTheme.colorScheme.onSurface&#10;            )&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;            Text(&#10;                text = notification.cuerpo,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                val senderLabel = notification.senderName ?: notification.remitente&#10;                Text(&#10;                    text = senderLabel,&#10;                    style = MaterialTheme.typography.bodySmall,&#10;                    color = MaterialTheme.colorScheme.onSurface&#10;                )&#10;                Text(&#10;                    text = time,&#10;                    style = MaterialTheme.typography.bodySmall,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.appcolegios.notificaciones&#10;&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.appcolegios.R&#10;import com.example.appcolegios.data.model.Notification&#10;import com.example.appcolegios.util.DateFormats&#10;import kotlinx.coroutines.launch&#10;import com.example.appcolegios.demo.DemoData&#10;import androidx.navigation.NavController&#10;&#10;@Composable&#10;fun NotificationsScreen(notificationsViewModel: NotificationsViewModel = viewModel(), navController: NavController? = null) {&#10;    val uiState by notificationsViewModel.uiState.collectAsState()&#10;    val scope = rememberCoroutineScope()&#10;&#10;    var cutoffDays by remember { mutableStateOf&lt;Int?&gt;(7) }&#10;    var expanded by remember { mutableStateOf(false) }&#10;&#10;    LaunchedEffect(cutoffDays) { notificationsViewModel.refresh(cutoffDays) }&#10;&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;    ) {&#10;        Column(modifier = Modifier.fillMaxSize()) {&#10;            Row(modifier = Modifier.fillMaxWidth().padding(12.dp), horizontalArrangement = Arrangement.End) {&#10;                Text(&quot;Mostrar últimos:&quot;)&#10;                Spacer(Modifier.width(8.dp))&#10;                Box {&#10;                    Button(onClick = { expanded = true }) { Text(cutoffDays?.toString() ?: &quot;Todos&quot;) }&#10;                    DropdownMenu(expanded = expanded, onDismissRequest = { expanded = false }) {&#10;                        DropdownMenuItem(text = { Text(&quot;7 días&quot;) }, onClick = { cutoffDays = 7; expanded = false })&#10;                        DropdownMenuItem(text = { Text(&quot;30 días&quot;) }, onClick = { cutoffDays = 30; expanded = false })&#10;                        DropdownMenuItem(text = { Text(&quot;90 días&quot;) }, onClick = { cutoffDays = 90; expanded = false })&#10;                        DropdownMenuItem(text = { Text(&quot;Todos&quot;) }, onClick = { cutoffDays = null; expanded = false })&#10;                    }&#10;                }&#10;            }&#10;&#10;            if (uiState.isLoading) {&#10;                CircularProgressIndicator(&#10;                    modifier = Modifier.align(Alignment.CenterHorizontally),&#10;                    color = MaterialTheme.colorScheme.primary&#10;                )&#10;            } else {&#10;                when {&#10;                    uiState.error != null -&gt; {&#10;                        Box(&#10;                            modifier = Modifier.fillMaxSize(),&#10;                            contentAlignment = Alignment.Center&#10;                        ) { Text(stringResource(R.string.error_label) + &quot;: &quot; + (uiState.error ?: &quot;&quot;), color = MaterialTheme.colorScheme.error) }&#10;                    }&#10;                    else -&gt; {&#10;                        val isDemo = DemoData.isDemoUser()&#10;                        val dataToShow = if (uiState.notifications.isEmpty() &amp;&amp; isDemo) DemoData.demoNotifications() else uiState.notifications&#10;                        if (dataToShow.isEmpty()) {&#10;                            Box(&#10;                                modifier = Modifier.fillMaxSize(),&#10;                                contentAlignment = Alignment.Center&#10;                            ) { Text(stringResource(R.string.no_new_notifications), color = MaterialTheme.colorScheme.onBackground) }&#10;                        } else {&#10;                            NotificationList(&#10;                                groupedNotifications = dataToShow,&#10;                                onNotificationClick = { notification -&gt;&#10;                                    scope.launch { notificationsViewModel.markAsRead(notification.id) }&#10;                                    // Si es evento, abrir calendario y (opcional) buscar evento&#10;                                    if (notification.tipo == &quot;evento&quot;) {&#10;                                        // si la notificación tiene relatedId (eventId) navegamos a la ruta específica&#10;                                        val evId = notification.relatedId&#10;                                        if (!evId.isNullOrBlank()) {&#10;                                            navController?.navigate(com.example.appcolegios.navigation.AppRoutes.CalendarEvent.route.replace(&quot;{eventId}&quot;, evId))&#10;                                        } else {&#10;                                            navController?.navigate(com.example.appcolegios.navigation.AppRoutes.Calendar.route)&#10;                                        }&#10;                                    }&#10;                                }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun NotificationList(&#10;    groupedNotifications: Map&lt;String, List&lt;Notification&gt;&gt;,&#10;    onNotificationClick: (Notification) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    LazyColumn(&#10;        modifier = modifier&#10;            .fillMaxSize(),&#10;        contentPadding = PaddingValues(vertical = 8.dp)&#10;    ) {&#10;        groupedNotifications.forEach { (dateHeader, notifications) -&gt;&#10;            item(key = &quot;header_$dateHeader&quot;) {&#10;                val headerText = when (dateHeader) {&#10;                    &quot;Hoy&quot; -&gt; stringResource(R.string.today)&#10;                    &quot;Ayer&quot; -&gt; stringResource(R.string.yesterday)&#10;                    else -&gt; dateHeader&#10;                }&#10;                Text(&#10;                    text = headerText,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = MaterialTheme.colorScheme.onBackground,&#10;                    modifier = Modifier.padding(horizontal = 16.dp, vertical = 8.dp)&#10;                )&#10;            }&#10;            items(&#10;                items = notifications,&#10;                key = { it.id }&#10;            ) { notification -&gt;&#10;                NotificationItem(notification = notification, onClick = { onNotificationClick(notification) })&#10;                HorizontalDivider(&#10;                    color = MaterialTheme.colorScheme.secondary.copy(alpha = 0.3f),&#10;                    thickness = 1.dp,&#10;                    modifier = Modifier.padding(horizontal = 16.dp)&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun NotificationItem(notification: Notification, onClick: () -&gt; Unit) {&#10;    val time = remember(notification.id, notification.fechaHora) { DateFormats.formatTime(notification.fechaHora) }&#10;&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .clickable { onClick() }&#10;            .padding(horizontal = 16.dp, vertical = 4.dp),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),&#10;        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface)&#10;    ) {&#10;        Column(modifier = Modifier.padding(16.dp)) {&#10;            Text(&#10;                text = notification.titulo,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                fontWeight = if (notification.leida) FontWeight.Normal else FontWeight.Bold,&#10;                color = MaterialTheme.colorScheme.onSurface&#10;            )&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;            Text(&#10;                text = notification.cuerpo,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                val senderLabel = notification.senderName ?: notification.remitente&#10;                Text(&#10;                    text = senderLabel,&#10;                    style = MaterialTheme.typography.bodySmall,&#10;                    color = MaterialTheme.colorScheme.onSurface&#10;                )&#10;                Text(&#10;                    text = time,&#10;                    style = MaterialTheme.typography.bodySmall,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                )&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/appcolegios/ui/AnimatedMaterialButton.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/appcolegios/ui/AnimatedMaterialButton.kt" />
              <option name="updatedContent" value="package com.example.appcolegios.ui&#10;&#10;import android.content.Context&#10;import android.util.AttributeSet&#10;import android.view.MotionEvent&#10;import com.google.android.material.button.MaterialButton&#10;&#10;class AnimatedMaterialButton @JvmOverloads constructor(&#10;    context: Context,&#10;    attrs: AttributeSet? = null,&#10;    defStyleAttr: Int = com.google.android.material.R.attr.materialButtonStyle&#10;) : MaterialButton(context, attrs, defStyleAttr) {&#10;&#10;    override fun onTouchEvent(event: MotionEvent): Boolean {&#10;        when (event.action) {&#10;            MotionEvent.ACTION_DOWN -&gt; {&#10;                this.animate().scaleX(0.97f).scaleY(0.97f).setDuration(50).start()&#10;            }&#10;            MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -&gt; {&#10;                this.animate().scaleX(1f).scaleY(1f).setDuration(50).start()&#10;            }&#10;        }&#10;        return super.onTouchEvent(event)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/anim/fade_in.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/anim/fade_in.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:duration=&quot;300&quot;&#10;    android:fromAlpha=&quot;0.0&quot;&#10;    android:toAlpha=&quot;1.0&quot; /&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/activity_attendance.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/activity_attendance.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    android:orientation=&quot;vertical&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    android:background=&quot;@color/background&quot;&gt;&#10;&#10;    &lt;!-- Toolbar/Header --&gt;&#10;    &lt;com.google.android.material.appbar.AppBarLayout&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:background=&quot;@color/primary&quot;&gt;&#10;&#10;        &lt;androidx.appcompat.widget.Toolbar&#10;            android:id=&quot;@+id/toolbar&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;?attr/actionBarSize&quot;&#10;            android:background=&quot;@color/primary&quot;&#10;            app:title=&quot;@string/attendance&quot;&#10;            app:titleTextColor=&quot;@color/on_primary&quot; /&gt;&#10;&#10;    &lt;/com.google.android.material.appbar.AppBarLayout&gt;&#10;&#10;    &lt;!-- Card con resumen de asistencia --&gt;&#10;    &lt;com.google.android.material.card.MaterialCardView&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_margin=&quot;16dp&quot;&#10;        app:cardBackgroundColor=&quot;@color/surface&quot;&#10;        app:cardElevation=&quot;4dp&quot;&#10;        app:cardCornerRadius=&quot;16dp&quot;&gt;&#10;&#10;        &lt;LinearLayout&#10;            android:orientation=&quot;vertical&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:padding=&quot;16dp&quot;&gt;&#10;&#10;            &lt;TextView&#10;                android:layout_width=&quot;wrap_content&quot;&#10;                android:layout_height=&quot;wrap_content&quot;&#10;                android:text=&quot;Porcentaje de asistencia&quot;&#10;                android:textSize=&quot;16sp&quot;&#10;                android:textColor=&quot;@color/on_surface_variant&quot; /&gt;&#10;&#10;            &lt;TextView&#10;                android:id=&quot;@+id/attendancePercentageText&quot;&#10;                android:layout_width=&quot;wrap_content&quot;&#10;                android:layout_height=&quot;wrap_content&quot;&#10;                android:text=&quot;95%&quot;&#10;                android:textSize=&quot;32sp&quot;&#10;                android:textStyle=&quot;bold&quot;&#10;                android:textColor=&quot;@color/primary&quot;&#10;                android:layout_marginTop=&quot;8dp&quot; /&gt;&#10;&#10;            &lt;!-- Leyenda --&gt;&#10;            &lt;LinearLayout&#10;                android:orientation=&quot;horizontal&quot;&#10;                android:layout_width=&quot;match_parent&quot;&#10;                android:layout_height=&quot;wrap_content&quot;&#10;                android:layout_marginTop=&quot;16dp&quot;&gt;&#10;&#10;                &lt;TextView&#10;                    android:layout_width=&quot;wrap_content&quot;&#10;                    android:layout_height=&quot;wrap_content&quot;&#10;                    android:text=&quot;✅ Presente&quot;&#10;                    android:textSize=&quot;14sp&quot;&#10;                    android:layout_marginEnd=&quot;16dp&quot; /&gt;&#10;&#10;                &lt;TextView&#10;                    android:layout_width=&quot;wrap_content&quot;&#10;                    android:layout_height=&quot;wrap_content&quot;&#10;                    android:text=&quot;❌ Ausente&quot;&#10;                    android:textSize=&quot;14sp&quot;&#10;                    android:layout_marginEnd=&quot;16dp&quot; /&gt;&#10;&#10;                &lt;TextView&#10;                    android:layout_width=&quot;wrap_content&quot;&#10;                    android:layout_height=&quot;wrap_content&quot;&#10;                    android:text=&quot;⚠️ Tarde&quot;&#10;                    android:textSize=&quot;14sp&quot; /&gt;&#10;&#10;            &lt;/LinearLayout&gt;&#10;&#10;        &lt;/LinearLayout&gt;&#10;&#10;    &lt;/com.google.android.material.card.MaterialCardView&gt;&#10;&#10;    &lt;!-- Selector de mes --&gt;&#10;    &lt;LinearLayout&#10;        android:orientation=&quot;horizontal&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:gravity=&quot;center&quot;&#10;        android:padding=&quot;8dp&quot;&gt;&#10;&#10;        &lt;com.google.android.material.button.MaterialButton&#10;            android:id=&quot;@+id/previousMonthButton&quot;&#10;            android:layout_width=&quot;wrap_content&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:text=&quot;◀&quot;&#10;            style=&quot;@style/Widget.Material3.Button.TextButton&quot; /&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/currentMonthText&quot;&#10;            android:layout_width=&quot;0dp&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:layout_weight=&quot;1&quot;&#10;            android:text=&quot;Octubre 2025&quot;&#10;            android:textSize=&quot;18sp&quot;&#10;            android:textStyle=&quot;bold&quot;&#10;            android:textColor=&quot;@color/on_background&quot;&#10;            android:gravity=&quot;center&quot; /&gt;&#10;&#10;        &lt;com.google.android.material.button.MaterialButton&#10;            android:id=&quot;@+id/nextMonthButton&quot;&#10;            android:layout_width=&quot;wrap_content&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:text=&quot;▶&quot;&#10;            style=&quot;@style/Widget.Material3.Button.TextButton&quot; /&gt;&#10;&#10;    &lt;/LinearLayout&gt;&#10;&#10;    &lt;!-- RecyclerView para días --&gt;&#10;    &lt;androidx.recyclerview.widget.RecyclerView&#10;        android:id=&quot;@+id/attendanceRecyclerView&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;0dp&quot;&#10;        android:layout_weight=&quot;1&quot;&#10;        android:padding=&quot;8dp&quot;&#10;        android:clipToPadding=&quot;false&quot; /&gt;&#10;&#10;    &lt;!-- Progress bar --&gt;&#10;    &lt;ProgressBar&#10;        android:id=&quot;@+id/progressBar&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_gravity=&quot;center&quot;&#10;        android:visibility=&quot;gone&quot; /&gt;&#10;&#10;&lt;/LinearLayout&gt;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#13;&#10;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#13;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#13;&#10;    android:orientation=&quot;vertical&quot;&#13;&#10;    android:layout_width=&quot;match_parent&quot;&#13;&#10;    android:layout_height=&quot;match_parent&quot;&#13;&#10;    android:background=&quot;@color/background&quot;&gt;&#13;&#10;&#13;&#10;    &lt;!-- Toolbar/Header --&gt;&#13;&#10;    &lt;com.google.android.material.appbar.AppBarLayout&#13;&#10;        android:layout_width=&quot;match_parent&quot;&#13;&#10;        android:layout_height=&quot;wrap_content&quot;&#13;&#10;        android:background=&quot;@color/primary&quot;&gt;&#13;&#10;&#13;&#10;        &lt;androidx.appcompat.widget.Toolbar&#13;&#10;            android:id=&quot;@+id/toolbar&quot;&#13;&#10;            android:layout_width=&quot;match_parent&quot;&#13;&#10;            android:layout_height=&quot;?attr/actionBarSize&quot;&#13;&#10;            android:background=&quot;@color/primary&quot;&#13;&#10;            app:title=&quot;@string/attendance&quot;&#13;&#10;            app:titleTextColor=&quot;@color/on_primary&quot; /&gt;&#13;&#10;&#13;&#10;    &lt;/com.google.android.material.appbar.AppBarLayout&gt;&#13;&#10;&#13;&#10;    &lt;!-- Card con resumen de asistencia --&gt;&#13;&#10;    &lt;com.google.android.material.card.MaterialCardView&#13;&#10;        android:layout_width=&quot;match_parent&quot;&#13;&#10;        android:layout_height=&quot;wrap_content&quot;&#13;&#10;        android:layout_margin=&quot;16dp&quot;&#13;&#10;        app:cardBackgroundColor=&quot;@color/surface&quot;&#13;&#10;        app:cardElevation=&quot;4dp&quot;&#13;&#10;        app:cardCornerRadius=&quot;16dp&quot;&gt;&#13;&#10;&#13;&#10;        &lt;LinearLayout&#13;&#10;            android:orientation=&quot;vertical&quot;&#13;&#10;            android:layout_width=&quot;match_parent&quot;&#13;&#10;            android:layout_height=&quot;wrap_content&quot;&#13;&#10;            android:padding=&quot;16dp&quot;&gt;&#13;&#10;&#13;&#10;            &lt;TextView&#13;&#10;                android:layout_width=&quot;wrap_content&quot;&#13;&#10;                android:layout_height=&quot;wrap_content&quot;&#13;&#10;                android:text=&quot;Porcentaje de asistencia&quot;&#13;&#10;                android:textSize=&quot;16sp&quot;&#13;&#10;                android:textColor=&quot;@color/on_surface_variant&quot; /&gt;&#13;&#10;&#13;&#10;            &lt;TextView&#13;&#10;                android:id=&quot;@+id/attendancePercentageText&quot;&#13;&#10;                android:layout_width=&quot;wrap_content&quot;&#13;&#10;                android:layout_height=&quot;wrap_content&quot;&#13;&#10;                android:text=&quot;95%&quot;&#13;&#10;                android:textSize=&quot;32sp&quot;&#13;&#10;                android:textStyle=&quot;bold&quot;&#13;&#10;                android:textColor=&quot;@color/primary&quot;&#13;&#10;                android:layout_marginTop=&quot;8dp&quot; /&gt;&#13;&#10;&#13;&#10;            &lt;!-- Leyenda --&gt;&#13;&#10;            &lt;LinearLayout&#13;&#10;                android:orientation=&quot;horizontal&quot;&#13;&#10;                android:layout_width=&quot;match_parent&quot;&#13;&#10;                android:layout_height=&quot;wrap_content&quot;&#13;&#10;                android:layout_marginTop=&quot;16dp&quot;&gt;&#13;&#10;&#13;&#10;                &lt;TextView&#13;&#10;                    android:layout_width=&quot;wrap_content&quot;&#13;&#10;                    android:layout_height=&quot;wrap_content&quot;&#13;&#10;                    android:text=&quot;✅ Presente&quot;&#13;&#10;                    android:textSize=&quot;14sp&quot;&#13;&#10;                    android:layout_marginEnd=&quot;16dp&quot; /&gt;&#13;&#10;&#13;&#10;                &lt;TextView&#13;&#10;                    android:layout_width=&quot;wrap_content&quot;&#13;&#10;                    android:layout_height=&quot;wrap_content&quot;&#13;&#10;                    android:text=&quot;❌ Ausente&quot;&#13;&#10;                    android:textSize=&quot;14sp&quot;&#13;&#10;                    android:layout_marginEnd=&quot;16dp&quot; /&gt;&#13;&#10;&#13;&#10;                &lt;TextView&#13;&#10;                    android:layout_width=&quot;wrap_content&quot;&#13;&#10;                    android:layout_height=&quot;wrap_content&quot;&#13;&#10;                    android:text=&quot;⚠️ Tarde&quot;&#13;&#10;                    android:textSize=&quot;14sp&quot; /&gt;&#13;&#10;&#13;&#10;            &lt;/LinearLayout&gt;&#13;&#10;&#13;&#10;        &lt;/LinearLayout&gt;&#13;&#10;&#13;&#10;    &lt;/com.google.android.material.card.MaterialCardView&gt;&#13;&#10;&#13;&#10;    &lt;!-- Selector de mes --&gt;&#13;&#10;    &lt;LinearLayout&#13;&#10;        android:orientation=&quot;horizontal&quot;&#13;&#10;        android:layout_width=&quot;match_parent&quot;&#13;&#10;        android:layout_height=&quot;wrap_content&quot;&#13;&#10;        android:gravity=&quot;center&quot;&#13;&#10;        android:padding=&quot;8dp&quot;&gt;&#13;&#10;&#13;&#10;        &lt;com.example.appcolegios.ui.AnimatedMaterialButton&#13;&#10;            android:id=&quot;@+id/previousMonthButton&quot;&#13;&#10;            android:layout_width=&quot;wrap_content&quot;&#13;&#10;            android:layout_height=&quot;wrap_content&quot;&#13;&#10;            android:text=&quot;◀&quot;&#13;&#10;            style=&quot;@style/Widget.Material3.Button.TextButton&quot; /&gt;&#13;&#10;&#13;&#10;        &lt;TextView&#13;&#10;            android:id=&quot;@+id/currentMonthText&quot;&#13;&#10;            android:layout_width=&quot;0dp&quot;&#13;&#10;            android:layout_height=&quot;wrap_content&quot;&#13;&#10;            android:layout_weight=&quot;1&quot;&#13;&#10;            android:text=&quot;Octubre 2025&quot;&#13;&#10;            android:textSize=&quot;18sp&quot;&#13;&#10;            android:textStyle=&quot;bold&quot;&#13;&#10;            android:textColor=&quot;@color/on_background&quot;&#13;&#10;            android:gravity=&quot;center&quot; /&gt;&#13;&#10;&#13;&#10;        &lt;com.example.appcolegios.ui.AnimatedMaterialButton&#13;&#10;            android:id=&quot;@+id/nextMonthButton&quot;&#13;&#10;            android:layout_width=&quot;wrap_content&quot;&#13;&#10;            android:layout_height=&quot;wrap_content&quot;&#13;&#10;            android:text=&quot;▶&quot;&#13;&#10;            style=&quot;@style/Widget.Material3.Button.TextButton&quot; /&gt;&#13;&#10;&#13;&#10;    &lt;/LinearLayout&gt;&#13;&#10;&#13;&#10;    &lt;!-- RecyclerView para días --&gt;&#13;&#10;    &lt;androidx.recyclerview.widget.RecyclerView&#13;&#10;        android:id=&quot;@+id/attendanceRecyclerView&quot;&#13;&#10;        android:layout_width=&quot;match_parent&quot;&#13;&#10;        android:layout_height=&quot;0dp&quot;&#13;&#10;        android:layout_weight=&quot;1&quot;&#13;&#10;        android:padding=&quot;8dp&quot;&#13;&#10;        android:clipToPadding=&quot;false&quot; /&gt;&#13;&#10;&#13;&#10;    &lt;!-- Progress bar --&gt;&#13;&#10;    &lt;ProgressBar&#13;&#10;        android:id=&quot;@+id/progressBar&quot;&#13;&#10;        android:layout_width=&quot;wrap_content&quot;&#13;&#10;        android:layout_height=&quot;wrap_content&quot;&#13;&#10;        android:layout_gravity=&quot;center&quot;&#13;&#10;        android:visibility=&quot;gone&quot; /&gt;&#13;&#10;&#13;&#10;&lt;/LinearLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>